<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sl&#39;s learning notes</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-03-17T02:44:59.112Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>_Silhouttes</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Cpp_learningnote2</title>
    <link href="http://yoursite.com/2021/03/17/Cpp-learning-note-2/"/>
    <id>http://yoursite.com/2021/03/17/Cpp-learning-note-2/</id>
    <published>2021-03-16T16:00:00.000Z</published>
    <updated>2021-03-17T02:44:59.112Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>reference：《黑马》C++系列教程 <a href="https://blog.csdn.net/ClaireSy/article/details/108422945" target="_blank" rel="noopener">基础</a> <a href="https://blog.csdn.net/ClaireSy/article/details/108423047" target="_blank" rel="noopener">核心</a> <a href="https://blog.csdn.net/ClaireSy/article/details/108423061" target="_blank" rel="noopener">提高</a></p><blockquote><p>本篇主要参考核心篇进行记录</p></blockquote><h2 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h2><ul><li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li><li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li></ul><p>在C++中主要利用new在堆区开辟内存，释放利用操作符 delete，note释放数组 delete 后加 []</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><p>不要返回局部变量引用，可以返回静态变量引用 static</p></li><li><p>引用的本质，在C++内部实现是一个指针常量</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; ref = a;</span><br><span class="line"><span class="comment">//自动转化为int* const ref = &amp;a; 指针常量是指针指向不可改</span></span><br></pre></td></tr></table></figure><ul><li>在函数形参列表中，可以加const修饰形参，防止形参改变实参</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; ref = <span class="number">10</span>;  <span class="comment">//是错误的，引用本身需要一个合法的内存空间，不能直接赋值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//加入const，编译器会优化代码，int temp = 10; const int&amp; ref = temp;</span></span><br></pre></td></tr></table></figure><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.引用作为重载条件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>&amp; a)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> a </span>= <span class="number">10</span>;</span><br><span class="line">func(a);</span><br><span class="line">func(<span class="number">10</span>);<span class="comment">//调用不同的函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.函数重载遇到函数默认参数</span></span><br><span class="line">func2(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>)</span><br><span class="line">func2(<span class="keyword">int</span> a)</span><br><span class="line"><span class="comment">//这样的定义在调用的时候会报错</span></span><br><span class="line">func2(<span class="number">10</span>);<span class="comment">//产生歧义，不能做出调用函数的判断</span></span><br></pre></td></tr></table></figure><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><blockquote><p>OOP - <strong>封装、继承、多态</strong></p></blockquote><p>一、about <strong>类</strong></p><ul><li>语法：class 类名{ 访问权限: 属性 / 行为};</li><li>类在设计时，可以把属性和行为放在不同权限下，加以控制</li></ul><p>访问权限有三种：</p><p>– public 公共权限：        类内可以访问，类外可以访问（只允许本类的成员函数访问） </p><p>– protected 保护权限 ：类内可以访问，类外不可以访问 （只允许子类及本类的成员函数访问）</p><p>– private 私有权限：      类内可以访问，类外不可以访问（可以被任意实体访问）</p><ul><li>在C++中 struct 和 class 唯一的区别就在于默认的访问权限不同，struct默认权限为公共，class默认权限为私有</li></ul><p>二、concerning <strong>对象</strong></p><ul><li>对象的初始化和清理 – 构造函数和析构函数</li></ul><p>如果编程者不提供，编译器会自动提供空实现的构造和析构函数（这时候编译器自动添加的拷贝构造对属性的拷贝是浅拷贝</p><p><strong>–构造函数语法</strong>： 类名(){}</p><ol><li>构造函数没有返回值也不写void</li><li>函数名称与类名相同</li><li>构造函数可以参数，可能发生函数重载</li><li>程序在调用对象的时候会自动调用构造，且只调用一次</li></ol><p><strong>分类</strong> 按参数：有参构造、无参构造 按类型：普通构造、拷贝构造</p><p><strong>调用方式</strong> 括号法、显式法（类似java）、隐式转换法</p><p>*tips:</p><ol><li><p>调用无参构造函数不能加括号，加了编译器认为这是一个函数声名；</p></li><li><p>不能利用拷贝构造函数初始化匿名对象，编译器认为是对象声明；</p></li><li>拷贝构造函数的调用时机：<ul><li>使用一个已创建好的对象初始化新的对象</li><li>值传递的方式给函数参数传值</li><li>以值的方式返回局部对象 </li></ul></li></ol><p><strong>– 析构函数语法</strong>：~类名(){}</p><ol><li>析构函数没有返回值也不写void</li><li>函数名称与类名相同，前面加上符号~</li><li>析构函数不可以有参数，不能发生重载</li><li>程序在对象销毁前会自动调用析构，且只调用一次</li></ol><p>（一）深拷贝与浅拷贝</p><p>浅拷贝：简单的赋值拷贝操作</p><p>深拷贝：在<strong>堆区</strong>重新申请空间进行拷贝操作</p><p>如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的在delete时出现的问题</p><p>new -&gt; 在堆空间创建一块内存并返回内存地址给指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);<span class="comment">//这里定义变量类型为指针</span></span><br></pre></td></tr></table></figure><p>（二）初始化列表</p><p>语法：构造函数(): 属性1(值1)， 属性2(值2), …{}</p><p>只有构造函数可以使用初始化列表语法，引用数据成员与const数据成员必须使用这种语法，因为它们在创建时就需要初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c) :m_A(a), m_B(b), m_C(c) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_A:</span><br><span class="line"><span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">int</span> m_C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（三）类对象作为类成员</p><p>当类中成员时其他类对象时，我们称该成员为 对象成员</p><p>构造的顺序是：先调用对象成员的构造，再调用本类构造。析构的顺序与构造相反</p><p>（四）静态成员</p><p>在成员变量和成员函数前加上关键字static，称为静态成员</p><ul><li><p>静态成员变量（2种访问方式：通过对象、通过类名）</p><ul><li>所有对象共享同一份数据</li><li>在编译阶段分配内存</li><li><strong>类内声明，类外初始化</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> Person::m_B = <span class="number">10</span>;<span class="comment">//类外初始化</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Person::m_A &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//通过类名访问</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Person::m_B &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//会报错，没有访问权限</span></span><br></pre></td></tr></table></figure></li><li><p>静态成员函数</p><ul><li>所有对象共享同一个函数</li><li>静态成员函数只能访问静态成员变量</li></ul></li></ul><p>三、C++对象模型和this指针</p><p>在C++中，类内的成员变量和成员函数 分开储存，只有非静态成员变量才属于类的对象上。非静态成员变量占用对象空间，而静态成员变量和成员函数（静态/非静态）都不占用对象空间，所有非静态成员函数共享一个函数实例。</p><ul><li><p><strong>this指针</strong> 指向被调用成员函数所属的对象</p><ul><li>this指针是隐含在每一个<strong>非静态成员函数内</strong>的一种指针</li><li>不需要定义可以直接使用</li><li>用途：当形参和成员变量同名时，用this指针区分；在类的非静态成员函数中返回对象本身，可使用return *this</li><li>空指针也可以调用成员函数，但是当成员函数用到了this指针则不可以，这个时候需要对指针进行非空判断，保证代码的健壮性</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person* p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == <span class="literal">NULL</span>) <span class="keyword">return</span>;<span class="comment">//非空判断</span></span><br></pre></td></tr></table></figure><ul><li><strong>常函数</strong>：成员函数后加const​，在常函数内不可以修改成员属性，但是当成员属性声明时添加mutable关键字，在常函数内仍可以进行修改</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;...&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">mutable</span> <span class="keyword">int</span> m_B;</span><br></pre></td></tr></table></figure><ul><li><strong>常对象</strong>：声明对象前加const，常对象只能调用常函数，不能修改成员变量的值，但是可以访问</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person person;</span><br></pre></td></tr></table></figure></li></ul><p>四、友元 -&gt; 让一个函数或者类访问另一个类中的私有成员</p><p><strong>关键字</strong> friend</p><p>三种实现</p><ul><li>全局函数左右元</li><li>类做友元</li><li>成员函数做友元</li></ul><p>五、运算符重载 -&gt; 对已有的运算符重新进行定义，赋予另一种功能，以适应不同的数据类型</p><p>函数名由关键字 operator 和其后要进行重载的运算符符号构成的</p><p>通俗理解就是将数的相加、输出、比较判断等运算重载为直接对对象进行操作</p><p>六、<strong>继承</strong></p><p>class A: public B { }; 其中A类称为子类 或 派生类，B类成为父类 或 基类</p><p>派生类中的成员包含从基类继承的和自己增加的成员</p><ul><li>继承方式 语法： class 子类: 继承方式 父类<ul><li>公共继承 public</li><li>保护继承 protected</li><li>私有继承 private</li></ul></li></ul><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">public</th><th>protected</th><th>private</th></tr></thead><tbody><tr><td style="text-align:left">公有继承</td><td style="text-align:left">public</td><td>protected</td><td>不可见</td></tr><tr><td style="text-align:left">保护继承</td><td style="text-align:left">protected</td><td>protected</td><td>不可见</td></tr><tr><td style="text-align:left">私有继承</td><td style="text-align:left">private</td><td>private</td><td>不可见</td></tr></tbody></table><p>tips：</p><ol><li><p>父类中私有成员也被子类继承下去了，只是由编译器隐藏后不能访问</p></li><li><p>继承中，先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p></li></ol><ul><li>继承同名成员的处理方式<ul><li>访问子类同名成员 直接访问即可</li><li>访问父类同名成员 需要添加作用域</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base()&#123;m_A = <span class="number">100</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Son()&#123;m_A = <span class="number">200</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line">    s.func();<span class="comment">//直接访问子类同名成员</span></span><br><span class="line">    s.Base::func();<span class="comment">//添加作用域访问父类同名成员</span></span><br><span class="line">&#125;<span class="comment">//这里是子类以对象的方式进行访问</span></span><br></pre></td></tr></table></figure><p>*tips：对于同名静态成员处理方式与上面相同，不过有通过对象和通过类名两种访问方式</p><ul><li>多继承语法：class 子类: 继承方式 父类1, 继承方式 父类2 …</li><li>菱形继承（草泥马的例子好形象2333)</li></ul><blockquote><p>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承前加virtual关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">//此时公共的父类Animal称为虚基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuo</span>   :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheepTuo</span> :</span> <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SheepTuo st;</span><br><span class="line">st.Sheep::m_Age = <span class="number">100</span>;</span><br><span class="line">st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"st.Sheep::m_Age = "</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"st.Tuo::m_Age = "</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"st.m_Age = "</span> &lt;&lt; st.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*tips：采用虚继承解决菱形继承的问题，虚继承的目的是让某个类做出声明，承诺愿意共享它的基类</p><p>七、<strong>多态</strong></p><p>分类：</p><ul><li>静态多态：函数重载和运算符重载属于静态多态，复用函数名</li><li>动态多态：派生类和虚函数实现运行时多态</li></ul><p>区别：静态–函数地址早绑定 - 编译阶段确定函数地址</p><p>动态–函数地址晚绑定 - 运行阶段确定函数地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//函数前加上virtual关键字，变成虚函数，编译器在编译的时候就不能确定函数调用</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span><span class="keyword">public</span> Animal&#123;<span class="comment">//继承Animal类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//Q:这里为virtual为什么可以省略不写</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span><span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSpeak</span><span class="params">(Animal &amp; animal)</span></span>&#123;</span><br><span class="line">    animal.speak();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Cat cat;</span><br><span class="line">    DoSpeak(cat);<span class="comment">//传入什么对象，就调用什么对象的寒素</span></span><br><span class="line">    Dog dog;</span><br><span class="line">    DoSpeak(dog);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多态满足条件：1. 有继承关系 2. 子类重写父类中的虚函数</li><li>多态使用：父类指针或引用指向子类对象</li></ul><p>重写：函数返回值类型 函数名 参数列表 完全一致称为重写</p><p>在多态中，通常父类中虚函数饿实现是毫无意义的，主要都是调用子类重写的内容</p><p>因此可以将虚函数改为<strong>纯虚函数</strong></p><ul><li>纯虚函数语法：virtual 返回值类型 函数名 (参数列表) = 0;</li></ul><p>当类中有了虚函数（虚构造函数或虚析构函数），这个类也成为<strong>抽象类</strong>（类中只要有一个纯虚函数就成为抽象类）</p><p>抽象类特点：</p><ol><li><p>无法实例化对象</p></li><li><p>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</p></li></ol><p>Q：多态使用时，子类中开辟属性到堆区（new），父类指针在释放时无法调用子类的析构代码</p><p>A：将父类中的析构函数改为<strong>虚析构</strong>或<strong>纯虚析构</strong></p><ul><li>虚析构和纯虚析构共性：<ul><li>可以解决父类指针释放子类对象的问题</li><li>都需要有具体的函数实现</li></ul></li><li>虚析构和纯虚析构区别：<ul><li>纯虚析构，该类属于抽象类，无法实例化对象</li></ul></li></ul><p>虚析构语法：virtual ~类名 () {}</p><p>纯虚析构语法：类内 -&gt; virtual ~类名() = 0;  类外 -&gt; 类名::~类名() {}</p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>C++中对文件操作许哟啊包含头文件<code>&lt;fstream&gt;</code></p><p>文件类型：</p><ol><li>文本文件：以ASCII码形式储存在计算机中</li><li>二进制文件：以二进制形式存储在计算机中</li></ol><p>操作文件的三大类：</p><ol><li>ofstream：写操作</li><li>ifstream：读操作</li><li>fstream：读写操作</li></ol><h3 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h3><ul><li>写文件<ol><li>包含头文件<code>#include&lt;fstream&gt;</code></li><li>创建流对象<code>ofstream ofs;</code></li><li>打开文件<code>ofs.open(&quot;file_path&quot;, way);</code></li><li>写数据<code>ofs&lt;&lt;&quot;writing data&quot;;</code></li><li>关闭文件<code>ofs.close();</code></li></ol></li><li>文件打开方式</li></ul><table><thead><tr><th style="text-align:center">打开方式</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">ios::in</td><td style="text-align:center">为读文件而打开文件</td></tr><tr><td style="text-align:center">ios::out</td><td style="text-align:center">为写文件而打开文件</td></tr><tr><td style="text-align:center">ios::ate</td><td style="text-align:center">初始位置：文件尾</td></tr><tr><td style="text-align:center">ios::app</td><td style="text-align:center">追加方式写文件</td></tr><tr><td style="text-align:center">ios::trunc</td><td style="text-align:center">如果文件存在先删除，再创建</td></tr><tr><td style="text-align:center">ios::binary</td><td style="text-align:center">二进制方式</td></tr></tbody></table><p>文件打开方式可以配合使用，利用<code>|</code>操作符</p><p>e.g. 用二进制方式写文件<code>ios::binary|ios::out</code></p><ul><li><p>读文件</p><ol><li><p>包含头文件<code>#include&lt;fstream&gt;</code></p></li><li><p>创建流对象<code>ifstream ifs;</code></p></li><li><p>打开文件<code>ifs.open(&quot;file_path&quot;, way);</code>，利用<code>is_open</code>函数可以判断文件是否打开成功</p></li><li><p>读数据 四种方式</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(ifs &gt;&gt; buf)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(ifs.getline(buf, <span class="keyword">sizeof</span>(buf)))&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> buf;</span><br><span class="line"><span class="keyword">while</span>(getline(ifs, buf))&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">while</span>((c = ifs.get()) != EOF)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>关闭文件<code>ifs.close();</code></p></li></ol></li></ul><h3 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h3><p>打开方式指定为<code>ios::binary</code></p><ul><li>写文件 利用流对象调用成员函数wirte</li></ul><p>函数原型 <code>ofstream&amp; write(const char * buffer,int len);</code></p><ul><li>写文件 利用流对象调用成员函数read</li></ul><p>函数原型 <code>ifstream&amp; read(char *buffer,int len);</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;reference：《黑马》C++系列教程 &lt;a href=&quot;https://blog.csdn.net/ClaireSy/article/details/108422945&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;基础&lt;/</summary>
      
    
    
    
    
    <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Cpp_learningnote3</title>
    <link href="http://yoursite.com/2021/03/17/Cpp-learning-note-3/"/>
    <id>http://yoursite.com/2021/03/17/Cpp-learning-note-3/</id>
    <published>2021-03-16T16:00:00.000Z</published>
    <updated>2021-03-17T02:45:17.535Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>reference：《黑马》C++系列教程 <a href="https://blog.csdn.net/ClaireSy/article/details/108422945" target="_blank" rel="noopener">基础</a> <a href="https://blog.csdn.net/ClaireSy/article/details/108423047" target="_blank" rel="noopener">核心</a> <a href="https://blog.csdn.net/ClaireSy/article/details/108423061" target="_blank" rel="noopener">提高</a></p><blockquote><p>本篇主要参考提高篇进行记录</p></blockquote><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ul><li><p>模板就是建立通用的模具，提高复用性。模板只是一个框架，不能直接使用</p></li><li><p><strong>函数模板</strong></p><ul><li>C++另一种编程思想称为 <strong>泛型编程</strong>，主要利用的技术就是模板</li><li>C++提供两种模板机制：函数模板 和 类模板</li></ul></li></ul><p>函数模板语法：<code>template&lt;typename T&gt;</code>，其中typename可以用class代替</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T&amp; a,T&amp; b)</span></span>&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>,b = <span class="number">20</span>;</span><br><span class="line">Swap(a, b);<span class="comment">//1.自动类型推导</span></span><br><span class="line">Swap&lt;<span class="keyword">int</span>&gt;(a, b);<span class="comment">//2.显示指定类型</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*tips：</p><ol><li><p>自动类型推导，必须推导出<strong>一致的数据类型T</strong>才可以使用</p></li><li><p>显示指定类型，必须<strong>确定出T的数据类型</strong>才可以使用</p></li></ol><p>也就是说，凡是给出了模板定义，之后跟着的函数，必须给出数据类型才能调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"test"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="comment">//函数中没用用到模板类型T，但是调用时必须给出才能使用</span></span><br></pre></td></tr></table></figure><ul><li>普通函数与函数模板的区别</li></ul><ol><li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li><li>函数模板调用的时候，如果利用自动类型推导，不会发生隐式类型转换</li><li>如果利用显式指定类型的方式，可以发生隐式类型转换</li></ol><ul><li>普通函数与函数模板的调用规则</li></ul><ol><li>如果函数模板和普通函数都可以实现，优先调用普通函数</li><li>可以通过空模板参数列表来强制调用函数模板  <code>funtion&lt;&gt;(a, b);</code></li><li>函数模板也可以发生重载</li><li>如果函数模板可以产生更好的匹配（例如不用进行隐式转换），优先调用函数模板</li></ol><ul><li>模板的局限性：传入数组、类对象、自定义数据类型等数据不能处理，可以为这些特定的类型提供具体化的模板</li></ul><p>具体化的模板以<code>template&lt;&gt;</code>开头，通过名称来指出类型，具体化优先于常规模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;&gt; <span class="keyword">bool</span> <span class="title">compare</span><span class="params">(Person&amp; p1, Person&amp; p2)</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>类模板</strong></li></ul><p>建立一个通用类，类中的成员数据类型可以不具体指定，用一个虚拟的类型来代表</p><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1， <span class="keyword">typename</span> T2, ...&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span></span></span><br></pre></td></tr></table></figure><ul><li>类模板与函数模板的区别</li></ul><ol><li>类模板<strong>没有自动类型推导</strong>的使用方式</li><li>类模板在模板参数列表中可以有默认参数（在显示指定的时候可以更换参数类型，如int-&gt;double）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">nametype</span>, <span class="title">class</span> <span class="title">agetype</span> = <span class="title">int</span>&gt;//2.<span class="title">defualt</span> <span class="title">parameter</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Person</span>&#123;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Person &lt;string, double&gt;p('string',10);//1.显示指定</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类模板中的成员函数并不是一开始就创建的，在调用的时候才会创建</li><li>类模板对象做函数参数</li></ul><ol><li>指定传入的类型 – 直接显示对象的数据类型</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; &amp;p)</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>参数模板化 – 将对象中的参数变为模板进行传递</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">printPerson2</span>(<span class="title">Person</span>&lt;T1, T2&gt;&amp;<span class="title">p</span>)&#123;</span></span><br><span class="line">p.showPerson();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"T1的类型为： "</span> &lt;&lt; <span class="keyword">typeid</span>(T1).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"T2的类型为： "</span> &lt;&lt; <span class="keyword">typeid</span>(T2).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>整个类模板化 – 将这个对象类型模板化进行传递</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">printPerson3</span>(<span class="title">T</span> &amp; <span class="title">p</span>)&#123;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"T的类型为： "</span> &lt;&lt; <span class="keyword">typeid</span>(T).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">p.showPerson();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;reference：《黑马》C++系列教程 &lt;a href=&quot;https://blog.csdn.net/ClaireSy/article/details/108422945&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;基础&lt;/</summary>
      
    
    
    
    
    <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>makefile</title>
    <link href="http://yoursite.com/2021/03/17/Makefile/"/>
    <id>http://yoursite.com/2021/03/17/Makefile/</id>
    <published>2021-03-16T16:00:00.000Z</published>
    <updated>2021-03-17T02:46:00.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Makefile-learning"><a href="#Makefile-learning" class="headerlink" title="Makefile_learning"></a>Makefile_learning</h2><blockquote><p>教程：<a href="http://c.biancheng.net/makefile/" target="_blank" rel="noopener">http://c.biancheng.net/makefile/</a></p></blockquote><p>makefile描述的是文件编译的相关规则，由依赖的关系和执行的命令两部分组成</p><ul><li>结构：</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">targets: prerequisites</span></span><br><span class="line">command</span><br></pre></td></tr></table></figure><ul><li>targets：规则的目标，可以是中间文件（*.o），也可以是执行文件（*.elf），还可以是一个标签（clean等）</li><li>prerequisites：依赖文件，要生成targets需要的文件或目标</li><li>command：make需要执行的命令（任意的shell命令）</li></ul><blockquote><p>attention：目标和依赖之间要用冒号分隔开，命令的开始一定要使用<code>tab</code>键</p></blockquote><h3 id="makefile的工作流程"><a href="#makefile的工作流程" class="headerlink" title="makefile的工作流程"></a>makefile的工作流程</h3><p>默认情况下，make执行的是Makefile中的第一规则（Makefile中出现的第一个依赖关系），此规则的第一目标称为“最终目标”，根据依赖关系查找下一条要执行的规则。</p><p>这里我们知道，编译时生成的 “.o” 文件。作用是检查某个源文件是不是进行过修改，最终目标文件是不是需要重建。</p><p>清除过程文件：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf *.0 test</span><br></pre></td></tr></table></figure><p>Makefile文件所在目录有文件名为clean的文件，命令行“.PHONY: clean”又没添加的话，执行make clean是无效的，“.PHONY: clean”就是保证即使目录下有文件名为clean的文件，也能正常执行make clean</p><h3 id="通配符的使用"><a href="#通配符的使用" class="headerlink" title="通配符的使用"></a>通配符的使用</h3><p>通配符可以出现在模式的规则中，也可以出现在命令中</p><table><thead><tr><th>通配符</th><th>使用说明</th></tr></thead><tbody><tr><td>*</td><td>匹配0个或者是任意个字符</td></tr><tr><td>？</td><td>匹配任意一个字符</td></tr><tr><td>[]</td><td>我们可以指定匹配的字符放在 “[]” 中</td></tr><tr><td>%</td><td>匹配任意个字符，储存名字在一个列表中，挨个查找</td></tr></tbody></table><ul><li>如果我们的通配符使用在<strong>依赖的规则中</strong>的话一定要注意这个问题：不能通过引用变量的方式来使用，但就是想要通过引用变量的话，我们要使用一个函数 “wildcard”，这个函数在我们引用变量的时候，会帮我们展开</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OBJ = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"><span class="section">test: <span class="variable">$(OBJ)</span></span></span><br><span class="line">gcc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure><h3 id="变量的定义和使用"><a href="#变量的定义和使用" class="headerlink" title="变量的定义和使用"></a>变量的定义和使用</h3><ul><li>基本语法<code>VALUE_LIST = one two three</code></li></ul><p>调用变量的时候用<code>$(VALUE_LIST)</code>或<code>${VALUE_LIST}</code>来替换</p><ul><li>四种基本赋值方式<ul><li>简单赋值（:=）只对当前语句的变量有效</li><li>递归赋值（=）所有目标变量相关的其他变量都受影响</li><li>条件赋值（?=）如果变量未定义，则使用符号中的值（等号后的值）定义变量，如果变量已经赋值，则该赋值语句无效（保持原定义的值）</li><li>追加赋值（+=）原变量用空格隔开的方式追加一个新值</li></ul></li></ul><h3 id="makefile自动化变量"><a href="#makefile自动化变量" class="headerlink" title="makefile自动化变量"></a>makefile自动化变量</h3><p>自动化变量可以理解为由 Makefile 自动产生的变量，自动化变量的取值根据执行的规则来决定，取决于执行规则的目标问价和依赖文件。</p><table><thead><tr><th>自动化变量</th><th>说明</th></tr></thead><tbody><tr><td>$@</td><td>表示规则的目标文件名。如果目标是一个文档文件（Linux 中，一般成 .a 文件为文档文件，也成为静态的库文件）， 那么它代表这个文档的文件名。在多目标模式规则中，它代表的是触发规则被执行的文件名。</td></tr><tr><td>$%</td><td>当目标文件是一个静态库文件时，代表静态库的一个成员名。</td></tr><tr><td>$&lt;</td><td>规则的第一个依赖的文件名。如果是一个目标文件使用隐含的规则来重建，则它代表由隐含规则加入的第一个依赖文件。</td></tr><tr><td>$?</td><td>所有比目标文件更新的依赖文件列表，空格分隔。如果目标文件时静态库文件，代表的是库文件（.o 文件）。</td></tr><tr><td>$^</td><td>代表的是所有依赖文件列表，使用空格分隔。如果目标是静态库文件，它所代表的只能是所有的库成员（.o 文件）名。 一个文件可重复的出现在目标的依赖中，变量“$^”只记录它的第一次引用的情况。就是说变量“$^”会去掉重复的依赖文件。</td></tr><tr><td>$+</td><td>类似“$^”，但是它保留了依赖文件中重复出现的文件。主要用在程序链接时库的交叉引用场合。</td></tr><tr><td>$*</td><td>在模式规则和静态模式规则中，代表“茎”。“茎”是目标模式中“%”所代表的部分（当文件名中存在目录时， “茎”也包含目录部分）。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Makefile-learning&quot;&gt;&lt;a href=&quot;#Makefile-learning&quot; class=&quot;headerlink&quot; title=&quot;Makefile_learning&quot;&gt;&lt;/a&gt;Makefile_learning&lt;/h2&gt;&lt;blockquote&gt;
</summary>
      
    
    
    
    
    <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Cpp learning note</title>
    <link href="http://yoursite.com/2020/12/19/Cpp-learning-note/"/>
    <id>http://yoursite.com/2020/12/19/Cpp-learning-note/</id>
    <published>2020-12-19T09:37:52.000Z</published>
    <updated>2020-12-20T03:24:45.453Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为项目而学习C++</p><p>学习资源：<a href="https://www.icourse163.org/course/NWPU-494001?tid=1450728827" target="_blank" rel="noopener">西北工业大学 C++程序设计</a>、<a href="https://www.icourse163.org/course/QDU-1458424165" target="_blank" rel="noopener">青岛大学 面向对象程序设计（C++和Java）</a></p><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>C++允许在函数定义或声明时，为形参指定默认值，这样的参数称为默认参数。</p><p>（1）如果在函数定义时设置了默认参数，那么就不能在函数声明中再次设置，反之亦然。</p><p>（2）可以设置多个默认参数，设置的顺序自右向左，即要设置默认值的参数右边的所有参数都必须是默认参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">volume</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> W, <span class="keyword">int</span> H = <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">volume</span><span class="params">(<span class="keyword">int</span> L = <span class="number">1</span>, <span class="keyword">int</span> W = <span class="number">1</span>, <span class="keyword">int</span> H = <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="comment">//上面都是正确的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">volume</span><span class="params">(<span class="keyword">int</span> L = <span class="number">1</span>, <span class="keyword">int</span> W, <span class="keyword">int</span> H)</span></span>;<span class="comment">//错误</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">volume</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> W = <span class="number">1</span>; <span class="keyword">int</span> H)</span></span>;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure><p>（3）默认值可以是常量、全局变量和函数调用（调用实参必须是常量或全局变量的表达式，不可以是局部变量）</p><a id="more"></a><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>function overloading是在同一个域中用同一个函数名来定义多个函数，但是函数参数列表彼此不同（个数不同或参数类型不同）</p><ul><li>编译程序将根据实参和形参的类型和个数的最佳匹配来选择调用哪一个函数</li></ul><h3 id="数组作为函数的参数"><a href="#数组作为函数的参数" class="headerlink" title="数组作为函数的参数"></a>数组作为函数的参数</h3><p>如果实参使用数组名，本质上是将这个数组的首地址传递到形参中。数组实参a传递的是数组首地址，形参A定义为数组形式，此时A 的地址与a一样，本质上形参数组A就是实参数组a（内存中两个对象所处位置相同，则实际上它们是同一个对象）</p><blockquote><p>和指针类似，指针传递的也是地址，这样做可以直接改变多个数组元素，而不用返回</p></blockquote><h3 id="数组参数的传递机制"><a href="#数组参数的传递机制" class="headerlink" title="数组参数的传递机制"></a>数组参数的传递机制</h3><ul><li>数组作为函数的参数，传递的是数组的地址（数组在内存中是一段区域内连续的）</li></ul><p>（1）在被调函数中使用形参就是间接使用实参（与变量不同）</p><p>（2）函数调用时不会为形参数组分配存储空间，即形参数组的长度无实际作用，所以形参数组甚至可不给出长度</p><p>（3）函数如何知道数组的长度-&gt;函数调用时再给出一个参数来表示实参数组的长度</p><p>（4）多维数组作为函数的参数，形参数组除第一维任意，其他维的长度需要与实参数组相同</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>C++语言规定字符串是以’\0’字符作为结束符的<strong>字符数组</strong>，空字符表示字符串的结束位置</p><p>定义字符数组的长度至少为字符串长度加1（空字符占1位）</p><p>C++在编译时自动在字符串常量后增加一个空字符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++中兼容C语言的字符串处理函数的头文件string.h</span></span><br><span class="line"><span class="built_in">strcpy</span>(str1, str2);<span class="comment">//copy</span></span><br><span class="line"><span class="built_in">strncpy</span>(str1, str2, n);<span class="comment">//copy前n个</span></span><br><span class="line"><span class="built_in">strcat</span>(str1, str2);<span class="comment">//连接</span></span><br><span class="line"><span class="built_in">strncat</span>(str1, str2, n);<span class="comment">//连接前n个</span></span><br><span class="line"><span class="built_in">strcmp</span>(str1, str2);<span class="comment">//比较字符串</span></span><br><span class="line"><span class="built_in">strlen</span>(str);<span class="comment">//length</span></span><br><span class="line">atof(<span class="string">"123.456"</span>);</span><br><span class="line">atoi(<span class="string">"-456"</span>);<span class="comment">//string转换成数值函数</span></span><br></pre></td></tr></table></figure><h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><p>采用类来实现字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> S1[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">string</span> str1;</span><br><span class="line"><span class="keyword">char</span> S2[<span class="number">20</span>] = <span class="string">"Java"</span>;<span class="comment">//C风格字符串初始化</span></span><br><span class="line"><span class="built_in">string</span> str2 = <span class="string">"Java"</span>;<span class="comment">//string对象copy初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str3</span><span class="params">(<span class="string">"Java"</span>)</span></span>;<span class="comment">//string对象直接初始化</span></span><br></pre></td></tr></table></figure><p>string对象允许使用+和复合运算符+=实现连接，可以调用其他<strong>成员函数</strong>来实现字符串处理（与java中的method相同）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近因为项目而学习C++&lt;/p&gt;
&lt;p&gt;学习资源：&lt;a href=&quot;https://www.icourse163.org/course/NWPU-494001?tid=1450728827&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;西北工业大学 C++程序设计&lt;/a&gt;、&lt;a href=&quot;https://www.icourse163.org/course/QDU-1458424165&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;青岛大学 面向对象程序设计（C++和Java）&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;默认参数&quot;&gt;&lt;a href=&quot;#默认参数&quot; class=&quot;headerlink&quot; title=&quot;默认参数&quot;&gt;&lt;/a&gt;默认参数&lt;/h3&gt;&lt;p&gt;C++允许在函数定义或声明时，为形参指定默认值，这样的参数称为默认参数。&lt;/p&gt;
&lt;p&gt;（1）如果在函数定义时设置了默认参数，那么就不能在函数声明中再次设置，反之亦然。&lt;/p&gt;
&lt;p&gt;（2）可以设置多个默认参数，设置的顺序自右向左，即要设置默认值的参数右边的所有参数都必须是默认参数。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;volume&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; L, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; W, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; H = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;volume&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; L = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; W = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; H = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//上面都是正确的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;volume&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; L = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; W, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; H)&lt;/span&gt;&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//错误&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;volume&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; L, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; W = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; H)&lt;/span&gt;&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//错误&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（3）默认值可以是常量、全局变量和函数调用（调用实参必须是常量或全局变量的表达式，不可以是局部变量）&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>summary_about_the_half_year</title>
    <link href="http://yoursite.com/2020/12/05/summary-about-the-half-year/"/>
    <id>http://yoursite.com/2020/12/05/summary-about-the-half-year/</id>
    <published>2020-12-05T13:40:35.000Z</published>
    <updated>2020-12-05T13:55:33.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="20201205-小记"><a href="#20201205-小记" class="headerlink" title="20201205-小记"></a>20201205-小记</h1><p>不知不觉研一开学有三个月了，自暑假之后再也没碰过blog，总觉得买域名的钱花的有点不值，换电脑后折腾了两个小时把原来的博客都搬到新电脑上面，换了个主题心情大好~。</p><p>三个月其实也没有做什么东西，一直在上课和划水。</p><p>RTS：李老师的课听得一脸懵…整个人都不太好，还好有万能的同学们一起讨论。也还好它结课了，整个人都轻松了hhh札记可太难了=_=</p><p>近期的小目标是学会C++的基本使用和做项目，当然还有考试和作业。</p><p>写的好水啊…没有任何干货（这篇后面会删掉吧hhh</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;20201205-小记&quot;&gt;&lt;a href=&quot;#20201205-小记&quot; class=&quot;headerlink&quot; title=&quot;20201205-小记&quot;&gt;&lt;/a&gt;20201205-小记&lt;/h1&gt;&lt;p&gt;不知不觉研一开学有三个月了，自暑假之后再也没碰过blog，总觉得买域</summary>
      
    
    
    
    
    <category term="about_life" scheme="http://yoursite.com/tags/about-life/"/>
    
  </entry>
  
  <entry>
    <title>bash</title>
    <link href="http://yoursite.com/2020/08/16/bash%20notes/"/>
    <id>http://yoursite.com/2020/08/16/bash%20notes/</id>
    <published>2020-08-15T16:00:00.000Z</published>
    <updated>2020-08-16T13:47:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="bash-notes"><a href="#bash-notes" class="headerlink" title="bash notes"></a>bash notes</h1><blockquote><p>reference: <a href="https://wangdoc.com/bash/" target="_blank" rel="noopener">https://wangdoc.com/bash/</a></p></blockquote><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p><strong>pwd</strong> – 显示当前目录</p><p><strong>echo</strong> 多行加“ ” 输出文本末尾有回车符</p><ol><li>-n参数 取消末尾的回车符</li><li>-e参数 解释单双引号中的特殊字符(e.g. \n)</li></ol><p><strong>type</strong> 判断命令的来源</p><ol><li>-a参数 查看命令的所有定义</li><li>-t参数 返回一个命令的类型：别名（alias），关键词（keyword），函数（function），内置命令（builtin）和文件（file）</li></ol><p>快捷键：</p><ul><li><code>Ctrl + L</code>：清除屏幕并将当前行移到页面顶部</li><li><code>Ctrl + C</code>：中止当前正在执行的命令</li><li><code>Shift + PageUp</code>：向上滚动</li><li><code>Shift + PageDown</code>：向下滚动</li><li><code>Ctrl + U</code>：从光标位置删除到行首</li><li><code>Ctrl + K</code>：从光标位置删除到行尾</li><li><code>Ctrl + D</code>：关闭 Shell 会话</li><li><code>↑</code>，<code>↓</code>：浏览已执行命令的历史记录</li></ul><h2 id="模式扩展-gt-简单的正则"><a href="#模式扩展-gt-简单的正则" class="headerlink" title="模式扩展-&gt;简单的正则"></a>模式扩展-&gt;简单的正则</h2><blockquote><p>shell接收命令，根据空格拆分为一个个词元，然后扩展词元里的特殊字符。</p></blockquote><p>set -f 开启        set +f 关闭</p><ol><li>波浪号 自动扩展成当前用户的主目录 ~+ equal to pwsd</li><li>问号 代表文件路径中的任意单个字符，不包含空字符</li><li>星号 代表文件路径中任意数量的任意字符，包括零个字符，但是不会匹配隐藏文件，如果需要匹配隐藏文件需要写成<code>.*</code></li><li><code>[...]</code> 匹配方括号中的任意一个字符 <code>[!...] or [^...]</code>是非的表达 匹配连字符- 只能放在方括号内部首尾位置</li><li><code>[start-end]</code> </li><li><code>{...}</code> 扩展成大括号里的所有值，各个值之间用逗号分隔，逗号前后不能有空格</li><li><code>{start..end}</code> 大括号扩展的简写形式，支持逆序 <code>{start..end..step}</code>中step为步长</li><li>变量扩展 e.g. ${SHELL}</li><li>子命令扩展 $(…) 可以扩展为另一个命令的运行结果</li><li>算数扩展$((…))</li><li>字符类</li></ol><ul><li><code>[[:alnum:]]</code>：匹配任意英文字母与数字</li><li><code>[[:alpha:]]</code>：匹配任意英文字母</li><li><code>[[:blank:]]</code>：空格和 Tab 键</li><li><code>[[:cntrl:]]</code>：ASCII 码 0-31 的不可打印字符</li><li><code>[[:digit:]]</code>：匹配任意数字 0-9</li><li><code>[[:graph:]]</code>：A-Z、a-z、0-9 和标点符号</li><li><code>[[:lower:]]</code>：匹配任意小写字母 a-z</li><li><code>[[:print:]]</code>：ASCII 码 32-127 的可打印字符</li><li><code>[[:punct:]]</code>：标点符号（除了 A-Z、a-z、0-9 的可打印字符）</li><li><code>[[:space:]]</code>：空格、Tab、LF（10）、VT（11）、FF（12）、CR（13）</li><li><code>[[:upper:]]</code>：匹配任意大写字母 A-Z</li><li><code>[[:xdigit:]]</code>：16进制字符（A-F、a-f、0-9）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;bash-notes&quot;&gt;&lt;a href=&quot;#bash-notes&quot; class=&quot;headerlink&quot; title=&quot;bash notes&quot;&gt;&lt;/a&gt;bash notes&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;reference: &lt;a href=&quot;https</summary>
      
    
    
    
    
    <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>YOLOv4</title>
    <link href="http://yoursite.com/2020/04/27/YOLOv4%20-%20note/"/>
    <id>http://yoursite.com/2020/04/27/YOLOv4%20-%20note/</id>
    <published>2020-04-27T08:03:05.000Z</published>
    <updated>2020-04-28T10:51:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="YOLOv4-note"><a href="#YOLOv4-note" class="headerlink" title="YOLOv4 - note"></a>YOLOv4 - note</h1><blockquote><p>arxiv.org/abs/2004.10934 -&gt; translation: <a href="https://tongtianta.site/paper/89863" target="_blank" rel="noopener">https://tongtianta.site/paper/89863</a></p></blockquote><p>提高accuracy的通用功能：加权残差链接（WRC）、跨阶段部分连接（CSP）、跨小批量标准化（CmBN）、自对抗训练（SAT）、Mish-activation。</p><p>本文结合WRC、CSP、CmBN、SAT、Mish-activation、镶嵌数据增强（augmentation mosaic）、DropBlock regularization、CIoU loss</p><p><img src="https://raw.githubusercontent.com/su-loch/pics/master/img/yolov4.png" alt></p><h2 id="bags-of-freebies"><a href="#bags-of-freebies" class="headerlink" title="bags of freebies"></a>bags of freebies</h2><p>数据增强：</p><ul><li>photomatric distortion-&gt; 调整图像亮度，对比度，色相，饱和度和噪点</li><li>geometric distortion -&gt; 随机缩放，裁剪，翻转和旋转</li></ul><p>模拟对象遮挡：</p><ul><li>random erase、CutOut -&gt; 随机选择图像中的矩形区域填充为0的随机或互补值</li><li>hide-and-seek、grid mask -&gt; 随机或均匀地选择图像中的多个矩形区域替换为全0</li></ul><p>类似概念应用于feature map有：DropOut、DropConnect、<strong>DropBlock</strong></p><p>DIoU考虑了对象中心的距离、CIoU同时考虑了重叠区域 -&gt; 更好的收敛速度和准确性</p><h2 id="bags-of-specials"><a href="#bags-of-specials" class="headerlink" title="bags of specials"></a>bags of specials</h2><p>plugin modules：</p><ul><li>增强接收域：SPP、ASPP、RFB</li><li>引入注意力机制（channel-wise、point-wise）：Squeeze-and-Excitation(SE)、Spatial Attention Module(<strong>SAM</strong>)</li><li>集成特征：SFAM、ASFF、BiFPN</li><li>激活函数：LReLU、<del>PReLU</del>、<del>ReLU6</del>、<del>SELU</del>、Swish、hard-Swish、Mish</li></ul><p>post-processing：DIoU NMS</p><h2 id="架构选择"><a href="#架构选择" class="headerlink" title="架构选择"></a>架构选择</h2><p><strong>CSPDarknet53</strong>、CSPResNext50</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;YOLOv4-note&quot;&gt;&lt;a href=&quot;#YOLOv4-note&quot; class=&quot;headerlink&quot; title=&quot;YOLOv4 - note&quot;&gt;&lt;/a&gt;YOLOv4 - note&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;arxiv.org/abs/200</summary>
      
    
    
    
    
    <category term="毕业设计" scheme="http://yoursite.com/tags/毕业设计/"/>
    
  </entry>
  
  <entry>
    <title>tf2.0</title>
    <link href="http://yoursite.com/2020/04/05/tf2-0/"/>
    <id>http://yoursite.com/2020/04/05/tf2-0/</id>
    <published>2020-04-05T02:48:29.000Z</published>
    <updated>2020-04-09T10:00:52.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>练习代码 <a href="https:github.com/su-loch/python_exercise" target="_blank" rel="noopener">pex</a> 基于tensorflow2.0</p></blockquote><h3 id="tensorflow-vs-pytorch"><a href="#tensorflow-vs-pytorch" class="headerlink" title="tensorflow_vs_pytorch"></a>tensorflow_vs_pytorch</h3><p>tf1.* 静态图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">print(tf.__version__)<span class="comment"># 1.9.0</span></span><br><span class="line"></span><br><span class="line">x = tf.Variable(<span class="number">0.</span>)</span><br><span class="line">y = tf.Variable(<span class="number">1.</span>)</span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># 构建计算图</span></span><br><span class="line"><span class="comment"># x = x + y</span></span><br><span class="line">add_op = x.assign(x +y)</span><br><span class="line"><span class="comment"># y = y / 2</span></span><br><span class="line">div_op = y.assign(y / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">        sess.run(add_op)</span><br><span class="line">        sess.run(div_op)</span><br><span class="line">    print(x.eval())</span><br></pre></td></tr></table></figure><p>tf2.* 动态图 -&gt; tf1.x中调用tf.enable_eager_execution()方法打开eager mode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">print(tf.__version__)   <span class="comment"># 2.0.0</span></span><br><span class="line"></span><br><span class="line">x = tf.constant(<span class="number">0.</span>)</span><br><span class="line">y = tf.constant(<span class="number">1.</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">    x = x + y</span><br><span class="line">    y = y / <span class="number">2</span></span><br><span class="line">print(x.numpy())</span><br></pre></td></tr></table></figure><p>PyTorch 动态图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">print(torch.__version__)    <span class="comment"># 1.4.0</span></span><br><span class="line"></span><br><span class="line">x = torch.Tensor([<span class="number">0.</span>])</span><br><span class="line">y = torch.Tensor([<span class="number">1.</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">    x = x + y</span><br><span class="line">    y = y / <span class="number">2</span></span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="分类问题与回归问题"><a href="#分类问题与回归问题" class="headerlink" title="分类问题与回归问题"></a>分类问题与回归问题</h2><ul><li><p>分类问题预测的是类别，模型的输出是概率分布</p></li><li><p>回归问题预测是值，模型的输出是一个实数值</p></li></ul><h3 id="目标函数-↓"><a href="#目标函数-↓" class="headerlink" title="目标函数 ↓"></a>目标函数 ↓</h3><ul><li><strong>分类问题</strong>–衡量目标类别与当前预测的差距</li></ul><p>e.g. 三分类问题，输出：[0.2, 0.7, 0.1] -&gt; 第1类</p><p>真实类别第2类 -&gt; one_hot -&gt; [0, 0, 1]</p><p>one_hot编码，把正整数变为向量表达，生成一个不小于正整数的向量，只有正整数的位置为1，其余位置为0</p><ul><li>分类常用损失函数：平方差损失、交叉熵损失</li><li><strong>回归问题</strong>–预测值与真实值差距</li><li>回归常用损失函数：平方差损失、绝对值损失</li></ul><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>tf.keras.callbacks</p><ul><li>EarlyStopping</li><li>ModelCheckpoint</li><li>TensorBoard</li></ul><p>在命令行中调用tensorboard：tensorboard –logdir=[你的文件夹名称]</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;练习代码 &lt;a href=&quot;https:github.com/su-loch/python_exercise&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pex&lt;/a&gt; 基于tensorflow2.0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;tensorflow-vs-pytorch&quot;&gt;&lt;a href=&quot;#tensorflow-vs-pytorch&quot; class=&quot;headerlink&quot; title=&quot;tensorflow_vs_pytorch&quot;&gt;&lt;/a&gt;tensorflow_vs_pytorch&lt;/h3&gt;&lt;p&gt;tf1.* 静态图&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; tensorflow &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; tf&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(tf.__version__)	&lt;span class=&quot;comment&quot;&gt;# 1.9.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;x = tf.Variable(&lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;y = tf.Variable(&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(x)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 构建计算图&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# x = x + y&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;add_op = x.assign(x +y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# y = y / 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;div_op = y.assign(y / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; tf.Session() &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; sess:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sess.run(tf.global_variables_initializer())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sess.run(add_op)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sess.run(div_op)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(x.eval())&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;tf2.* 动态图 -&amp;gt; tf1.x中调用tf.enable_eager_execution()方法打开eager mode&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; tensorflow &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; tf&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(tf.__version__)   &lt;span class=&quot;comment&quot;&gt;# 2.0.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;x = tf.constant(&lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;y = tf.constant(&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    x = x + y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    y = y / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(x.numpy())&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;PyTorch 动态图&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; torch&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(torch.__version__)    &lt;span class=&quot;comment&quot;&gt;# 1.4.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;x = torch.Tensor([&lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;y = torch.Tensor([&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    x = x + y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    y = y / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(x)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="tensorflow" scheme="http://yoursite.com/tags/tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>YOLOv3</title>
    <link href="http://yoursite.com/2020/04/02/YOLOv3/"/>
    <id>http://yoursite.com/2020/04/02/YOLOv3/</id>
    <published>2020-04-01T17:29:04.000Z</published>
    <updated>2020-04-04T14:36:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://pjreddie.com/media/files/papers/YOLOv3.pdf" target="_blank" rel="noopener">论文地址</a></p><h2 id="YOLOv3结构图"><a href="#YOLOv3结构图" class="headerlink" title="YOLOv3结构图"></a>YOLOv3结构图</h2><p><img src="https://raw.githubusercontent.com/su-loch/pics/master/img/yolo_v3_structure.png" alt></p><ul><li>DBL：卷积 + BN(Batch Normalization) + Leaky relu</li><li>resn：n表示包含的res_unit个数</li><li>concat：张量拼接，拼接会扩充张量的维度</li></ul><h3 id="backbone"><a href="#backbone" class="headerlink" title="backbone"></a>backbone</h3><p>Darknet-53没有设置池化层和全连接层，而通过改变卷积核的步长进行张量的尺寸变换，在yolov3中没有最后的全局平均池化层，所以张量变化只考虑5层。</p><h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><p>y1、y2、y3深度都是255 = 3*（5+80），其中5是bbox的5个参数，80是COCO数据集的类别数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://pjreddie.com/media/files/papers/YOLOv3.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;论文地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;YOLOv3结构图&quot;&gt;&lt;a href=&quot;#YOL</summary>
      
    
    
    
    
    <category term="毕业设计" scheme="http://yoursite.com/tags/毕业设计/"/>
    
  </entry>
  
  <entry>
    <title>ResNet</title>
    <link href="http://yoursite.com/2020/03/18/ResNet/"/>
    <id>http://yoursite.com/2020/03/18/ResNet/</id>
    <published>2020-03-18T03:05:41.000Z</published>
    <updated>2020-04-04T14:36:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>残差网路</strong></p><p><img src="https://raw.githubusercontent.com/su-loch/pics/master/img/resnet-block.png" alt></p><p>这是一个两层神经网络。</p><p>计算过程从a[l]开始，先进行线性运算。<br>$$<br>z^{[l+1] }= W^{[l+1]}a^{[l]} + b^{[l+1]}<br>$$<br>在由激活函数g得到a[l+1]，这里g是线性整流函数relu<br>$$<br>a^{[l+1]} = g(z^{[l+1]})<br>$$<br>随后进行第二层线性运算<br>$$<br>z^{[l+2]} = W^{[l+2]}a^{[l+1]} + b^{[l+2]}<br>$$<br>再经过Relu<br>$$<br>a^{[l+2]} = g(z^{[l+2]})<br>$$<br>在残差网络中加入一点变化</p><p><img src="https://raw.githubusercontent.com/su-loch/pics/master/img/resnet.png" alt></p><p>即”跳远连接”<br>$$<br>a^{[l+2]} = g(z^{[l+2]} + a^{[l]})<br>$$<br>这样，随着网络的加深，训练误差也跟着下降。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;残差网路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/su-loch/pics/master/img/resnet-block.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;这是一个两层神经网络</summary>
      
    
    
    
    
    <category term="deeplearning" scheme="http://yoursite.com/tags/deeplearning/"/>
    
  </entry>
  
  <entry>
    <title>Linux指令</title>
    <link href="http://yoursite.com/2020/03/17/Linux%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/03/17/Linux%E6%8C%87%E4%BB%A4/</id>
    <published>2020-03-17T07:09:23.000Z</published>
    <updated>2020-04-01T17:33:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/nb/37698552" target="_blank" rel="noopener">https://www.jianshu.com/nb/37698552</a></p><p><a href="https://www.jianshu.com/p/8c2af151ddc2" target="_blank" rel="noopener">https://www.jianshu.com/p/8c2af151ddc2</a></p><p><a href="https://www.runoob.com/linux/linux-shell.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-shell.html</a></p><p><a href="https://www.linuxcool.com/" target="_blank" rel="noopener">linux命令大全</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/nb/37698552&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/nb/37698552&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http</summary>
      
    
    
    
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>VID</title>
    <link href="http://yoursite.com/2020/03/15/VID/"/>
    <id>http://yoursite.com/2020/03/15/VID/</id>
    <published>2020-03-15T12:53:26.000Z</published>
    <updated>2020-03-16T14:44:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>reference paper：</p><blockquote><p>陈志欣. 基于深度学习的视频目标检测算法研究与应用[D].北方工业大学,2019.</p></blockquote><p><strong>视频目标检测（object detection from video）</strong></p><p>从2015年开始，ILSVRC新增了VID挑战任务，视频中的目标检测难题：更多的帧图像文件、由于速度快导致运动模糊和光照等问题、物体间的遮挡问题。</p><p><strong>数据集预处理</strong></p><ol><li>归一化：将原始像素压缩到[0,1]区间</li></ol><p>$$<br>\text { norm }=\frac{x_{i}-\min (x)}{\max (x)-\min (x)}<br>$$</p><ol start="2"><li>去均值化：对每个通道，移除图像的平均亮度，凸显个体差异</li></ol><p>$$<br>x_{r}, x_{g}, x_{b}=\left(x_{r}-R_{m e a n}, x_{g}-G_{m e a n}, x_{b}-B_{m e a n}\right)<br>$$</p><ol start="3"><li>标准化：使像素符合标准正态分布，在样本尺度不一致的情况下（如不同相机采集的图片，或者是来源不同的图片）</li></ol><p>$$<br>x^{\prime}=\frac{x-\mu}{\sigma}<br>$$</p><a id="more"></a><p><strong>数据增强</strong>：解决样本数量和质量不满足需求的问题</p><p>镜像翻转、随机旋转、随机错切、高斯噪声、椒盐噪声、明亮度变化（不加入影响图像本质特性的噪声）</p><p><strong>性能指标</strong></p><p>mAP、IoU、FPS、NMS</p><p><strong>可变形卷积</strong>（Deformable Convolution）-&gt; 了解卷积的多种方式</p><p><img src="https://raw.githubusercontent.com/su-loch/pics/master/img/deformable%20convolution.png" alt></p><p>refer to <a href="https://arxiv.org/pdf/1703.06211.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1703.06211.pdf</a></p><p><strong>对小目标物体的检测</strong></p><ul><li><p>数据增强：用不同尺度的图片进行训练 × </p></li><li><p>SPP 空间池化金字塔 ×</p></li><li><p>SSD 在不同尺度的特征图上引入区域检测机制 （提高有限） ×</p></li><li><p><strong>FPN网络</strong></p></li></ul><p><img src="https://raw.githubusercontent.com/su-loch/pics/master/img/FPN.png" alt></p><p>自下而上的前馈计算（池化采样），自下而上的特征融合与横向连接（最近邻上采样或双线性插值），横向对应的层特征图各像素点之间直接相加，融合后的特征还要进行3*3卷积以消除upsampling产生的混叠作用。</p><p><strong>网络的训练损失函数</strong></p><p>这一块真的看的我眼花…</p><ol><li>回归损失</li></ol><p>均方误差/平方损失/L2 损失：<br>$$<br>M S E=\frac{\sum_{i=1}^{n}\left(y_{i}-\hat{y}_{i}\right)^{2}}{n}<br>$$<br>平均绝对误差/L1 损失：</p><p>$$<br>M A E=\frac{\sum_{i=1}^{n}\left|y_{i}-\hat{y}_{i}\right|}{n}<br>$$</p><p>平均偏差误差（mean bias error）：</p><p>$$<br>M B E=\frac{\sum_{i=1}^{n}\left(y_{i}-\hat{y}_{i}\right)}{n}<br>$$</p><ol start="2"><li>分类损失</li></ol><p>Hinge Loss/多分类 SVM 损失：</p><p>$$<br>S V M L o s s=\sum_{j \neq y_{i}} \max \left(0, s_{j}-s_{y_{i}}+1\right)<br>$$</p><p>交叉熵损失/负对数似然：</p><p>$$<br>CrossEntropyLoss = -\left( y_{i} \log \left( \hat{y} _ {i} \right) + \left( 1-y _ {i} \right) \log \left(1- \hat{y}_{i} \right) \right)<br>$$<br>剩余词条待补充：multi-task loss、facol loss、GIoU、DIoU</p><p>refer to：<a href="https://zhuanlan.zhihu.com/p/112057799" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/112057799</a></p><p><strong>YOLOv3中用k-means聚类得到anchor大小和数量设置</strong></p><p><strong>VID流程</strong></p><p>Image_Feature = N_feat(Image_input) -&gt; Output = N_det(Image_Feature)提取候选框进行分类回归</p><p>Deap Feature Flow利用一种基于卷积操作的FlowNet生成前后帧的光流图，再叠加上前一时刻关键帧信息，生成本时刻关键帧最终的特征图。</p><p>FGFA将相邻帧在时序上的特征聚合到当前帧的特征中，处理运动模糊、视频散焦、奇特姿势等问题。</p><p><strong>稀疏特征传播方式提高检测速度</strong>   DFF</p><p>每隔n张（n常取10）抽取一个关键帧得到特征图，非关键帧的特征图计算为最近邻关键帧以及其与当前非关键帧之间运动变化矢量的加和。通常用光流矢量定量计算临近两帧之间的信息差值。 -&gt; FlowNet如何实现</p><p><strong>密集特征聚合方式提高检测精度</strong>   FGFA</p><p>需要计算视频每一帧的特征图，对视频的第i个时刻的关键帧，给每个时间帧分配一定权重系数，来对前后i+2r个特征图对应位置的值加权求和。 -&gt; 权重如何分配</p><p><strong>关键帧的选择优化</strong></p><ul><li>基于特征一致性的关键帧调度策略：</li></ul><p>$$<br>key = is_{-}key \left( B_{k \rightarrow i} \right)<br>$$</p><p>$$<br>i s_{k e y}\left(Q_{k \rightarrow i}\right) = \left [ \frac{1}{N_{p}} \sum_{p} 1 \left ( B_{k \rightarrow i}(p) \leq \tau \right ) \right ] &gt; \gamma<br>$$<br>前后两个参数分别设置为0.1 和 0.2</p><ul><li><p>FlowNetSimple作为光流计算网络</p></li><li><p>设计Tubelet结构存放<strong>低检测关键帧</strong>前后r帧信息，做密特征聚合使用，优化此关键帧的检测精度。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;reference paper：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;陈志欣. 基于深度学习的视频目标检测算法研究与应用[D].北方工业大学,2019.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;视频目标检测（object detection from video）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从2015年开始，ILSVRC新增了VID挑战任务，视频中的目标检测难题：更多的帧图像文件、由于速度快导致运动模糊和光照等问题、物体间的遮挡问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据集预处理&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;归一化：将原始像素压缩到[0,1]区间&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$$&lt;br&gt;\text { norm }=\frac{x_{i}-\min (x)}{\max (x)-\min (x)}&lt;br&gt;$$&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;去均值化：对每个通道，移除图像的平均亮度，凸显个体差异&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$$&lt;br&gt;x_{r}, x_{g}, x_{b}=\left(x_{r}-R_{m e a n}, x_{g}-G_{m e a n}, x_{b}-B_{m e a n}\right)&lt;br&gt;$$&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;标准化：使像素符合标准正态分布，在样本尺度不一致的情况下（如不同相机采集的图片，或者是来源不同的图片）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$$&lt;br&gt;x^{\prime}=\frac{x-\mu}{\sigma}&lt;br&gt;$$&lt;/p&gt;</summary>
    
    
    
    
    <category term="cv" scheme="http://yoursite.com/tags/cv/"/>
    
  </entry>
  
  <entry>
    <title>Anaconda使用tips</title>
    <link href="http://yoursite.com/2020/03/13/Anaconda%E4%BD%BF%E7%94%A8tips/"/>
    <id>http://yoursite.com/2020/03/13/Anaconda%E4%BD%BF%E7%94%A8tips/</id>
    <published>2020-03-13T11:57:12.000Z</published>
    <updated>2020-03-13T12:59:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天为了安装tensorflow踩了不少坑🤢，主要是anaconda环境安装的问题，写点笔记记下来</p><p>新建一个虚拟环境 conda create -n 环境名 python=3.7 （版本自己选择），创建的环境在./envs文件夹下。</p><p>conda activate 环境名 激活</p><p>conda deactivate 关闭回到base环境</p><p>conda remove -n 环境名 –all 删除已有环境</p><p>conda list 查看已安装package</p><p>换源就不说了，注意在修改.condarc文件时如果运行报错，把里面的https改为http即可。</p><p>因为直接使用conda下载速度太慢，所以选择离线安装。首先在清华镜像源下载<a href="https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/tensorflow/" target="_blank" rel="noopener">tensorflow</a>和<a href="https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/opencv-python/" target="_blank" rel="noopener">opencv</a>，选择对应平台和python版本的.whl文件，放在./Lib/site-packages/文件夹下。cd到当前目录，pip install xxxx.whl安装即可。如果出现报错无法定位程序输入点的问题把Anaconda3/DLLS下libssl-1_1-x64.dll文件到覆盖Anaconda3/Library/bin中，一路yes就可以完成安装。安错版本pip uninstall tensorflow卸载</p><p>在选择tensorflow版本的时候，注意自己的电脑是否支持当前版本。</p><p><strong>reference：</strong></p><p><a href="https://blog.csdn.net/qq_37465638/article/details/100071259" target="_blank" rel="noopener">无法定位程序输入点</a></p><p><a href="https://zhuanlan.zhihu.com/p/102324325" target="_blank" rel="noopener">tf2.0安装</a></p><p><a href="https://www.cnblogs.com/zhaochunhui/p/10839462.html" target="_blank" rel="noopener">版本选择</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天为了安装tensorflow踩了不少坑🤢，主要是anaconda环境安装的问题，写点笔记记下来&lt;/p&gt;
&lt;p&gt;新建一个虚拟环境 conda create -n 环境名 python=3.7 （版本自己选择），创建的环境在./envs文件夹下。&lt;/p&gt;
&lt;p&gt;conda</summary>
      
    
    
    
    
    <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>DL_tools</title>
    <link href="http://yoursite.com/2020/03/12/DL-tools/"/>
    <id>http://yoursite.com/2020/03/12/DL-tools/</id>
    <published>2020-03-12T08:50:55.000Z</published>
    <updated>2020-03-12T09:13:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一些深度学习框架"><a href="#一些深度学习框架" class="headerlink" title="一些深度学习框架"></a>一些深度学习框架</h1><ol><li>Caffe：代码基于C++（训练速度快），入门级、上手快（修改一些配置文件即可），适合新手了解深度学习任务中的各种参数；</li><li>Keras：基于Theano或TensorFlow的高级框架，可快速构建网络，不用了解网络的底层设计；</li><li>TensorFlow：有高级的API（tf.Keras等），也可以自己从零开始构建一个新的网络，但是1.x版本静态图问题不好调试，2.0貌似解决了这个问题（尝试使用这个做毕设，不知道学长用的是哪个）；</li><li>Pytorch：科研人员都说好用的框架，上手快、好搭建，但是工业上采用tensorflow更多。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一些深度学习框架&quot;&gt;&lt;a href=&quot;#一些深度学习框架&quot; class=&quot;headerlink&quot; title=&quot;一些深度学习框架&quot;&gt;&lt;/a&gt;一些深度学习框架&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;Caffe：代码基于C++（训练速度快），入门级、上手快（修改一些配置文件即可）</summary>
      
    
    
    
    
    <category term="深度学习" scheme="http://yoursite.com/tags/深度学习/"/>
    
  </entry>
  
  <entry>
    <title>CNN</title>
    <link href="http://yoursite.com/2020/03/06/CNN/"/>
    <id>http://yoursite.com/2020/03/06/CNN/</id>
    <published>2020-03-06T13:23:00.000Z</published>
    <updated>2020-03-06T13:42:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Convolutional-Neural-Network"><a href="#Convolutional-Neural-Network" class="headerlink" title="Convolutional Neural Network"></a>Convolutional Neural Network</h1><h2 id="1-输入层"><a href="#1-输入层" class="headerlink" title="1. 输入层"></a>1. 输入层</h2><p>原始图片，在计算机内用构成像素点的多维矩阵来表示。</p><h2 id="2-隐层"><a href="#2-隐层" class="headerlink" title="2. 隐层"></a>2. 隐层</h2><p>convolution卷积：过滤特征</p><p>ReLU线性修正单元：激活函数</p><p>polling池化：降低维度并提高模型的容错性</p><p><strong>降低模型的参数数目</strong></p><ol><li><p>局部感知野：每个神经元只需要对局部图像进行感知，然后在更高层将局部的信息综合起来得到全局的信息；</p></li><li><p>权值共享：对于每一层来讲，所有神经元对应的权值参数是一样的，同一层下的神经元连接参数只与特征提取的方式有关，而与具体的位置无关。</p></li></ol><p>第一层隐层一般是用来做边缘和曲线检测</p><p>第二层隐层对第一层学到的边缘曲线组合得到的一些特征</p><p>第三层则会学到一些更复杂的特征</p><p><strong>ReLU激活函数</strong></p><p>引入非线性激励函数，深层网络具有意义（不再是输入的线性组合，可以逼近任意函数）</p><p>为什么采用ReLU函数：1. 采用sigmoid等函数，计算量大，反向传播求误差梯度时涉及除法；2. 对于深层网络，sigmoid函数反向传播时，容易出现梯度消失的情况（sigmoid接近饱和区时，变换太缓慢，导数趋于0，容易造成信息丢失），从而无法完成深层网络的训练；3. ReLU会使一部分神经元的输出为0，造成了网络的稀疏性，并减少了参数的相互依存关系，缓解了过拟合问题的发生。</p><p><strong>pooling池化（欠采样）</strong></p><p>主要有max、average、sum等不同类型的操作</p><h2 id="3-输出层"><a href="#3-输出层" class="headerlink" title="3. 输出层"></a>3. 输出层</h2><p>经过若干次的卷积+线性修真+pooling，模型会将学到的高水平特征接到一个<strong>全连接层</strong>，通过softmax函数得到输出。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Convolutional-Neural-Network&quot;&gt;&lt;a href=&quot;#Convolutional-Neural-Network&quot; class=&quot;headerlink&quot; title=&quot;Convolutional Neural Network&quot;&gt;&lt;/a&gt;Co</summary>
      
    
    
    
    
    <category term="NN" scheme="http://yoursite.com/tags/NN/"/>
    
  </entry>
  
  <entry>
    <title>TexLive_installation</title>
    <link href="http://yoursite.com/2019/07/11/TexLive-installation/"/>
    <id>http://yoursite.com/2019/07/11/TexLive-installation/</id>
    <published>2019-07-11T08:02:40.000Z</published>
    <updated>2019-08-18T07:19:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TexLive-VScode-搭建LaTex编译环境"><a href="#TexLive-VScode-搭建LaTex编译环境" class="headerlink" title="TexLive + VScode 搭建LaTex编译环境"></a>TexLive + VScode 搭建LaTex编译环境</h1><p>最近对LaTex十分感兴趣（因为好看），百度了很多教程，最后决定在VScode上配置环境。</p><fancybox><br><br><img src="/img/texlive_test.png" alt><br><br></fancybox><a id="more"></a><ol><li><p>下载<a href="https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/" target="_blank" rel="noopener">TexLive镜像文件</a>(清华大学镜像)，选择texlive2019.iso下载即可；</p></li><li><p>iso文件解压后，在文件夹中点击install-tl-advanced.bat或install-tl-windows.bat文件均可，其中可进行一些安装地址和组件的配置，安装时间较长；</p></li><li><p>在VScode中安装插件：LaTex language support, LaTex Workshop</p></li><li><p>对latex编译环境进行配置：在设置中搜索latex，对setting.json进行编辑，加入以下代码段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&quot;latex-workshop.latex.tools&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;latexmk&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;latexmk&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;-synctex=1&quot;,</span><br><span class="line">                &quot;-interaction=nonstopmode&quot;,</span><br><span class="line">                &quot;-file-line-error&quot;,</span><br><span class="line">                &quot;-pdf&quot;,</span><br><span class="line">                &quot;%DOC%&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;xelatex&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;xelatex&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;-synctex=1&quot;,</span><br><span class="line">                &quot;-interaction=nonstopmode&quot;,</span><br><span class="line">                &quot;-file-line-error&quot;,</span><br><span class="line">                &quot;%DOC%&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;pdflatex&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;pdflatex&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;-synctex=1&quot;,</span><br><span class="line">                &quot;-interaction=nonstopmode&quot;,</span><br><span class="line">                &quot;-file-line-error&quot;,</span><br><span class="line">                &quot;%DOC%&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;bibtex&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;bibtex&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;%DOCFILE%&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;latex-workshop.latex.recipes&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;xelatex&quot;,</span><br><span class="line">            &quot;tools&quot;: [</span><br><span class="line">                &quot;xelatex&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;pdflatex&quot;,</span><br><span class="line">            &quot;tools&quot;: [</span><br><span class="line">                &quot;pdflatex&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;latexmk&quot;,</span><br><span class="line">            &quot;tools&quot;: [</span><br><span class="line">                &quot;latexmk&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;pdflatex -&gt; bibtex -&gt; pdflatex*2&quot;,</span><br><span class="line">            &quot;tools&quot;: [</span><br><span class="line">                &quot;pdflatex&quot;,</span><br><span class="line">                &quot;bibtex&quot;,</span><br><span class="line">                &quot;pdflatex&quot;,</span><br><span class="line">                &quot;pdflatex&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;latex-workshop.view.pdf.viewer&quot;: &quot;tab&quot;,</span><br><span class="line">    &quot;latex-workshop.latex.clean.subfolder.enabled&quot;: true //这里要选择true清除编译过程中产生的文件</span><br></pre></td></tr></table></figure></li><li><p>创建文件test.tex，Ctrl+S保存编译，得到PDF文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\documentclass[UTF8]&#123;ctexart&#125;</span><br><span class="line">    \title&#123;TexLive + VScode 环境配置&#125;</span><br><span class="line">    \author&#123;Silhouettes&#125;</span><br><span class="line">    \date&#123;\today&#125;</span><br><span class="line">    \begin&#123;document&#125;</span><br><span class="line">    \maketitle</span><br><span class="line">    This is the beginning of the article.\\</span><br><span class="line">    </span><br><span class="line">    编译成功！\\</span><br><span class="line"></span><br><span class="line">    $ &#123;f&#125;&apos;(0) =  \left. \frac&#123;df&#125;&#123;dx&#125; \right|_&#123;x=0&#125; $</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure><p>这里要注意tex文件要按utf-8编码，如果编译后出现乱码，可以更换编码方式重新保存后再编译一次。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;TexLive-VScode-搭建LaTex编译环境&quot;&gt;&lt;a href=&quot;#TexLive-VScode-搭建LaTex编译环境&quot; class=&quot;headerlink&quot; title=&quot;TexLive + VScode 搭建LaTex编译环境&quot;&gt;&lt;/a&gt;TexLive + VScode 搭建LaTex编译环境&lt;/h1&gt;&lt;p&gt;最近对LaTex十分感兴趣（因为好看），百度了很多教程，最后决定在VScode上配置环境。&lt;/p&gt;
&lt;fancybox&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;/img/texlive_test.png&quot; alt&gt;&lt;br&gt;&lt;br&gt;&lt;/fancybox&gt;</summary>
    
    
    
    
    <category term="LaTex" scheme="http://yoursite.com/tags/LaTex/"/>
    
  </entry>
  
  <entry>
    <title>latex2word</title>
    <link href="http://yoursite.com/2019/07/06/latex2word/"/>
    <id>http://yoursite.com/2019/07/06/latex2word/</id>
    <published>2019-07-06T10:21:19.000Z</published>
    <updated>2019-08-18T07:20:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="latex2word"><a href="#latex2word" class="headerlink" title="latex2word"></a>latex2word</h1><p>突然想，能不能把在latex上生成的数学公式导入word里面，因为word自带的公式编辑器确实不是很好用，相较之下latex生成的公式十分精致。</p><p>搜到了很多教程，挑了我觉得最方便的一种：</p><p>先用<a href="https://mathpix.com/" target="_blank" rel="noopener">Mathpix</a>把需要的公式截图翻译成latex语言，再copy到<a href="https://www.latex4technics.com/" target="_blank" rel="noopener">Online LaTeX Equation Editor</a>网站，在MathJax框右键Show Math As项MathML Code选项，在word中 Alt 加 = 快捷键生成一个公式文本框将前面弹出界面的代码全部复制粘贴即可。</p><fancybox><br><br><img src="/img/step_1.gif" alt="step_1"><br><br></fancybox><fancybox><br><br><img src="/img/step_2.gif" alt="step_2"><br><br></fancybox><p>当然这是一种偷懒的方法，在Word2016中的公式编辑器中已经支持了一部分的LaTeX语法（比如\partial、\sum等等），可以很方便地输入一些简单的公式。</p><p>这个方法主要是用来抄理论的时候快速打出公式用的（不是。</p><p>/暑假愉快</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;latex2word&quot;&gt;&lt;a href=&quot;#latex2word&quot; class=&quot;headerlink&quot; title=&quot;latex2word&quot;&gt;&lt;/a&gt;latex2word&lt;/h1&gt;&lt;p&gt;突然想，能不能把在latex上生成的数学公式导入word里面，因为word自</summary>
      
    
    
    
    
    <category term="daily" scheme="http://yoursite.com/tags/daily/"/>
    
  </entry>
  
  <entry>
    <title>tensorflow_learning_2</title>
    <link href="http://yoursite.com/2019/05/20/tensorflow-learning-2/"/>
    <id>http://yoursite.com/2019/05/20/tensorflow-learning-2/</id>
    <published>2019-05-20T11:53:43.000Z</published>
    <updated>2019-05-20T13:57:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tensorflow学习笔记-2"><a href="#tensorflow学习笔记-2" class="headerlink" title="tensorflow学习笔记_2"></a>tensorflow学习笔记_2</h1><h2 id="计算图与张量"><a href="#计算图与张量" class="headerlink" title="计算图与张量"></a>计算图与张量</h2><p>TensorFlow中的计算可以表示为一个有向图（<strong>计算图</strong>），其中每一个运算操作作为一个节点，节点与节点的连接称为边，一张计算图描述了数据的计算流程，我们可以对计算图上的各个分支进行改变来达到我们的运算目的。在计算图的边中流动的数据被称为<strong>张量</strong>（tensor），张量的数据类型可以事先定义，也可以通过计算图的结构推导得出。</p><p>一个运算操作代表了一类抽象运算（如矩阵乘法或向量加法），运算操作必须有自己的属性，但是所有属性都必须被预先设置，或者在计算图沿着边运行时可以被推断出来。</p><h2 id="会话-Session"><a href="#会话-Session" class="headerlink" title="会话 Session"></a>会话 Session</h2><p>session是用户使用tensorflow的互交式接口，用户可以通过session的Extend方法添加新的节点和边来创建计算图，然后通过session的Run方法执行计算图。</p><p>大多数运算中，tensor不会一直保留下去。而Variable是一类特殊的运算操作，可以将一些需要保留的tensor储存在内存或者显存当中。每执行一次计算图后，Variable中的tensor都会被保存，同时在计算过程中，tensor的值也可以被更新。</p><hr><p>csdn上还是有很多的教程   <a href="https://www.cnblogs.com/hypnus-ly/p/8040951.html" target="_blank" rel="noopener">概念理解</a></p><h2 id="MNIST手写数字识别"><a href="#MNIST手写数字识别" class="headerlink" title="MNIST手写数字识别"></a>MNIST手写数字识别</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">mnist = input_data.read_data_sets(<span class="string">"MNIST_data/"</span>, one_hot=<span class="literal">True</span>)</span><br><span class="line">print(mnist.train.images.shape,mnist.train.labels.shape)</span><br><span class="line">print(mnist.test.images.shape,mnist.test.labels.shape)</span><br><span class="line">print(mnist.validation.images.shape,mnist.validation.labels.shape)</span><br></pre></td></tr></table></figure><p>结果输出为</p><p>(55000, 784) (55000, 10)<br>(10000, 784) (10000, 10)<br>(5000, 784) (5000, 10)</p><p><a href="https://github.com/yhlleo/mnist" target="_blank" rel="noopener">一个例程</a> 存</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;tensorflow学习笔记-2&quot;&gt;&lt;a href=&quot;#tensorflow学习笔记-2&quot; class=&quot;headerlink&quot; title=&quot;tensorflow学习笔记_2&quot;&gt;&lt;/a&gt;tensorflow学习笔记_2&lt;/h1&gt;&lt;h2 id=&quot;计算图与张量&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="机器学习" scheme="http://yoursite.com/categories/机器学习/"/>
    
    
    <category term="tensorflow" scheme="http://yoursite.com/tags/tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>tensorflow_learning_1</title>
    <link href="http://yoursite.com/2019/05/19/tensorflow-learning-1/"/>
    <id>http://yoursite.com/2019/05/19/tensorflow-learning-1/</id>
    <published>2019-05-19T09:40:58.000Z</published>
    <updated>2019-05-20T13:23:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tensorflow学习笔记-1"><a href="#tensorflow学习笔记-1" class="headerlink" title="tensorflow学习笔记_1"></a>tensorflow学习笔记_1</h1><h2 id="环境安装-CPU版本的tensorflow"><a href="#环境安装-CPU版本的tensorflow" class="headerlink" title="环境安装 CPU版本的tensorflow"></a>环境安装 CPU版本的tensorflow</h2><ol><li><p>安装anaconda或者miniconda 这里附上 <a href="https://blog.csdn.net/qq_36306781/article/details/81254832?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">一个很完整的参考教程</a>，因为我的anaconda安装了python3.7，而3.5对tensorflow的兼容性最好（听说，所以在anaconda中新建一个环境安装python3.5和tensorflow1.13.1。</p></li><li><p>首先 conda creat -n tensorflow python=3.5 新建一个环境名字为tensorflow，然后发现Anaconda3/envs/目录下出现了tensorflow的文件夹。</p></li><li><p>激活环境 activate tensorflow，关闭这个环境用命令 deactivate</p></li><li><p>安装tensorflow  conda install tensorflow</p><blockquote><p>conda安装比pip要方便不少，而且conda安装的tf效率要比pip安装的高。</p></blockquote></li><li><p>验证是否安装成功</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">hello = tf.constant(<span class="string">'Hello,tensorflow'</span>)</span><br><span class="line">sess = tf.Session()</span><br><span class="line">print(sess.run(hello))</span><br></pre></td></tr></table></figure><p>报错的话加上这段话</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line">os.environ[<span class="string">'TF_CPP_MIN_LOG_LEVEL'</span>] = <span class="string">'2'</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>tips：</strong>上面的方法将tensorflow安装在一个单独的环境当中，其他模块如numpy、opencv等都要重新配置，尝试将/Anaconda3/envs/tensorflow文件夹全部复制到/Anaconda3/Lib/site-packages下运行（参考了一篇安装在linux上的文章，结果不是很理想，放弃。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;tensorflow学习笔记-1&quot;&gt;&lt;a href=&quot;#tensorflow学习笔记-1&quot; class=&quot;headerlink&quot; title=&quot;tensorflow学习笔记_1&quot;&gt;&lt;/a&gt;tensorflow学习笔记_1&lt;/h1&gt;&lt;h2 id=&quot;环境安装-CPU版</summary>
      
    
    
    
    <category term="机器学习" scheme="http://yoursite.com/categories/机器学习/"/>
    
    
    <category term="tensorflow" scheme="http://yoursite.com/tags/tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>CDN_jsdelivr</title>
    <link href="http://yoursite.com/2019/05/06/CDN-jsdelivr/"/>
    <id>http://yoursite.com/2019/05/06/CDN-jsdelivr/</id>
    <published>2019-05-06T05:08:48.000Z</published>
    <updated>2019-05-08T10:31:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="blog引用资源路径由本地替换为CDN"><a href="#blog引用资源路径由本地替换为CDN" class="headerlink" title="blog引用资源路径由本地替换为CDN"></a>blog引用资源路径由本地替换为CDN</h1><blockquote><p>内容分发网络（Content Delivery Network），依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</p></blockquote><p>由于GitHub资源在国内加载过慢，有很多人选择通过CDN来提高资源加载速度，我选择了免费、速度快的<a href="https://www.jsdelivr.com/" target="_blank" rel="noopener">jsdelivr</a>，CDN的本质是缓存。</p><a id="more"></a><h2 id="1-在GitHub上Create-a-new-repository"><a href="#1-在GitHub上Create-a-new-repository" class="headerlink" title="1. 在GitHub上Create a new repository"></a>1. 在GitHub上Create a new repository</h2><p>得到repository name</p><h2 id="2-clone-这个仓库到本地"><a href="#2-clone-这个仓库到本地" class="headerlink" title="2. clone 这个仓库到本地"></a>2. clone 这个仓库到本地</h2><p>在文件夹下git bash here</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 你的仓库地址</span><br></pre></td></tr></table></figure><h2 id="3-上传资源"><a href="#3-上传资源" class="headerlink" title="3. 上传资源"></a>3. 上传资源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git status   # 查看仓库状态</span><br><span class="line">git add .    # 所有文件添加至缓存区</span><br><span class="line">git commit -m &quot;your_commit&quot;</span><br><span class="line">git push     # 推送至远端仓库</span><br></pre></td></tr></table></figure><h2 id="4-发布仓库"><a href="#4-发布仓库" class="headerlink" title="4. 发布仓库"></a>4. 发布仓库</h2><p>点击releases，版本号自定义</p><h2 id="5-引用资源"><a href="#5-引用资源" class="headerlink" title="5. 引用资源"></a>5. 引用资源</h2><p>通过路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://cdn.jsdelivr.net/gh/user/repo@version/file</span><br><span class="line">https://cdn.jsdelivr.net/gh/你的github用户名/你的仓库名@发布的版本号/文件路径</span><br></pre></td></tr></table></figure><p>可以CDN引用资源啦~</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;blog引用资源路径由本地替换为CDN&quot;&gt;&lt;a href=&quot;#blog引用资源路径由本地替换为CDN&quot; class=&quot;headerlink&quot; title=&quot;blog引用资源路径由本地替换为CDN&quot;&gt;&lt;/a&gt;blog引用资源路径由本地替换为CDN&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;内容分发网络（Content Delivery Network），依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于GitHub资源在国内加载过慢，有很多人选择通过CDN来提高资源加载速度，我选择了免费、速度快的&lt;a href=&quot;https://www.jsdelivr.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;jsdelivr&lt;/a&gt;，CDN的本质是缓存。&lt;/p&gt;</summary>
    
    
    
    <category term="HEXO搭建" scheme="http://yoursite.com/categories/HEXO搭建/"/>
    
    
    <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
    <category term="CDN" scheme="http://yoursite.com/tags/CDN/"/>
    
  </entry>
  
</feed>
