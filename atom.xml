<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sl&#39;s learning notes</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-04-07T03:13:25.592Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>_Silhouttes</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>omnetpp</title>
    <link href="http://yoursite.com/2021/04/07/omnetpp/"/>
    <id>http://yoursite.com/2021/04/07/omnetpp/</id>
    <published>2021-04-07T02:55:26.000Z</published>
    <updated>2021-04-07T03:13:25.592Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Tictoc-tutorial"><a href="#Tictoc-tutorial" class="headerlink" title="Tictoc_tutorial"></a>Tictoc_tutorial</h2><p>Network Description File(NED)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Tictoc-tutorial&quot;&gt;&lt;a href=&quot;#Tictoc-tutorial&quot; class=&quot;headerlink&quot; title=&quot;Tictoc_tutorial&quot;&gt;&lt;/a&gt;Tictoc_tutorial&lt;/h2&gt;&lt;p&gt;Network Descriptio</summary>
      
    
    
    
    
    <category term="omnetpp" scheme="http://yoursite.com/tags/omnetpp/"/>
    
  </entry>
  
  <entry>
    <title>Cpp_learningnote2</title>
    <link href="http://yoursite.com/2021/03/17/Cpp-learning-note-2/"/>
    <id>http://yoursite.com/2021/03/17/Cpp-learning-note-2/</id>
    <published>2021-03-16T16:00:00.000Z</published>
    <updated>2021-03-17T02:44:59.112Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>reference：《黑马》C++系列教程 <a href="https://blog.csdn.net/ClaireSy/article/details/108422945" target="_blank" rel="noopener">基础</a> <a href="https://blog.csdn.net/ClaireSy/article/details/108423047" target="_blank" rel="noopener">核心</a> <a href="https://blog.csdn.net/ClaireSy/article/details/108423061" target="_blank" rel="noopener">提高</a></p><blockquote><p>本篇主要参考核心篇进行记录</p></blockquote><h2 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h2><ul><li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li><li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li></ul><p>在C++中主要利用new在堆区开辟内存，释放利用操作符 delete，note释放数组 delete 后加 []</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><p>不要返回局部变量引用，可以返回静态变量引用 static</p></li><li><p>引用的本质，在C++内部实现是一个指针常量</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; ref = a;</span><br><span class="line"><span class="comment">//自动转化为int* const ref = &amp;a; 指针常量是指针指向不可改</span></span><br></pre></td></tr></table></figure><ul><li>在函数形参列表中，可以加const修饰形参，防止形参改变实参</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; ref = <span class="number">10</span>;  <span class="comment">//是错误的，引用本身需要一个合法的内存空间，不能直接赋值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//加入const，编译器会优化代码，int temp = 10; const int&amp; ref = temp;</span></span><br></pre></td></tr></table></figure><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.引用作为重载条件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>&amp; a)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> a </span>= <span class="number">10</span>;</span><br><span class="line">func(a);</span><br><span class="line">func(<span class="number">10</span>);<span class="comment">//调用不同的函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.函数重载遇到函数默认参数</span></span><br><span class="line">func2(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>)</span><br><span class="line">func2(<span class="keyword">int</span> a)</span><br><span class="line"><span class="comment">//这样的定义在调用的时候会报错</span></span><br><span class="line">func2(<span class="number">10</span>);<span class="comment">//产生歧义，不能做出调用函数的判断</span></span><br></pre></td></tr></table></figure><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><blockquote><p>OOP - <strong>封装、继承、多态</strong></p></blockquote><p>一、about <strong>类</strong></p><ul><li>语法：class 类名{ 访问权限: 属性 / 行为};</li><li>类在设计时，可以把属性和行为放在不同权限下，加以控制</li></ul><p>访问权限有三种：</p><p>– public 公共权限：        类内可以访问，类外可以访问（只允许本类的成员函数访问） </p><p>– protected 保护权限 ：类内可以访问，类外不可以访问 （只允许子类及本类的成员函数访问）</p><p>– private 私有权限：      类内可以访问，类外不可以访问（可以被任意实体访问）</p><ul><li>在C++中 struct 和 class 唯一的区别就在于默认的访问权限不同，struct默认权限为公共，class默认权限为私有</li></ul><p>二、concerning <strong>对象</strong></p><ul><li>对象的初始化和清理 – 构造函数和析构函数</li></ul><p>如果编程者不提供，编译器会自动提供空实现的构造和析构函数（这时候编译器自动添加的拷贝构造对属性的拷贝是浅拷贝</p><p><strong>–构造函数语法</strong>： 类名(){}</p><ol><li>构造函数没有返回值也不写void</li><li>函数名称与类名相同</li><li>构造函数可以参数，可能发生函数重载</li><li>程序在调用对象的时候会自动调用构造，且只调用一次</li></ol><p><strong>分类</strong> 按参数：有参构造、无参构造 按类型：普通构造、拷贝构造</p><p><strong>调用方式</strong> 括号法、显式法（类似java）、隐式转换法</p><p>*tips:</p><ol><li><p>调用无参构造函数不能加括号，加了编译器认为这是一个函数声名；</p></li><li><p>不能利用拷贝构造函数初始化匿名对象，编译器认为是对象声明；</p></li><li>拷贝构造函数的调用时机：<ul><li>使用一个已创建好的对象初始化新的对象</li><li>值传递的方式给函数参数传值</li><li>以值的方式返回局部对象 </li></ul></li></ol><p><strong>– 析构函数语法</strong>：~类名(){}</p><ol><li>析构函数没有返回值也不写void</li><li>函数名称与类名相同，前面加上符号~</li><li>析构函数不可以有参数，不能发生重载</li><li>程序在对象销毁前会自动调用析构，且只调用一次</li></ol><p>（一）深拷贝与浅拷贝</p><p>浅拷贝：简单的赋值拷贝操作</p><p>深拷贝：在<strong>堆区</strong>重新申请空间进行拷贝操作</p><p>如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的在delete时出现的问题</p><p>new -&gt; 在堆空间创建一块内存并返回内存地址给指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);<span class="comment">//这里定义变量类型为指针</span></span><br></pre></td></tr></table></figure><p>（二）初始化列表</p><p>语法：构造函数(): 属性1(值1)， 属性2(值2), …{}</p><p>只有构造函数可以使用初始化列表语法，引用数据成员与const数据成员必须使用这种语法，因为它们在创建时就需要初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c) :m_A(a), m_B(b), m_C(c) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_A:</span><br><span class="line"><span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">int</span> m_C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（三）类对象作为类成员</p><p>当类中成员时其他类对象时，我们称该成员为 对象成员</p><p>构造的顺序是：先调用对象成员的构造，再调用本类构造。析构的顺序与构造相反</p><p>（四）静态成员</p><p>在成员变量和成员函数前加上关键字static，称为静态成员</p><ul><li><p>静态成员变量（2种访问方式：通过对象、通过类名）</p><ul><li>所有对象共享同一份数据</li><li>在编译阶段分配内存</li><li><strong>类内声明，类外初始化</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> Person::m_B = <span class="number">10</span>;<span class="comment">//类外初始化</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Person::m_A &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//通过类名访问</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Person::m_B &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//会报错，没有访问权限</span></span><br></pre></td></tr></table></figure></li><li><p>静态成员函数</p><ul><li>所有对象共享同一个函数</li><li>静态成员函数只能访问静态成员变量</li></ul></li></ul><p>三、C++对象模型和this指针</p><p>在C++中，类内的成员变量和成员函数 分开储存，只有非静态成员变量才属于类的对象上。非静态成员变量占用对象空间，而静态成员变量和成员函数（静态/非静态）都不占用对象空间，所有非静态成员函数共享一个函数实例。</p><ul><li><p><strong>this指针</strong> 指向被调用成员函数所属的对象</p><ul><li>this指针是隐含在每一个<strong>非静态成员函数内</strong>的一种指针</li><li>不需要定义可以直接使用</li><li>用途：当形参和成员变量同名时，用this指针区分；在类的非静态成员函数中返回对象本身，可使用return *this</li><li>空指针也可以调用成员函数，但是当成员函数用到了this指针则不可以，这个时候需要对指针进行非空判断，保证代码的健壮性</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person* p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == <span class="literal">NULL</span>) <span class="keyword">return</span>;<span class="comment">//非空判断</span></span><br></pre></td></tr></table></figure><ul><li><strong>常函数</strong>：成员函数后加const​，在常函数内不可以修改成员属性，但是当成员属性声明时添加mutable关键字，在常函数内仍可以进行修改</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;...&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">mutable</span> <span class="keyword">int</span> m_B;</span><br></pre></td></tr></table></figure><ul><li><strong>常对象</strong>：声明对象前加const，常对象只能调用常函数，不能修改成员变量的值，但是可以访问</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person person;</span><br></pre></td></tr></table></figure></li></ul><p>四、友元 -&gt; 让一个函数或者类访问另一个类中的私有成员</p><p><strong>关键字</strong> friend</p><p>三种实现</p><ul><li>全局函数左右元</li><li>类做友元</li><li>成员函数做友元</li></ul><p>五、运算符重载 -&gt; 对已有的运算符重新进行定义，赋予另一种功能，以适应不同的数据类型</p><p>函数名由关键字 operator 和其后要进行重载的运算符符号构成的</p><p>通俗理解就是将数的相加、输出、比较判断等运算重载为直接对对象进行操作</p><p>六、<strong>继承</strong></p><p>class A: public B { }; 其中A类称为子类 或 派生类，B类成为父类 或 基类</p><p>派生类中的成员包含从基类继承的和自己增加的成员</p><ul><li>继承方式 语法： class 子类: 继承方式 父类<ul><li>公共继承 public</li><li>保护继承 protected</li><li>私有继承 private</li></ul></li></ul><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">public</th><th>protected</th><th>private</th></tr></thead><tbody><tr><td style="text-align:left">公有继承</td><td style="text-align:left">public</td><td>protected</td><td>不可见</td></tr><tr><td style="text-align:left">保护继承</td><td style="text-align:left">protected</td><td>protected</td><td>不可见</td></tr><tr><td style="text-align:left">私有继承</td><td style="text-align:left">private</td><td>private</td><td>不可见</td></tr></tbody></table><p>tips：</p><ol><li><p>父类中私有成员也被子类继承下去了，只是由编译器隐藏后不能访问</p></li><li><p>继承中，先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p></li></ol><ul><li>继承同名成员的处理方式<ul><li>访问子类同名成员 直接访问即可</li><li>访问父类同名成员 需要添加作用域</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base()&#123;m_A = <span class="number">100</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Son()&#123;m_A = <span class="number">200</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line">    s.func();<span class="comment">//直接访问子类同名成员</span></span><br><span class="line">    s.Base::func();<span class="comment">//添加作用域访问父类同名成员</span></span><br><span class="line">&#125;<span class="comment">//这里是子类以对象的方式进行访问</span></span><br></pre></td></tr></table></figure><p>*tips：对于同名静态成员处理方式与上面相同，不过有通过对象和通过类名两种访问方式</p><ul><li>多继承语法：class 子类: 继承方式 父类1, 继承方式 父类2 …</li><li>菱形继承（草泥马的例子好形象2333)</li></ul><blockquote><p>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承前加virtual关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">//此时公共的父类Animal称为虚基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuo</span>   :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheepTuo</span> :</span> <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SheepTuo st;</span><br><span class="line">st.Sheep::m_Age = <span class="number">100</span>;</span><br><span class="line">st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"st.Sheep::m_Age = "</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"st.Tuo::m_Age = "</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"st.m_Age = "</span> &lt;&lt; st.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*tips：采用虚继承解决菱形继承的问题，虚继承的目的是让某个类做出声明，承诺愿意共享它的基类</p><p>七、<strong>多态</strong></p><p>分类：</p><ul><li>静态多态：函数重载和运算符重载属于静态多态，复用函数名</li><li>动态多态：派生类和虚函数实现运行时多态</li></ul><p>区别：静态–函数地址早绑定 - 编译阶段确定函数地址</p><p>动态–函数地址晚绑定 - 运行阶段确定函数地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//函数前加上virtual关键字，变成虚函数，编译器在编译的时候就不能确定函数调用</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span><span class="keyword">public</span> Animal&#123;<span class="comment">//继承Animal类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//Q:这里为virtual为什么可以省略不写</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span><span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSpeak</span><span class="params">(Animal &amp; animal)</span></span>&#123;</span><br><span class="line">    animal.speak();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Cat cat;</span><br><span class="line">    DoSpeak(cat);<span class="comment">//传入什么对象，就调用什么对象的寒素</span></span><br><span class="line">    Dog dog;</span><br><span class="line">    DoSpeak(dog);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多态满足条件：1. 有继承关系 2. 子类重写父类中的虚函数</li><li>多态使用：父类指针或引用指向子类对象</li></ul><p>重写：函数返回值类型 函数名 参数列表 完全一致称为重写</p><p>在多态中，通常父类中虚函数饿实现是毫无意义的，主要都是调用子类重写的内容</p><p>因此可以将虚函数改为<strong>纯虚函数</strong></p><ul><li>纯虚函数语法：virtual 返回值类型 函数名 (参数列表) = 0;</li></ul><p>当类中有了虚函数（虚构造函数或虚析构函数），这个类也成为<strong>抽象类</strong>（类中只要有一个纯虚函数就成为抽象类）</p><p>抽象类特点：</p><ol><li><p>无法实例化对象</p></li><li><p>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</p></li></ol><p>Q：多态使用时，子类中开辟属性到堆区（new），父类指针在释放时无法调用子类的析构代码</p><p>A：将父类中的析构函数改为<strong>虚析构</strong>或<strong>纯虚析构</strong></p><ul><li>虚析构和纯虚析构共性：<ul><li>可以解决父类指针释放子类对象的问题</li><li>都需要有具体的函数实现</li></ul></li><li>虚析构和纯虚析构区别：<ul><li>纯虚析构，该类属于抽象类，无法实例化对象</li></ul></li></ul><p>虚析构语法：virtual ~类名 () {}</p><p>纯虚析构语法：类内 -&gt; virtual ~类名() = 0;  类外 -&gt; 类名::~类名() {}</p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>C++中对文件操作许哟啊包含头文件<code>&lt;fstream&gt;</code></p><p>文件类型：</p><ol><li>文本文件：以ASCII码形式储存在计算机中</li><li>二进制文件：以二进制形式存储在计算机中</li></ol><p>操作文件的三大类：</p><ol><li>ofstream：写操作</li><li>ifstream：读操作</li><li>fstream：读写操作</li></ol><h3 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h3><ul><li>写文件<ol><li>包含头文件<code>#include&lt;fstream&gt;</code></li><li>创建流对象<code>ofstream ofs;</code></li><li>打开文件<code>ofs.open(&quot;file_path&quot;, way);</code></li><li>写数据<code>ofs&lt;&lt;&quot;writing data&quot;;</code></li><li>关闭文件<code>ofs.close();</code></li></ol></li><li>文件打开方式</li></ul><table><thead><tr><th style="text-align:center">打开方式</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">ios::in</td><td style="text-align:center">为读文件而打开文件</td></tr><tr><td style="text-align:center">ios::out</td><td style="text-align:center">为写文件而打开文件</td></tr><tr><td style="text-align:center">ios::ate</td><td style="text-align:center">初始位置：文件尾</td></tr><tr><td style="text-align:center">ios::app</td><td style="text-align:center">追加方式写文件</td></tr><tr><td style="text-align:center">ios::trunc</td><td style="text-align:center">如果文件存在先删除，再创建</td></tr><tr><td style="text-align:center">ios::binary</td><td style="text-align:center">二进制方式</td></tr></tbody></table><p>文件打开方式可以配合使用，利用<code>|</code>操作符</p><p>e.g. 用二进制方式写文件<code>ios::binary|ios::out</code></p><ul><li><p>读文件</p><ol><li><p>包含头文件<code>#include&lt;fstream&gt;</code></p></li><li><p>创建流对象<code>ifstream ifs;</code></p></li><li><p>打开文件<code>ifs.open(&quot;file_path&quot;, way);</code>，利用<code>is_open</code>函数可以判断文件是否打开成功</p></li><li><p>读数据 四种方式</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(ifs &gt;&gt; buf)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(ifs.getline(buf, <span class="keyword">sizeof</span>(buf)))&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> buf;</span><br><span class="line"><span class="keyword">while</span>(getline(ifs, buf))&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">while</span>((c = ifs.get()) != EOF)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>关闭文件<code>ifs.close();</code></p></li></ol></li></ul><h3 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h3><p>打开方式指定为<code>ios::binary</code></p><ul><li>写文件 利用流对象调用成员函数wirte</li></ul><p>函数原型 <code>ofstream&amp; write(const char * buffer,int len);</code></p><ul><li>写文件 利用流对象调用成员函数read</li></ul><p>函数原型 <code>ifstream&amp; read(char *buffer,int len);</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;reference：《黑马》C++系列教程 &lt;a href=&quot;https://blog.csdn.net/ClaireSy/article/details/108422945&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;基础&lt;/</summary>
      
    
    
    
    
    <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Cpp_learningnote3</title>
    <link href="http://yoursite.com/2021/03/17/Cpp-learning-note-3/"/>
    <id>http://yoursite.com/2021/03/17/Cpp-learning-note-3/</id>
    <published>2021-03-16T16:00:00.000Z</published>
    <updated>2021-07-03T06:58:25.331Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>reference：《黑马》C++系列教程 <a href="https://blog.csdn.net/ClaireSy/article/details/108422945" target="_blank" rel="noopener">基础</a> <a href="https://blog.csdn.net/ClaireSy/article/details/108423047" target="_blank" rel="noopener">核心</a> <a href="https://blog.csdn.net/ClaireSy/article/details/108423061" target="_blank" rel="noopener">提高</a></p><blockquote><p>本篇主要参考提高篇进行记录</p></blockquote><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ul><li><p>模板就是建立通用的模具，提高复用性。模板只是一个框架，不能直接使用</p></li><li><p><strong>函数模板</strong></p><ul><li>C++另一种编程思想称为 <strong>泛型编程</strong>，主要利用的技术就是模板</li><li>C++提供两种模板机制：函数模板 和 类模板</li></ul></li></ul><p>函数模板语法：<code>template&lt;typename T&gt;</code>，其中typename可以用class代替</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T&amp; a,T&amp; b)</span></span>&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>,b = <span class="number">20</span>;</span><br><span class="line">Swap(a, b);<span class="comment">//1.自动类型推导</span></span><br><span class="line">Swap&lt;<span class="keyword">int</span>&gt;(a, b);<span class="comment">//2.显示指定类型</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*tips：</p><ol><li><p>自动类型推导，必须推导出<strong>一致的数据类型T</strong>才可以使用</p></li><li><p>显示指定类型，必须<strong>确定出T的数据类型</strong>才可以使用</p></li></ol><p>也就是说，凡是给出了模板定义，之后跟着的函数，必须给出数据类型才能调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"test"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="comment">//函数中没用用到模板类型T，但是调用时必须给出才能使用</span></span><br></pre></td></tr></table></figure><ul><li>普通函数与函数模板的区别</li></ul><ol><li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li><li>函数模板调用的时候，如果利用自动类型推导，不会发生隐式类型转换</li><li>如果利用显式指定类型的方式，可以发生隐式类型转换</li></ol><ul><li>普通函数与函数模板的调用规则</li></ul><ol><li>如果函数模板和普通函数都可以实现，优先调用普通函数</li><li>可以通过空模板参数列表来强制调用函数模板  <code>funtion&lt;&gt;(a, b);</code></li><li>函数模板也可以发生重载</li><li>如果函数模板可以产生更好的匹配（例如不用进行隐式转换），优先调用函数模板</li></ol><ul><li>模板的局限性：传入数组、类对象、自定义数据类型等数据不能处理，可以为这些特定的类型提供具体化的模板</li></ul><p>具体化的模板以<code>template&lt;&gt;</code>开头，通过名称来指出类型，具体化优先于常规模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;&gt; <span class="keyword">bool</span> <span class="title">compare</span><span class="params">(Person&amp; p1, Person&amp; p2)</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>类模板</strong></li></ul><p>建立一个通用类，类中的成员数据类型可以不具体指定，用一个虚拟的类型来代表</p><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1， <span class="keyword">typename</span> T2, ...&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span></span></span><br></pre></td></tr></table></figure><ul><li>类模板与函数模板的区别</li></ul><ol><li>类模板<strong>没有自动类型推导</strong>的使用方式</li><li>类模板在模板参数列表中可以有默认参数（在显示指定的时候可以更换参数类型，如int-&gt;double）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">nametype</span>, <span class="title">class</span> <span class="title">agetype</span> = <span class="title">int</span>&gt;//2.<span class="title">defualt</span> <span class="title">parameter</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Person</span>&#123;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Person &lt;string, double&gt;p('string',10);//1.显示指定</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类模板中的成员函数并不是一开始就创建的，在调用的时候才会创建</li><li>类模板对象做函数参数</li></ul><ol><li>指定传入的类型 – 直接显示对象的数据类型</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; &amp;p)</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>参数模板化 – 将对象中的参数变为模板进行传递</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">printPerson2</span>(<span class="title">Person</span>&lt;T1, T2&gt;&amp;<span class="title">p</span>)&#123;</span></span><br><span class="line">p.showPerson();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"T1的类型为： "</span> &lt;&lt; <span class="keyword">typeid</span>(T1).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"T2的类型为： "</span> &lt;&lt; <span class="keyword">typeid</span>(T2).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>整个类模板化 – 将这个对象类型模板化进行传递</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">printPerson3</span>(<span class="title">T</span> &amp; <span class="title">p</span>)&#123;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"T的类型为： "</span> &lt;&lt; <span class="keyword">typeid</span>(T).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">p.showPerson();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类模板与继承</li></ul><ol><li>当子类继承的父类是一个类模板时，子类在声明的时候要制定出父类中T的类型</li><li>如果不指定，编译器无法给子类分配内存</li><li>如果想灵活制定出父类中T的类型，子类也需要变为类模板</li></ol><ul><li>类模板成员函数类外实现</li><li>类模板份文件编写</li><li>类模板与友元</li></ul><h2 id="STL初识"><a href="#STL初识" class="headerlink" title="STL初识"></a>STL初识</h2><blockquote><p>STL(Standard Template Library, 标准模板库)</p></blockquote><p>STL广义上分为：<strong>容器(container)、算法(algorithm)和迭代器(iterator)</strong>。其中容器和算法之间通过迭代器进行无缝连接。STL中几乎所有的代码都采用了模板类或者模板函数。</p><h3 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h3><p>STL大体分为六大组件，分别是：容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</p><ol><li>容器：各种数据结构，如vector、list、deque、set和map等，用来存放数据；</li><li>算法：各种常用的算法，如sort、find、copy、for_each等；</li><li>迭代器：扮演了容器与算法之间的胶合剂；</li><li>仿函数：行为类似函数，可以作为算法的某种策略；</li><li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西；</li><li>空间配置器：负责空间的配置与管理。</li></ol><ul><li>STL中容器、算法、迭代器</li></ul><ol><li>容器将运用最广泛的一些数据结构实现出来，分为序列式容器和关联式容器两种：</li></ol><p>序列式容器：强调值的排序，序列式容器中的每个元素均有固定的位置。</p><p>关联式容器：二叉树结构，各元素之间没有严格的物理上的顺序关系</p><ol start="2"><li>算法分为质变算法和非质变算法：</li></ol><p>质变算法：是指运算过程中会更改区间内的元素内容，如拷贝、替换、删除等</p><p>非质变算法：是指运算过程中不会更改区间内的元素内容，如查找、计数、遍历、寻找极值等</p><ol start="3"><li>迭代器：提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。每个容器都有自己专属的迭代器（类似于指针）</li></ol><h3 id="容器算法迭代器初识"><a href="#容器算法迭代器初识" class="headerlink" title="容器算法迭代器初识"></a>容器算法迭代器初识</h3><ol><li>vector存放内置数据类型</li></ol><hr><p>容器：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">算法：```for_each</span><br></pre></td></tr></table></figure></p><p>迭代器：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"> ```c++</span><br><span class="line"> #include &lt;vector&gt;</span><br><span class="line"> #include &lt;algorithm&gt;</span><br><span class="line"> </span><br><span class="line"> void MyPrint(int val)</span><br><span class="line"> &#123;</span><br><span class="line">     cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> void test()&#123;</span><br><span class="line">     vector&lt;int&gt; v;</span><br><span class="line">     v.push_back(10);</span><br><span class="line">     v.push_back(20);</span><br><span class="line">     v.push_back(30);</span><br><span class="line">     v.push_back(40);</span><br><span class="line">     </span><br><span class="line">     vector&lt;int&gt;::iterator pBegin = v.begin();</span><br><span class="line">     vector&lt;int&gt;::iterator pEnd = v.end();</span><br><span class="line">     // 遍历方式1</span><br><span class="line">     while(pBegin != pEnd) &#123;</span><br><span class="line"> cout &lt;&lt; *pBegin &lt;&lt; endl;</span><br><span class="line">         pBegin++;</span><br><span class="line">     &#125;</span><br><span class="line">     // 遍历方式2</span><br><span class="line">     for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)&#123;</span><br><span class="line">         cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">     &#125;</span><br><span class="line">     // 遍历方式3</span><br><span class="line">     for_each(v.begin(), v.end(), Myprint);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> int main()&#123;</span><br><span class="line"> test();</span><br><span class="line">     system(&quot;pause&quot;);</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>vector存放自定义数据类型</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)&#123;</span><br><span class="line">    mName = name;</span><br><span class="line">    mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> mName;</span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 存放对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"aaa"</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"bbb"</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"ccc"</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    v.push_back(p1);</span><br><span class="line">    v.push_back(p2);</span><br><span class="line">    v.push_back(p3);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Person&gt;::iterator it = v.begin(); it!=v.end(); it++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Name: "</span> &lt;&lt; (*it).mName &lt;&lt;<span class="string">", Age: "</span> &lt;&lt; (*it).mAge &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 存放对象指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Person*&gt; v;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"aaa"</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"bbb"</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"ccc"</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    v.push_back(&amp;p1);</span><br><span class="line">    v.push_back(&amp;p2);</span><br><span class="line">    v.push_back(&amp;p3);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Person*&gt;::iterator it = v.begin(); it!=v.end(); it++) &#123;</span><br><span class="line">        Person* p = (*it);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Name: "</span> &lt;&lt; p-&gt;mName &lt;&lt;<span class="string">", Age: "</span> &lt;&lt; (*it)-&gt;mAge &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>vector容器嵌套容器</li></ol><blockquote><p>容器中嵌套容器，将所有数据遍历输出</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        v1.push_back(i+<span class="number">1</span>);</span><br><span class="line">        v2.push_back(i+<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    v.push_back(v1);</span><br><span class="line">    v.push_back(v2);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;::iterator pBegin = v.begin();</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;::iterator pEnd = v.end();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pBegin != pEnd) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator vit = pBegin-&gt;begin(); vit != pBegin-&gt;end(); vit++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *vit &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        pBegin++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="STL-常用容器"><a href="#STL-常用容器" class="headerlink" title="STL - 常用容器"></a>STL - 常用容器</h2><h3 id="string容器"><a href="#string容器" class="headerlink" title="string容器"></a>string容器</h3><ul><li>string是c++风格的字符串，本质上是一个类</li></ul><p>string与char <em>的区别：char\</em>是一个指针，string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。</p><ul><li>string构造函数</li></ul><p><code>string()</code>// 创建一个空的字符串</p><p><code>string(const char* s)</code>// 使用字符串s初始化</p><p><code>string(const string&amp; str)</code>// 使用一个string对象初始化另一个string对象</p><p><code>string(int n, char c)</code>// 使用n个字符c初始化</p><ul><li>string赋值操作</li></ul><p><code>string&amp; operator=(const char* s);</code> //char*类型字符串赋值给当前的字符串</p><p><code>string&amp; operator=(const string &amp;s);</code> //把字符串s赋给当前的字符串</p><p><code>string&amp; operator=(char c);</code> //字符赋值给当前的字符串</p><p><code>string&amp; assign(const char *s);</code> //把字符串s赋给当前的字符串</p><p><code>string&amp; assign(const char *s, int n);</code> //把字符串s的前n个字符赋给当前的字符串</p><p><code>string&amp; assign(const string &amp;s);</code> //把字符串s赋给当前字符串</p><p><code>string&amp; assign(int n, char c);</code> //用n个字符c赋给当前字符串</p><ul><li>string字符串拼接</li></ul><blockquote><p>实现在字符串末尾拼接字符串</p></blockquote><p><code>string&amp; operator+=(const char* str);</code> //重载+=操作符</p><p><code>string&amp; operator+=(const char c);</code> //重载+=操作符</p><p><code>string&amp; operator+=(const string&amp; str);</code> //重载+=操作符</p><p><code>string&amp; append(const char *s);</code> //把字符串s连接到当前字符串结尾</p><p><code>string&amp; append(const char *s, int n);</code> //把字符串s的前n个字符连接到当前字符串结尾</p><p><code>string&amp; append(const string &amp;s);</code> //同operator+=(const string&amp; str)</p><p><code>string&amp; append(const string &amp;s, int pos, int n);</code>//字符串s中从pos开始的n个字符连接到字符串结尾</p><ul><li>string查找和替换</li></ul><blockquote><p>查找：查找指定字符串是否存在</p><p>替换：在指定的位置替换字符</p></blockquote><p><code>int find(const string&amp; str, int pos = 0) const;</code> //查找str第一次出现位置,从pos开始查找</p><p><code>int find(const char* s, int pos = 0) const;</code> //查找s第一次出现位置,从pos开始查找</p><p><code>int find(const char* s, int pos, int n) const;</code> //从pos位置查找s的前n个字符第一次位置</p><p><code>int find(const char c, int pos = 0) const;</code> //查找字符c第一次出现位置</p><p><code>int rfind(const string&amp; str, int pos = npos) const;</code> //查找str最后一次位置,从pos开始查找</p><p><code>int rfind(const char* s, int pos = npos) const;</code> //查找s最后一次出现位置,从pos开始查找</p><p><code>int rfind(const char* s, int pos, int n) const;</code> //从pos查找s的前n个字符最后一次位置</p><p><code>int rfind(const char c, int pos = 0) const;</code> //查找字符c最后一次出现位置</p><p><code>string&amp; replace(int pos, int n, const string&amp; str);</code> //替换从pos开始n个字符为字符串str</p><p><code>string&amp; replace(int pos, int n,const char* s);</code> //替换从pos开始的n个字符为字符串s</p><blockquote><p>conclusion：find查找是从左向右，rfind自右向左；find找不到时返回-1；replace要指定从哪个位置起，多少个字符，替换的字符串。</p></blockquote><ul><li>string字符串比较</li></ul><blockquote><p>字符串按字符的ASCII码进行对比，=返回0、&gt;返回1、&lt;返回-1</p></blockquote><p><code>int compare(const string &amp;s) const;</code> //与字符串s比较</p><p><code>int compare(const char *s) const;</code> //与字符串s比较</p><ul><li>string字符串存取</li></ul><p>string中单个字符存取方式有两种</p><p><code>char&amp; operator[](int n);</code> //通过[]方式取字符</p><p><code>char&amp; at(int n);</code> //通过at方法获取字符</p><ul><li>string插入和删除</li></ul><p><code>string&amp; insert(int pos, const char* s);</code> //插入字符串</p><p><code>string&amp; insert(int pos, const string&amp; str);</code> //插入字符串</p><p><code>string&amp; insert(int pos, int n, char c);</code> //在指定位置插入n个字符c</p><p><code>string&amp; erase(int pos, int n = npos);</code> //删除从Pos开始的n个字符</p><ul><li>string子串</li></ul><blockquote><p>从字符串中获取想要的子串</p></blockquote><p><code>string substr(int pos = 0, int n = npos) const;</code> //返回由pos开始的n个字符组成的字符串</p><h3 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h3><blockquote><p>vector数据结构和数组非常相似，也称为单端数组；不同之处在于数组是静态空间，而vector可以动态扩展。这里的动态扩展并不是在原空间之后续接新空间，而是找更大的内存空间，将原数据copy新空间，释放原空间。</p></blockquote><ul><li>vector构造函数</li></ul><p><code>vector&lt;T&gt; v;</code> //采用模板实现类实现，默认构造函数</p><p><code>vector(v.begin(), v.end());</code> //将v[begin(), end())区间中的元素拷贝给本身。</p><p><code>vector(n, elem);</code> //构造函数将n个elem拷贝给本身。</p><p><code>vector(const vector &amp;vec);</code> //拷贝构造函数。</p><ul><li>vector赋值操作</li></ul><p><code>vector&amp; operator=(const vector &amp;vec);</code>//重载等号操作符</p><p><code>assign(beg, end);</code> //将[beg, end)区间中的数据拷贝赋值给本身。</p><p><code>assign(n, elem);</code> //将n个elem拷贝赋值给本身。</p><ul><li>vector容量和大小</li></ul><p><code>empty();</code> //判断容器是否为空</p><p><code>capacity();</code> //容器的容量</p><p><code>size();</code> //返回容器中元素的个数</p><p><code>resize(int num);</code> //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p><p><code>resize(int num, elem);</code> //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除</p><ul><li>vector插入和删除</li></ul><p><code>push_back(ele);</code> //尾部插入元素ele</p><p><code>pop_back();</code> //删除<strong>最后一个元素</strong></p><p><code>insert(const_iterator pos, ele);</code> //迭代器指向位置pos插入元素ele</p><p><code>insert(const_iterator pos, int count,ele);</code>//迭代器指向位置pos插入count个元素ele</p><p><code>erase(const_iterator pos);</code> //删除迭代器指向的元素</p><p><code>erase(const_iterator start, const_iterator end);</code>//删除迭代器从start到end之间的元素</p><p><code>clear();</code> //删除容器中所有元素</p><ul><li>vector数据存取（除了用迭代去获取vector容器中元素，[]和at也可以）</li></ul><p><code>at(int idx);</code> //返回索引idx所指的数据</p><p><code>operator[];</code> //返回索引idx所指的数据</p><p><code>front();</code> //返回容器中第一个数据元素</p><p><code>back();</code> //返回容器中最后一个数据元素</p><ul><li>vector互换容器</li></ul><p><code>swap(vec);</code> // 将vec与本身的元素互换</p><ul><li>vector预留空间</li></ul><blockquote><p>减少vector在动态扩展容量时的扩展次数</p></blockquote><p><code>reserve(int len);</code> // 容器预留len个元素长度，预留位置不初始化，元素不可访问</p><h3 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h3><blockquote><p>双端数组，可以对头端进行插入和删除操作。</p></blockquote><p>deque与vector区别：</p><ul><li>vector对于头部的插入删除效率低，数据量越大，效率越低</li><li>deque相对而言，对头部的插入删除速度比vector块</li><li>vector访问元素时的速度比deque快</li></ul><p>deque内部工作原理：</p><p>​        deque内部有一个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据。中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间。deque容器的迭代器也是支持随机访问的。</p><h3 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a>stack容器</h3><blockquote><p>stack是一种先进后出（FILO）的数据结构，它只有一个出口。</p></blockquote><p>栈中只有顶端的元素才可以被外界使用，不允许有遍历行为。有push和pop操作。</p><ul><li>stack常用接口</li></ul><p>入栈 — push</p><p>出栈 — pop</p><p>返回栈顶 — top</p><p>判断栈是否为空 — empty</p><p>返回栈大小 — size</p><h3 id="queue容器"><a href="#queue容器" class="headerlink" title="queue容器"></a>queue容器</h3><blockquote><p>queue是一种FIFO的数据结构，有两个出口。</p></blockquote><p>队列容器允许从一端新增元素，从另一端移除元素，只有队头和队尾才可以被使用，不允许有遍历行为。</p><ul><li>queue常用接口</li></ul><p>入队 — push</p><p>出队 — pop</p><p>返回队头元素 — front</p><p>返回队尾元素 — back</p><p>判断队是否为空 — empty</p><p>返回队列大小 — size</p><h3 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h3><blockquote><p>list（链表）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的，list将数据进行链式储存。</p></blockquote><p>STL中的链表是一个双向循环链表，list的迭代器只支持前移和后移，属于双向迭代器。</p><p>list有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</p><blockquote><p>tips: const_iterator和iterator都可以遍历容器的元素，并访问这些元素的值。iterator可以改变元素值，但是const_iterator不可改。</p></blockquote><ul><li>list 插入与删除</li></ul><p>尾插 — push_back</p><p>尾删 — pop_back</p><p>头插 — push_front</p><p>头删 — pop_front</p><p>插入 — insert</p><p>删除 — erase</p><p>移除 — remove</p><p>清空 — clear</p><ul><li>list反转和排序</li></ul><p>反转 — reverse</p><p>排序 — sort （成员函数）</p><h3 id="set-multiset容器"><a href="#set-multiset容器" class="headerlink" title="set/multiset容器"></a>set/multiset容器</h3><blockquote><p>所有元素都会在插入时自动被排序</p></blockquote><p>本质：set/multiset属于关联式容器。底层结构是用二叉树实现的。</p><ul><li>set与multiset区别：set不允许容器中有重复元素，multiset允许容器中有重复元素。</li></ul><p>set不可以插入重复数据，而multiset可以</p><p>set插入数据的同时会返回插入结果，表示插入是否成功</p><p>multiset不会检测数据，因此可以插入重复数据</p><ul><li>set构造与赋值</li></ul><p>set容器插入数据时用insert</p><p>set容器插入数据的数据会自动排序</p><ul><li>set大小和交换</li></ul><p>统计大小 — size</p><p>判断是否为空 — empty</p><p>交换容器 — swap</p><ul><li>set查找和统计</li></ul><p>查找 — find （返回的是迭代器）</p><p>统计 — count （对于set，结果为0或者1）</p><ul><li>pair对组创建</li></ul><blockquote><p>成对出现的数据，利用对组可以返回两个数据</p></blockquote><p><code>pair&lt;type, type&gt; p ( value1, value2 );</code></p><p><code>pair&lt;type, type&gt; p = make_pair( value1, value2 );</code></p><p><code>pair&lt;set&lt;int&gt;::iterator, bool&gt;  ret = s.insert(10);</code># 注意insert()的返回是一个pair对组，此外对pair对组的访问通过<code>pair.first or pair.second</code>进行。</p><ul><li>set容器排序</li></ul><blockquote><p>set容器默认排序规则为从小到大，利用仿函数，可以改变排序规则。</p><p>仿函数 (functor)，就是<strong>使一个类的使用看上去像一个函数</strong>。 其实现就是类中实现一个 operator ()，这个类就有了类似函数的行为，就是一个仿函数类了。</p></blockquote><p>通过定义结构体(或类)，并在其中重载()运算符，来自定义排序函数。然后，在定义set的时候，将结构体加入其中例如如下代码中的set&lt;int, intComp&gt;和set&lt;string, strComp &gt;。</p><h3 id="map-multimap容器"><a href="#map-multimap容器" class="headerlink" title="map/multimap容器"></a>map/multimap容器</h3><blockquote><p>map中所有元素都是pair，pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值），所有元素都会根据元素的key自动排序。</p></blockquote><p>本质：map/multimap属于关联式容器，底层结构用二叉树实现。</p><ul><li>map和multimap的区别：map不允许容器中有重复的key，而multimap可以</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;reference：《黑马》C++系列教程 &lt;a href=&quot;https://blog.csdn.net/ClaireSy/article/details/108422945&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;基础&lt;/</summary>
      
    
    
    
    
    <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>makefile</title>
    <link href="http://yoursite.com/2021/03/17/Makefile/"/>
    <id>http://yoursite.com/2021/03/17/Makefile/</id>
    <published>2021-03-16T16:00:00.000Z</published>
    <updated>2021-03-23T07:20:09.104Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="Makefile-learning"><a href="#Makefile-learning" class="headerlink" title="Makefile_learning"></a>Makefile_learning</h2><blockquote><p>教程：<a href="http://c.biancheng.net/makefile/" target="_blank" rel="noopener">http://c.biancheng.net/makefile/</a></p></blockquote><p>makefile描述的是文件编译的相关规则，由依赖的关系和执行的命令两部分组成</p><ul><li>结构：</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">targets: prerequisites</span></span><br><span class="line">command</span><br></pre></td></tr></table></figure><ul><li>targets：规则的目标，可以是中间文件（*.o），也可以是执行文件（*.elf），还可以是一个标签（clean等）</li><li>prerequisites：依赖文件，要生成targets需要的文件或目标</li><li>command：make需要执行的命令（任意的shell命令）</li></ul><blockquote><p>attention：目标和依赖之间要用冒号分隔开，命令的开始一定要使用<code>tab</code>键</p></blockquote><h3 id="makefile的工作流程"><a href="#makefile的工作流程" class="headerlink" title="makefile的工作流程"></a>makefile的工作流程</h3><p>默认情况下，make执行的是Makefile中的第一规则（Makefile中出现的第一个依赖关系），此规则的第一目标称为“最终目标”，根据依赖关系查找下一条要执行的规则。</p><p>这里我们知道，编译时生成的 “.o” 文件。作用是检查某个源文件是不是进行过修改，最终目标文件是不是需要重建。</p><p>清除过程文件：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf *.0 test</span><br></pre></td></tr></table></figure><p>Makefile文件所在目录有文件名为clean的文件，命令行“.PHONY: clean”又没添加的话，执行make clean是无效的，“.PHONY: clean”就是保证即使目录下有文件名为clean的文件，也能正常执行make clean</p><h3 id="通配符的使用"><a href="#通配符的使用" class="headerlink" title="通配符的使用"></a>通配符的使用</h3><p>通配符可以出现在模式的规则中，也可以出现在命令中</p><table><thead><tr><th>通配符</th><th>使用说明</th></tr></thead><tbody><tr><td>*</td><td>匹配0个或者是任意个字符</td></tr><tr><td>？</td><td>匹配任意一个字符</td></tr><tr><td>[]</td><td>我们可以指定匹配的字符放在 “[]” 中</td></tr><tr><td>%</td><td>匹配任意个字符，储存名字在一个列表中，挨个查找</td></tr></tbody></table><ul><li>如果我们的通配符使用在<strong>依赖的规则中</strong>的话一定要注意这个问题：不能通过引用变量的方式来使用，但就是想要通过引用变量的话，我们要使用一个函数 “wildcard”，这个函数在我们引用变量的时候，会帮我们展开</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OBJ = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"><span class="section">test: <span class="variable">$(OBJ)</span></span></span><br><span class="line">gcc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure><h3 id="变量的定义和使用"><a href="#变量的定义和使用" class="headerlink" title="变量的定义和使用"></a>变量的定义和使用</h3><ul><li>基本语法<code>VALUE_LIST = one two three</code></li></ul><p>调用变量的时候用<code>$(VALUE_LIST)</code>或<code>${VALUE_LIST}</code>来替换</p><ul><li>四种基本赋值方式<ul><li>简单赋值（:=）只对当前语句的变量有效</li><li>递归赋值（=）所有目标变量相关的其他变量都受影响</li><li>条件赋值（?=）如果变量未定义，则使用符号中的值（等号后的值）定义变量，如果变量已经赋值，则该赋值语句无效（保持原定义的值）</li><li>追加赋值（+=）原变量用空格隔开的方式追加一个新值</li></ul></li></ul><h3 id="makefile自动化变量"><a href="#makefile自动化变量" class="headerlink" title="makefile自动化变量"></a>makefile自动化变量</h3><p>自动化变量可以理解为由 Makefile 自动产生的变量，自动化变量的取值根据执行的规则来决定，取决于执行规则的目标问价和依赖文件。</p><table><thead><tr><th>自动化变量</th><th>说明</th></tr></thead><tbody><tr><td>$@</td><td>表示规则的目标文件名。如果目标是一个文档文件（Linux 中，一般成 .a 文件为文档文件，也称为静态的库文件）， 那么它代表这个文档的文件名。在多目标模式规则中，它代表的是触发规则被执行的文件名。</td></tr><tr><td>$%</td><td>当目标文件是一个静态库文件时，代表静态库的一个成员名。</td></tr><tr><td>$&lt;</td><td>规则的第一个依赖的文件名。如果是一个目标文件使用隐含的规则来重建，则它代表由隐含规则加入的第一个依赖文件。</td></tr><tr><td>$?</td><td>所有比目标文件更新的依赖文件列表，空格分隔。如果目标文件是静态库文件，代表的是库文件（.o 文件）。</td></tr><tr><td>$^</td><td>代表的是所有依赖文件列表，使用空格分隔。如果目标是静态库文件，它所代表的只能是所有的库成员（.o 文件）名。 一个文件可重复的出现在目标的依赖中，变量“\$^”只记录它的第一次引用的情况。就是说变量“\$^”会去掉重复的依赖文件。</td></tr><tr><td>$+</td><td>类似“$^”，但是它保留了依赖文件中重复出现的文件。主要用在程序链接时库的交叉引用场合。</td></tr><tr><td>$*</td><td>在模式规则和静态模式规则中，代表“茎”。“茎”是目标模式中“%”所代表的部分（当文件名中存在目录时， “茎”也包含目录部分）。</td></tr></tbody></table><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test:test.o test1.o test2.o</span></span><br><span class="line">         gcc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"><span class="section">test.o:test.c test.h</span></span><br><span class="line">         gcc -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"><span class="section">test1.o:test1.c test1.h</span></span><br><span class="line">         gcc -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"><span class="section">test2.o:test2.c test2.h</span></span><br><span class="line">         gcc -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure><p>GNU make 中在这些变量中加入字符 “D” 或者 “F” 就形成了一系列变种的自动化变量，这些自动化变量可以对文件的名称进行操作。</p><table><thead><tr><th>变量名</th><th>功能</th></tr></thead><tbody><tr><td>$(@D)</td><td>表示文件的目录部分（不包括斜杠）。如果 “$\@” 表示的是 “dir/foo.o” 那么 “\$(@D)” 表示的值就是 “dir”。如果 “\$@” 不存在斜杠（文件在当前目录下），其值就是 “.”。</td></tr><tr><td>$(@F)</td><td>表示的是文件除目录外的部分（实际的文件名）。如果 “\$@” 表示的是 “dir/foo.o”，那么 “\$@F” 表示的值为 “dir”。</td></tr><tr><td>\$(*D) ​\$(*F)</td><td>分别代表 “茎” 中的目录部分和文件名部分</td></tr><tr><td>\$(%D) \$(%F)</td><td>当以 “archive(member)” 形式静态库为目标时，分别表示库文件成员 “member” 名中的目录部分和文件名部分。(?)</td></tr><tr><td>\$(&lt;D) ​\$(&lt;F)</td><td>表示第一个依赖文件的目录部分和文件名部分。</td></tr><tr><td>\$(^D) ​\$(^F)</td><td>分别表示所有依赖文件的目录部分和文件部分。</td></tr><tr><td>\$(+D) ​\$(+F)</td><td>分别表示所有的依赖文件的目录部分和文件部分。</td></tr><tr><td>\$(?D) ​\$(?F)</td><td>分别表示更新的依赖文件的目录部分和文件名部分。</td></tr></tbody></table><h3 id="makefile目标文件搜索（VPATH和vpath）"><a href="#makefile目标文件搜索（VPATH和vpath）" class="headerlink" title="makefile目标文件搜索（VPATH和vpath）"></a>makefile目标文件搜索（VPATH和vpath）</h3><ul><li><p>VAPTH和vpath区别：VPATH是环境变量，使用时需要指定文件的路径；vpath是关键字，按照模式搜索，也可以说是选择搜索。搜索时不仅需要加上文件的路径，还需要加上相应的限制条件。</p></li><li><p>VAPTH的使用 -&gt; 检索路径下的所有文件</p></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VPATH := src <span class="comment">#把src的值赋值给变量VPATH</span></span><br></pre></td></tr></table></figure><p>存在多个路径，使用<strong>空格或冒号分隔</strong>开，搜索顺序为书写顺序</p><ul><li>vpath的使用（选择性搜索）-&gt; 文件数量大时可以提高搜索效率</li></ul><p>VPATH 是搜索路径下所有的文件，而 vpath 更像是添加了限制条件，会过滤出一部分再去寻找。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vpath</span> PATTERN DIRECTORIES <span class="comment"># PATTERN：要寻找的条件 DIRECTORIES：寻找的路径</span></span><br><span class="line"><span class="keyword">vpath</span> PATTERN <span class="comment"># 可以使用通配符% e.g. "%.c"搜索所有的.c文件</span></span><br><span class="line"><span class="keyword">vpath</span></span><br></pre></td></tr></table></figure><ol><li>vpath PATTERN DIRECTORIES<br>为所有符合模式“PATTERN”的文件指定搜索目录“DIRECTORIES” 。多个目录使用空格或者冒号（：）分开。</li><li>vpath PATTERN<br>清除之前为符合模式“PATTERN”的文件设置的搜索路径。</li><li>vpath<br>清除所有已被设置的文件搜索路径。</li></ol><h3 id="makefile隐含规则"><a href="#makefile隐含规则" class="headerlink" title="makefile隐含规则"></a>makefile隐含规则</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test:test.o</span></span><br><span class="line">gcc -o test test.o</span><br><span class="line"><span class="section">test.o:test.c</span></span><br></pre></td></tr></table></figure><blockquote><p>隐含条件只能省略中间目标文件重建的命令和规则，最终目标的命令和规则不能省略</p></blockquote><p>工作流程：make执行过程中找到隐含规则，提供了此目标的基本依赖关系。确定目标的依赖文件和重建目标需要使用的命令行。隐含规则所提供的依赖文件只是一个基本的。当需要<strong>增加</strong>这个文件的依赖文件的时候要在 Makefile 中使用<strong>没有命令行的规则</strong>给出。</p><h3 id="makefile条件判断"><a href="#makefile条件判断" class="headerlink" title="makefile条件判断"></a>makefile条件判断</h3><p>条件语句可以根据一个变量的值来控制make执行或者忽略makefile的特定部分，条件语句可以是两个不同的变量或者是常量和变量之间的比较。</p><blockquote><p>条件语句只能用于控制make实际执行的makefile部分，不能控制规则的shell命令执行的过程</p></blockquote><table><thead><tr><th>关键字</th><th>功能</th></tr></thead><tbody><tr><td>ifeq</td><td>判断参数是否相等，相等为 true，不相等为 false。</td></tr><tr><td>ifneq</td><td>判断参数是否不相等，不相等为 true，相等为 false。</td></tr><tr><td>ifdef</td><td>判断是否有值，有值为 true，没有值为 false。</td></tr><tr><td>ifndef</td><td>判断是否有值，没有值为 true，有值为 false。</td></tr></tbody></table><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (VAL1,VAL2)<span class="comment"># 或者 ifeq 'VAL1' 'VAL2'</span></span><br><span class="line"><span class="keyword">ifdef</span> VARIABLE-NAME</span><br></pre></td></tr></table></figure><h3 id="makefile伪目标"><a href="#makefile伪目标" class="headerlink" title="makefile伪目标"></a>makefile伪目标</h3><p>伪目标不会创建目标文件，只是想执行这个目标下面的命令。</p><ul><li>使用伪目标的原因<ul><li>避免makefile中定义的只执行的命令和工作目录下实际文件出现名字冲突</li><li>提高执行make的效率</li></ul></li></ul><ol><li>将一个目标声明为伪目标的方法是将它作为特殊的目标<code>.PHONY</code>的依赖</li></ol><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf *.o test</span><br></pre></td></tr></table></figure><ol start="2"><li>make在并行和递归执行的过程中，存在一个变量定义为所有需要make的子目录。</li></ol><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SUBDIRS = foo bar baz</span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:subdirs $(SUBDIRS)</span></span><br><span class="line"><span class="section">subdirs:<span class="variable">$(SUBDIRS)</span></span></span><br><span class="line"><span class="variable">$(SUBDIRS)</span>:</span><br><span class="line"><span class="variable">$(MAKE)</span> -C <span class="variable">$@</span></span><br><span class="line"><span class="section">foo:baz #规定三个子目录的编译顺序，baz比foo先执行，最后执行bar</span></span><br></pre></td></tr></table></figure><ul><li>伪目标实现多文件编译</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:all</span></span><br><span class="line"><span class="section">all:test1 test2  test3</span></span><br><span class="line"><span class="section">test1:test1.o</span></span><br><span class="line">gcc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"><span class="section">test2:test2.o</span></span><br><span class="line">gcc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"><span class="section">test3:test3.o</span></span><br><span class="line">gcc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure><h3 id="makefile常用字符串处理函数"><a href="#makefile常用字符串处理函数" class="headerlink" title="makefile常用字符串处理函数"></a>makefile常用字符串处理函数</h3><p>函数的语法结构</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&lt;function&gt; &lt;arguments&gt;)  <span class="comment"># or $&#123;&lt;function&gt; &lt;arguments&gt;&#125;</span></span><br></pre></td></tr></table></figure><p>其中，function是函数名，arguments是函数的参数，参数之间要用逗号分隔开，而函数名和参数之间用空格分开。调用函数的时候要使用字符<code>$</code>，后面跟小括号或者花括号。</p><ul><li>模式字符串替换函数</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure><p>查找text中的单词是否符合模式pattern，如果匹配的话，则用replacement替换。返回值为替换后的新字符串。 </p><ul><li>字符串替换函数</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> &lt;form&gt;,&lt;to&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure><p>将字符串中的form替换成to，返回值为替换后的新字符串。</p><ul><li>去空格函数</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">strip</span> &lt;string&gt;)</span></span><br></pre></td></tr></table></figure><p>去掉字符串开后和结尾的空格，并将字符中间的多个连续的空格合并成为一个空格，返回值为去掉空格的字符串。</p><ul><li>查找字符串函数</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">findstring</span> &lt;find&gt;,&lt;in&gt;)</span></span><br></pre></td></tr></table></figure><p>查找in中的find，如果我们的目标字符串存在。返回值为目标字符串，如果不存在就返回空值。</p><ul><li>过滤函数</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span> &lt;pattern&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure><p>过滤出text中符合模式pattern的字符串，可以有多个pattern。返回值为过滤后的字符串。</p><ul><li>反过滤函数</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span>-out &lt;pattern&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure><ul><li>排序函数</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">sort</span> &lt;list&gt;)</span></span><br></pre></td></tr></table></figure><p>将list中的单词排序（升序）。返回值为排序后的字符串。</p><blockquote><p>sort会去除重复的字符串</p></blockquote><ul><li>取单词函数</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">word</span> &lt;n&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure><p>取出text中的第n个单词。</p><h3 id="makefile常用文件名操作函数"><a href="#makefile常用文件名操作函数" class="headerlink" title="makefile常用文件名操作函数"></a>makefile常用文件名操作函数</h3><blockquote><p>下面每个函数的参数字符串都会被当作是一个系列的文件名来看待</p></blockquote><ul><li>取目录函数</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">dir</span> &lt;names&gt;)</span></span><br></pre></td></tr></table></figure><p>从文件名序列names中取出目录部分，如果names中没有<code>/</code>，取出的值为<code>./</code>。返回值为目录部分，指的是最后一个反斜杠之前的部分。</p><ul><li>取文件函数名</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">notdir</span> &lt;names)</span></span><br></pre></td></tr></table></figure><p>从文件名序列names中取出非目录部分。</p><ul><li>取后缀名函数</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">suffix</span> &lt;names&gt;)</span></span><br></pre></td></tr></table></figure><p>从文件名序列names中取出各个问价的后缀名。返回值为后缀序列，如果没有后缀名，返回空字符串。</p><ul><li>取前缀函数</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">basename</span> &lt;names&gt;)</span></span><br></pre></td></tr></table></figure><p>获取的是文件的前缀名，包含文件路径的部分。</p><ul><li>添加后缀名函数</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addsuffix</span> &lt;<span class="built_in">suffix</span>&gt;,&lt;names&gt;)</span></span><br></pre></td></tr></table></figure><ul><li>添加前缀名函数</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addprefix</span> &lt;prefix&gt;,&lt;names&gt;)</span></span><br></pre></td></tr></table></figure><p>可以使用这个函数给文件添加路径</p><ul><li>链接函数</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">join</span> &lt;list1&gt;,&lt;list2&gt;)</span></span><br></pre></td></tr></table></figure><p>把list2中的单词对应地拼接到list1的后面。如果list1的单词比list2多，那么list1中多出来的单词将保持原样；如果list1中的单词比list2的少，那么list2中多出来的单词将保持原样。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OBJ = <span class="variable">$(<span class="built_in">join</span> src car,abc zxc qwe)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">@echo <span class="variable">$(OBJ)</span></span><br></pre></td></tr></table></figure><p>结果输出为srcabc carzxc qwe</p><ul><li>获取匹配模式文件函数名</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> PATTERN)</span></span><br></pre></td></tr></table></figure><p>列出当前目录下的所有符合模式的PATTERN格式的文件名。返回值为空格分隔并且存在当前目录下的所有符合模式PATTERN的文件名。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OBJ = $(*.c *.h)<span class="comment"># 这里可以不适用wildcard函数 因为echo属于shell函数，通配符会自动展开，注意这里不是规则，是执行语句</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">@echo <span class="variable">$(OBJ)</span></span><br></pre></td></tr></table></figure><h3 id="makefile中其他常用函数"><a href="#makefile中其他常用函数" class="headerlink" title="makefile中其他常用函数"></a>makefile中其他常用函数</h3><ul><li>foreach</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">foreach</span> &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure><p>把参数<code>&lt;list&gt;</code>中的单词逐一取出放到参数<code>&lt;var&gt;</code>所指定的变量中，然后再执行<code>&lt;text&gt;</code>所包含的表达式。每一次<code>&lt;text&gt;</code>会返回一个字符串，循环过程中，<code>&lt;text&gt;</code>所返回的每个字符串会以空格分割，最后当整个循环结束的时候，<code>&lt;text&gt;</code>所返回的每个字符串所组成的整个字符串（以空格分隔）将会是 foreach 函数的返回值。所以<code>&lt;var&gt;</code>最好是一个变量名，<code>&lt;list&gt;</code>可以是一个表达式，而<code>&lt;text&gt;</code>中一般会只用<code>&lt;var&gt;</code>这个参数来一次枚举<code>&lt;list&gt;</code>中的单词。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name := a b c d</span><br><span class="line">files := <span class="variable">$(<span class="built_in">foreach</span> val, <span class="variable">$(names)</span>, <span class="variable">$(val)</span>.o)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">@echo <span class="variable">$(files)</span></span><br></pre></td></tr></table></figure><p>输出为<code>a.o b.o c.o d.o</code></p><blockquote><p>foreah中的var是局部变量，作用域只在函数内</p></blockquote><ul><li>if</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">if</span> &lt;condition&gt;,&lt;then-part&gt;)</span> <span class="comment"># or $(if &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;)</span></span><br></pre></td></tr></table></figure><ul><li>call</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">call</span> &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;,...)</span></span><br></pre></td></tr></table></figure><p>call函数是唯一一个可以用来创建新的参数化的函数，可以用来写一个非常复杂的表达式，用call来向这个表达式传递参数。当 make 执行这个函数的时候，<code>expression</code>参数中的变量\$(1)、\$(2)、\$(3)等，会被参数<code>parm1</code>，<code>parm2</code>，<code>parm3</code>依次取代。而<code>expression</code>的返回值就是 call 函数的返回值。</p><ul><li>origin</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">origin</span> &lt;variable&gt;)</span></span><br></pre></td></tr></table></figure><p>origin函数告诉你变量从哪里来</p><p>下面是origin函数返回值：</p><ul><li><p>“undefined”：如果<code>&lt;variable&gt;</code>从来没有定义过，函数将返回这个值。</p></li><li><p>“default”：如果<code>&lt;variable&gt;</code>是一个默认的定义，比如说“CC”这个变量。</p></li><li>“environment”：如果<code>&lt;variable&gt;</code>是一个环境变量并且当Makefile被执行的时候，“-e”参数没有被打开。</li><li>“file”：如果<code>&lt;variable&gt;</code>这个变量被定义在Makefile中，将会返回这个值。</li><li>“command line”：如果<code>&lt;variable&gt;</code>这个变量是被命令执行的，将会被返回。</li><li>“override”：如果<code>&lt;variable&gt;</code>是被override指示符重新定义的。</li><li>“automatic”：如果<code>&lt;variable&gt;</code>是一个命令运行中的自动化变量。</li></ul><h3 id="makefile命令的编写"><a href="#makefile命令的编写" class="headerlink" title="makefile命令的编写"></a>makefile命令的编写</h3><ul><li><p>命令回显</p><p>通常make在执行命令行之前会把要执行的命令行输出到标准输出设备，我们称之为“回显”。如果规则的命令行以字符<code>@</code>开始，则make在执行的时候不会显示这个将要被执行的命令。</p><p>我们在执行 make 时添加上一些参数，可以控制命令行是否输出。</p><p>当使用 make 的时候加上参数<code>-n</code>或者是<code>--just-print</code> ，执行时只显示所要执行的命令，但不会真正的执行这个命令。只有在这种情况下 make 才会打印出所有的 make 需要执行的命令，其中包括了使用的“@”字符开始的命令。</p><p>而 make 参数<code>-s</code>或者是<code>--slient</code>则是禁止所有的执行命令的显示。就好像所有的命令行都使用“@”开始一样。</p></li><li><p>命令执行</p><p>当规则中的目标需要被重建的时候，此规则所定义的命令将会被执行，如果是多行的命令，那么每一行命令将是在一个独立的子 shell 进程中被执行。因此，多命令行之间的执行命令时是相互独立的，相互之间不存在往来。</p><p>在 Makefile 中书写在同一行中的多个命令（用<code>;</code>分隔开）属于一个完整的 shell 命令行，书写在独立行的一条命令是一个独立的 shell 命令行。使用反斜杠<code>\</code>来对处于多行的命令进行连接，表示他们是一个完整的shell命令行。</p></li><li><p>并发执行命令</p><p>通过 make 命令行选项 “-j” 或者 “–jobs” 来告诉 make 在同一时刻可以允许多条命令同时执行。如果选项 “-j” 之后存在一个整数，其含义是告诉 make 在同一时刻可以允许同时执行的命令行的数目。这个数字被称为<code>job slots</code>。当 “-j” 选项中没有出现数字的时候，那么同一时间执行的命令数目没有要求。使用默认的<code>job solts</code>，值为1，表示make将串行的执行规则的命令（同一时刻只能由一条命令被执行）。</p></li></ul><h3 id="makefile-include文件包含"><a href="#makefile-include文件包含" class="headerlink" title="makefile include文件包含"></a>makefile include文件包含</h3><p>当make读取到“lnclude”关键字的时候，会暂停读物当前的makefile，而是去读“include”包含的文件，读取结束后再继续读取当前的makefile文件。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> &lt;filenames&gt;</span><br></pre></td></tr></table></figure><p>include使用场景</p><ul><li>将共同使用的变量或者模式规则定义在一个文件中，需要的时候用 “include” 包含这个文件。</li><li>当根据源文件自动产生依赖文件时，我们可以将自动产生的依赖关系保存在另一个文件中。然后在 Makefile 中包含这个文件。</li></ul><blockquote><p>如果使用 “include” 包含文件的时候，指定的文件不是文件的绝对路径或者是为当前文件下没有这个文件，make 会根据文件名会在以下几个路径中去找，首先我们在执行 make 命令的时候可以加入选项 “-I” 或 “–include-dir” 后面添加上指定的路径，如果文件存在就会被使用，如果文件不存在将会在其他的几个路径中搜索： “usr/gnu/include”、”usr/local/include” 和 “usr/include”。</p></blockquote><p>如果在上面的路径没有找到 “include” 指定的文件，make 将会提示一个文件没有找到的警示提示，但是不会退出，而是继续执行 Makefile 的后续的内容。当完成读取整个 Makefile 后，make 将试图使用规则来创建通过 “include” 指定但不存在的文件。当不能创建的时候，文件将会提示致命错误并退出。</p><p>使用时，通常用 “-include” 来代替 “include” 来忽略文件不存在或者是无法创建的错误提示</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-include</span> &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>这种情况下，只有在不能正确完成终极目标的重建时，才会提示错误并退出。</p><p>为了和其它的make程序进行兼容。也可以使用“sinclude”来代替“-include”（GNU所支持的方式）。</p><h3 id="makefile的嵌套执行make"><a href="#makefile的嵌套执行make" class="headerlink" title="makefile的嵌套执行make"></a>makefile的嵌套执行make</h3><p>不同模块有自己的makefile文件，我们只需要控制其他模块中的makefile就可以实现总体的控制。</p><p>我们把最外层的 Makefile 称为是总控 Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">cd subdir &amp;&amp; <span class="variable">$(MAKE)</span></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"><span class="section">subsystem:</span></span><br><span class="line"><span class="variable">$(MAKE)</span> -C subdir</span><br></pre></td></tr></table></figure><p>变量“CURDIR”，代表make的工作目录。当使用make的选项 -C 的时候，命令会进入指定的目录中，这时该变量会被重新赋值为指定目录。</p><ul><li>export的使用</li></ul><p>如果需要变量的传递（到下一层make），可以使用下列语句</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &lt;variable&gt;</span><br></pre></td></tr></table></figure><p>不需要使用“$“字符。如果所有变量都需要传递，那么只需要使用”export“即可</p><p>Makefile中有两个变量不需使用关键字”export“声明，他们总会传递到下层的Makefile中，分别是 SHELL 和 MAKEFLAGS。其中MAKEFLAGS包含了make的参数信息，这是一个系统级别的环境变量。</p><p>make命令中有几个参数选项并不传递，它们是：”-C”、”-f”、”-o”、”-h” 和 “-W”。如果我们不想传递 MAKEFLAGS 变量的值，在 Makefile 中可以这样来写：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">cd subdir &amp;&amp; <span class="variable">$(MAKE)</span> MAKEFLAGS=</span><br></pre></td></tr></table></figure><ul><li>嵌套执行make</li></ul><p><strong>要提供正确的依赖关系</strong></p><p>当 make 发觉它正在递归调用另一个 make 时，他会启 用–print-directory(-w) 选项，这会使得 make 输出 Entering directory(进入目录) 和 Leaving directory(离开目录) 的信息。当 –directory(-C) 选项被使用时，也会启用这个选项。我们还可以看到每一行中，MAKELEVEL 这个 make 变量的值加上方括号之后被一起输出。</p><h3 id="makefile变量的高级用法"><a href="#makefile变量的高级用法" class="headerlink" title="makefile变量的高级用法"></a>makefile变量的高级用法</h3><ul><li>替换引用</li></ul><p>字符串后缀名的替换（同patsubst函数）</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo:=a.c b.c d.c</span><br><span class="line">obj:=$(foo:.c=.o) <span class="comment"># 变量名的后面要使用冒号和参数选项分开，表达式中间不能使用空格</span></span><br><span class="line"><span class="comment"># 更通用的写法</span></span><br><span class="line">obj:=$(foo:%.c:%.o) <span class="comment"># e.g. $(foo:a%c:x%y)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">@echo <span class="variable">$(obj)</span></span><br></pre></td></tr></table></figure><ul><li>嵌套引用</li></ul><p>在一个变量的赋值中引用其他的变量（避免使用-别人可能看不懂）</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">first_pass=hello</span><br><span class="line">bar=first</span><br><span class="line">var:=<span class="variable">$(bar)</span>_pass</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">@echo <span class="variable">$(var)</span> <span class="comment"># 输出结果是hello</span></span><br></pre></td></tr></table></figure><h3 id="makefile控制函数error和warning"><a href="#makefile控制函数error和warning" class="headerlink" title="makefile控制函数error和warning"></a>makefile控制函数error和warning</h3><p>当make执行过程中检测到某些错误时为用户提供消息，并可以控制make执行过程是否继续</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">error</span> TEXT...)</span></span><br></pre></td></tr></table></figure><p>函数说明如下：</p><ul><li>函数功能：产生致命错误，并提示 “TEXT…” 信息给用户，并退出 make 的执行。需要说明的是：”error” 函数是在函数展开时（函数被调用时）才提示信息并结束 make 进程。因此如果函数出现在命令中或者一个递归的变量定义时，读取 Makefile 时不会出现错误。而只有包含 “error” 函数引用的命令被执行，或者定义中引用此函数的递归变量被展开时，才会提示知名信息 “TEXT…” 同时退出 make。</li><li>返回值：空</li><li>函数说明：”error” 函数一般不出现在直接展开式的变量定义中，否则在 make 读取 Makefile 时将会提示致命错误。</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">warning</span> TEXT...)</span></span><br></pre></td></tr></table></figure><p>函数说明如下：</p><ul><li>函数功能：函数 “warning” 类似于函数 “error” ，区别在于它不会导致致命错误（make不退出），而只是提示 “TEXT…”，make 的执行过程继续。</li><li>返回值：空</li><li>函数说明：用法和 “error” 类似，展开过程相同。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;Makefile-learning&quot;&gt;&lt;a href=&quot;#Makefile-learning&quot; class=&quot;headerlink&quot; title=&quot;Makefile_learning&quot;&gt;&lt;/a&gt;Makefile_learning&lt;/h2&gt;</summary>
      
    
    
    
    
    <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Cpp learning note</title>
    <link href="http://yoursite.com/2020/12/19/Cpp-learning-note/"/>
    <id>http://yoursite.com/2020/12/19/Cpp-learning-note/</id>
    <published>2020-12-19T09:37:52.000Z</published>
    <updated>2020-12-20T03:24:45.453Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为项目而学习C++</p><p>学习资源：<a href="https://www.icourse163.org/course/NWPU-494001?tid=1450728827" target="_blank" rel="noopener">西北工业大学 C++程序设计</a>、<a href="https://www.icourse163.org/course/QDU-1458424165" target="_blank" rel="noopener">青岛大学 面向对象程序设计（C++和Java）</a></p><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>C++允许在函数定义或声明时，为形参指定默认值，这样的参数称为默认参数。</p><p>（1）如果在函数定义时设置了默认参数，那么就不能在函数声明中再次设置，反之亦然。</p><p>（2）可以设置多个默认参数，设置的顺序自右向左，即要设置默认值的参数右边的所有参数都必须是默认参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">volume</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> W, <span class="keyword">int</span> H = <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">volume</span><span class="params">(<span class="keyword">int</span> L = <span class="number">1</span>, <span class="keyword">int</span> W = <span class="number">1</span>, <span class="keyword">int</span> H = <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="comment">//上面都是正确的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">volume</span><span class="params">(<span class="keyword">int</span> L = <span class="number">1</span>, <span class="keyword">int</span> W, <span class="keyword">int</span> H)</span></span>;<span class="comment">//错误</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">volume</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> W = <span class="number">1</span>; <span class="keyword">int</span> H)</span></span>;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure><p>（3）默认值可以是常量、全局变量和函数调用（调用实参必须是常量或全局变量的表达式，不可以是局部变量）</p><a id="more"></a><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>function overloading是在同一个域中用同一个函数名来定义多个函数，但是函数参数列表彼此不同（个数不同或参数类型不同）</p><ul><li>编译程序将根据实参和形参的类型和个数的最佳匹配来选择调用哪一个函数</li></ul><h3 id="数组作为函数的参数"><a href="#数组作为函数的参数" class="headerlink" title="数组作为函数的参数"></a>数组作为函数的参数</h3><p>如果实参使用数组名，本质上是将这个数组的首地址传递到形参中。数组实参a传递的是数组首地址，形参A定义为数组形式，此时A 的地址与a一样，本质上形参数组A就是实参数组a（内存中两个对象所处位置相同，则实际上它们是同一个对象）</p><blockquote><p>和指针类似，指针传递的也是地址，这样做可以直接改变多个数组元素，而不用返回</p></blockquote><h3 id="数组参数的传递机制"><a href="#数组参数的传递机制" class="headerlink" title="数组参数的传递机制"></a>数组参数的传递机制</h3><ul><li>数组作为函数的参数，传递的是数组的地址（数组在内存中是一段区域内连续的）</li></ul><p>（1）在被调函数中使用形参就是间接使用实参（与变量不同）</p><p>（2）函数调用时不会为形参数组分配存储空间，即形参数组的长度无实际作用，所以形参数组甚至可不给出长度</p><p>（3）函数如何知道数组的长度-&gt;函数调用时再给出一个参数来表示实参数组的长度</p><p>（4）多维数组作为函数的参数，形参数组除第一维任意，其他维的长度需要与实参数组相同</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>C++语言规定字符串是以’\0’字符作为结束符的<strong>字符数组</strong>，空字符表示字符串的结束位置</p><p>定义字符数组的长度至少为字符串长度加1（空字符占1位）</p><p>C++在编译时自动在字符串常量后增加一个空字符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++中兼容C语言的字符串处理函数的头文件string.h</span></span><br><span class="line"><span class="built_in">strcpy</span>(str1, str2);<span class="comment">//copy</span></span><br><span class="line"><span class="built_in">strncpy</span>(str1, str2, n);<span class="comment">//copy前n个</span></span><br><span class="line"><span class="built_in">strcat</span>(str1, str2);<span class="comment">//连接</span></span><br><span class="line"><span class="built_in">strncat</span>(str1, str2, n);<span class="comment">//连接前n个</span></span><br><span class="line"><span class="built_in">strcmp</span>(str1, str2);<span class="comment">//比较字符串</span></span><br><span class="line"><span class="built_in">strlen</span>(str);<span class="comment">//length</span></span><br><span class="line">atof(<span class="string">"123.456"</span>);</span><br><span class="line">atoi(<span class="string">"-456"</span>);<span class="comment">//string转换成数值函数</span></span><br></pre></td></tr></table></figure><h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><p>采用类来实现字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> S1[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">string</span> str1;</span><br><span class="line"><span class="keyword">char</span> S2[<span class="number">20</span>] = <span class="string">"Java"</span>;<span class="comment">//C风格字符串初始化</span></span><br><span class="line"><span class="built_in">string</span> str2 = <span class="string">"Java"</span>;<span class="comment">//string对象copy初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str3</span><span class="params">(<span class="string">"Java"</span>)</span></span>;<span class="comment">//string对象直接初始化</span></span><br></pre></td></tr></table></figure><p>string对象允许使用+和复合运算符+=实现连接，可以调用其他<strong>成员函数</strong>来实现字符串处理（与java中的method相同）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近因为项目而学习C++&lt;/p&gt;
&lt;p&gt;学习资源：&lt;a href=&quot;https://www.icourse163.org/course/NWPU-494001?tid=1450728827&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;西北工业大学 C++程序设计&lt;/a&gt;、&lt;a href=&quot;https://www.icourse163.org/course/QDU-1458424165&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;青岛大学 面向对象程序设计（C++和Java）&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;默认参数&quot;&gt;&lt;a href=&quot;#默认参数&quot; class=&quot;headerlink&quot; title=&quot;默认参数&quot;&gt;&lt;/a&gt;默认参数&lt;/h3&gt;&lt;p&gt;C++允许在函数定义或声明时，为形参指定默认值，这样的参数称为默认参数。&lt;/p&gt;
&lt;p&gt;（1）如果在函数定义时设置了默认参数，那么就不能在函数声明中再次设置，反之亦然。&lt;/p&gt;
&lt;p&gt;（2）可以设置多个默认参数，设置的顺序自右向左，即要设置默认值的参数右边的所有参数都必须是默认参数。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;volume&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; L, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; W, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; H = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;volume&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; L = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; W = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; H = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//上面都是正确的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;volume&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; L = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; W, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; H)&lt;/span&gt;&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//错误&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;volume&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; L, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; W = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; H)&lt;/span&gt;&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//错误&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（3）默认值可以是常量、全局变量和函数调用（调用实参必须是常量或全局变量的表达式，不可以是局部变量）&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>summary_about_the_half_year</title>
    <link href="http://yoursite.com/2020/12/05/summary-about-the-half-year/"/>
    <id>http://yoursite.com/2020/12/05/summary-about-the-half-year/</id>
    <published>2020-12-05T13:40:35.000Z</published>
    <updated>2021-03-10T06:27:46.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="20201205-小记"><a href="#20201205-小记" class="headerlink" title="20201205-小记"></a>20201205-小记</h1><p>不知不觉研一开学有三个月了，自暑假之后再也没碰过blog，总觉得买域名的钱花的有点不值，换电脑后折腾了两个小时把原来的博客都搬到新电脑上面，换了个主题心情大好~。</p><p>三个月其实也没有做什么东西，一直在上课和划水。</p><p>RTS：李老师的课听得一脸懵…整个人都不太好，还好有万能的同学们一起讨论。也还好它结课了，整个人都轻松了hhh札记可太难了=_=</p><p>近期的小目标是学会C++的基本使用和做项目，当然还有考试和作业。</p><p>写的好水啊…没有任何干货（这篇后面会删掉吧hhh</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;20201205-小记&quot;&gt;&lt;a href=&quot;#20201205-小记&quot; class=&quot;headerlink&quot; title=&quot;20201205-小记&quot;&gt;&lt;/a&gt;20201205-小记&lt;/h1&gt;&lt;p&gt;不知不觉研一开学有三个月了，自暑假之后再也没碰过blog，总觉得买域</summary>
      
    
    
    
    
    <category term="about_life" scheme="http://yoursite.com/tags/about-life/"/>
    
  </entry>
  
  <entry>
    <title>bash</title>
    <link href="http://yoursite.com/2020/08/16/bash%20notes/"/>
    <id>http://yoursite.com/2020/08/16/bash%20notes/</id>
    <published>2020-08-15T16:00:00.000Z</published>
    <updated>2020-08-16T13:47:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="bash-notes"><a href="#bash-notes" class="headerlink" title="bash notes"></a>bash notes</h1><blockquote><p>reference: <a href="https://wangdoc.com/bash/" target="_blank" rel="noopener">https://wangdoc.com/bash/</a></p></blockquote><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p><strong>pwd</strong> – 显示当前目录</p><p><strong>echo</strong> 多行加“ ” 输出文本末尾有回车符</p><ol><li>-n参数 取消末尾的回车符</li><li>-e参数 解释单双引号中的特殊字符(e.g. \n)</li></ol><p><strong>type</strong> 判断命令的来源</p><ol><li>-a参数 查看命令的所有定义</li><li>-t参数 返回一个命令的类型：别名（alias），关键词（keyword），函数（function），内置命令（builtin）和文件（file）</li></ol><p>快捷键：</p><ul><li><code>Ctrl + L</code>：清除屏幕并将当前行移到页面顶部</li><li><code>Ctrl + C</code>：中止当前正在执行的命令</li><li><code>Shift + PageUp</code>：向上滚动</li><li><code>Shift + PageDown</code>：向下滚动</li><li><code>Ctrl + U</code>：从光标位置删除到行首</li><li><code>Ctrl + K</code>：从光标位置删除到行尾</li><li><code>Ctrl + D</code>：关闭 Shell 会话</li><li><code>↑</code>，<code>↓</code>：浏览已执行命令的历史记录</li></ul><h2 id="模式扩展-gt-简单的正则"><a href="#模式扩展-gt-简单的正则" class="headerlink" title="模式扩展-&gt;简单的正则"></a>模式扩展-&gt;简单的正则</h2><blockquote><p>shell接收命令，根据空格拆分为一个个词元，然后扩展词元里的特殊字符。</p></blockquote><p>set -f 开启        set +f 关闭</p><ol><li>波浪号 自动扩展成当前用户的主目录 ~+ equal to pwsd</li><li>问号 代表文件路径中的任意单个字符，不包含空字符</li><li>星号 代表文件路径中任意数量的任意字符，包括零个字符，但是不会匹配隐藏文件，如果需要匹配隐藏文件需要写成<code>.*</code></li><li><code>[...]</code> 匹配方括号中的任意一个字符 <code>[!...] or [^...]</code>是非的表达 匹配连字符- 只能放在方括号内部首尾位置</li><li><code>[start-end]</code> </li><li><code>{...}</code> 扩展成大括号里的所有值，各个值之间用逗号分隔，逗号前后不能有空格</li><li><code>{start..end}</code> 大括号扩展的简写形式，支持逆序 <code>{start..end..step}</code>中step为步长</li><li>变量扩展 e.g. ${SHELL}</li><li>子命令扩展 $(…) 可以扩展为另一个命令的运行结果</li><li>算数扩展$((…))</li><li>字符类</li></ol><ul><li><code>[[:alnum:]]</code>：匹配任意英文字母与数字</li><li><code>[[:alpha:]]</code>：匹配任意英文字母</li><li><code>[[:blank:]]</code>：空格和 Tab 键</li><li><code>[[:cntrl:]]</code>：ASCII 码 0-31 的不可打印字符</li><li><code>[[:digit:]]</code>：匹配任意数字 0-9</li><li><code>[[:graph:]]</code>：A-Z、a-z、0-9 和标点符号</li><li><code>[[:lower:]]</code>：匹配任意小写字母 a-z</li><li><code>[[:print:]]</code>：ASCII 码 32-127 的可打印字符</li><li><code>[[:punct:]]</code>：标点符号（除了 A-Z、a-z、0-9 的可打印字符）</li><li><code>[[:space:]]</code>：空格、Tab、LF（10）、VT（11）、FF（12）、CR（13）</li><li><code>[[:upper:]]</code>：匹配任意大写字母 A-Z</li><li><code>[[:xdigit:]]</code>：16进制字符（A-F、a-f、0-9）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;bash-notes&quot;&gt;&lt;a href=&quot;#bash-notes&quot; class=&quot;headerlink&quot; title=&quot;bash notes&quot;&gt;&lt;/a&gt;bash notes&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;reference: &lt;a href=&quot;https</summary>
      
    
    
    
    
    <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>YOLOv4</title>
    <link href="http://yoursite.com/2020/04/27/YOLOv4%20-%20note/"/>
    <id>http://yoursite.com/2020/04/27/YOLOv4%20-%20note/</id>
    <published>2020-04-27T08:03:05.000Z</published>
    <updated>2020-04-28T10:51:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="YOLOv4-note"><a href="#YOLOv4-note" class="headerlink" title="YOLOv4 - note"></a>YOLOv4 - note</h1><blockquote><p>arxiv.org/abs/2004.10934 -&gt; translation: <a href="https://tongtianta.site/paper/89863" target="_blank" rel="noopener">https://tongtianta.site/paper/89863</a></p></blockquote><p>提高accuracy的通用功能：加权残差链接（WRC）、跨阶段部分连接（CSP）、跨小批量标准化（CmBN）、自对抗训练（SAT）、Mish-activation。</p><p>本文结合WRC、CSP、CmBN、SAT、Mish-activation、镶嵌数据增强（augmentation mosaic）、DropBlock regularization、CIoU loss</p><p><img src="https://raw.githubusercontent.com/su-loch/pics/master/img/yolov4.png" alt></p><h2 id="bags-of-freebies"><a href="#bags-of-freebies" class="headerlink" title="bags of freebies"></a>bags of freebies</h2><p>数据增强：</p><ul><li>photomatric distortion-&gt; 调整图像亮度，对比度，色相，饱和度和噪点</li><li>geometric distortion -&gt; 随机缩放，裁剪，翻转和旋转</li></ul><p>模拟对象遮挡：</p><ul><li>random erase、CutOut -&gt; 随机选择图像中的矩形区域填充为0的随机或互补值</li><li>hide-and-seek、grid mask -&gt; 随机或均匀地选择图像中的多个矩形区域替换为全0</li></ul><p>类似概念应用于feature map有：DropOut、DropConnect、<strong>DropBlock</strong></p><p>DIoU考虑了对象中心的距离、CIoU同时考虑了重叠区域 -&gt; 更好的收敛速度和准确性</p><h2 id="bags-of-specials"><a href="#bags-of-specials" class="headerlink" title="bags of specials"></a>bags of specials</h2><p>plugin modules：</p><ul><li>增强接收域：SPP、ASPP、RFB</li><li>引入注意力机制（channel-wise、point-wise）：Squeeze-and-Excitation(SE)、Spatial Attention Module(<strong>SAM</strong>)</li><li>集成特征：SFAM、ASFF、BiFPN</li><li>激活函数：LReLU、<del>PReLU</del>、<del>ReLU6</del>、<del>SELU</del>、Swish、hard-Swish、Mish</li></ul><p>post-processing：DIoU NMS</p><h2 id="架构选择"><a href="#架构选择" class="headerlink" title="架构选择"></a>架构选择</h2><p><strong>CSPDarknet53</strong>、CSPResNext50</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;YOLOv4-note&quot;&gt;&lt;a href=&quot;#YOLOv4-note&quot; class=&quot;headerlink&quot; title=&quot;YOLOv4 - note&quot;&gt;&lt;/a&gt;YOLOv4 - note&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;arxiv.org/abs/200</summary>
      
    
    
    
    
    <category term="毕业设计" scheme="http://yoursite.com/tags/毕业设计/"/>
    
  </entry>
  
  <entry>
    <title>tf2.0</title>
    <link href="http://yoursite.com/2020/04/05/tf2-0/"/>
    <id>http://yoursite.com/2020/04/05/tf2-0/</id>
    <published>2020-04-05T02:48:29.000Z</published>
    <updated>2020-04-09T10:00:52.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>练习代码 <a href="https:github.com/su-loch/python_exercise" target="_blank" rel="noopener">pex</a> 基于tensorflow2.0</p></blockquote><h3 id="tensorflow-vs-pytorch"><a href="#tensorflow-vs-pytorch" class="headerlink" title="tensorflow_vs_pytorch"></a>tensorflow_vs_pytorch</h3><p>tf1.* 静态图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">print(tf.__version__)<span class="comment"># 1.9.0</span></span><br><span class="line"></span><br><span class="line">x = tf.Variable(<span class="number">0.</span>)</span><br><span class="line">y = tf.Variable(<span class="number">1.</span>)</span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># 构建计算图</span></span><br><span class="line"><span class="comment"># x = x + y</span></span><br><span class="line">add_op = x.assign(x +y)</span><br><span class="line"><span class="comment"># y = y / 2</span></span><br><span class="line">div_op = y.assign(y / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">        sess.run(add_op)</span><br><span class="line">        sess.run(div_op)</span><br><span class="line">    print(x.eval())</span><br></pre></td></tr></table></figure><p>tf2.* 动态图 -&gt; tf1.x中调用tf.enable_eager_execution()方法打开eager mode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">print(tf.__version__)   <span class="comment"># 2.0.0</span></span><br><span class="line"></span><br><span class="line">x = tf.constant(<span class="number">0.</span>)</span><br><span class="line">y = tf.constant(<span class="number">1.</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">    x = x + y</span><br><span class="line">    y = y / <span class="number">2</span></span><br><span class="line">print(x.numpy())</span><br></pre></td></tr></table></figure><p>PyTorch 动态图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">print(torch.__version__)    <span class="comment"># 1.4.0</span></span><br><span class="line"></span><br><span class="line">x = torch.Tensor([<span class="number">0.</span>])</span><br><span class="line">y = torch.Tensor([<span class="number">1.</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">    x = x + y</span><br><span class="line">    y = y / <span class="number">2</span></span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="分类问题与回归问题"><a href="#分类问题与回归问题" class="headerlink" title="分类问题与回归问题"></a>分类问题与回归问题</h2><ul><li><p>分类问题预测的是类别，模型的输出是概率分布</p></li><li><p>回归问题预测是值，模型的输出是一个实数值</p></li></ul><h3 id="目标函数-↓"><a href="#目标函数-↓" class="headerlink" title="目标函数 ↓"></a>目标函数 ↓</h3><ul><li><strong>分类问题</strong>–衡量目标类别与当前预测的差距</li></ul><p>e.g. 三分类问题，输出：[0.2, 0.7, 0.1] -&gt; 第1类</p><p>真实类别第2类 -&gt; one_hot -&gt; [0, 0, 1]</p><p>one_hot编码，把正整数变为向量表达，生成一个不小于正整数的向量，只有正整数的位置为1，其余位置为0</p><ul><li>分类常用损失函数：平方差损失、交叉熵损失</li><li><strong>回归问题</strong>–预测值与真实值差距</li><li>回归常用损失函数：平方差损失、绝对值损失</li></ul><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>tf.keras.callbacks</p><ul><li>EarlyStopping</li><li>ModelCheckpoint</li><li>TensorBoard</li></ul><p>在命令行中调用tensorboard：tensorboard –logdir=[你的文件夹名称]</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;练习代码 &lt;a href=&quot;https:github.com/su-loch/python_exercise&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pex&lt;/a&gt; 基于tensorflow2.0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;tensorflow-vs-pytorch&quot;&gt;&lt;a href=&quot;#tensorflow-vs-pytorch&quot; class=&quot;headerlink&quot; title=&quot;tensorflow_vs_pytorch&quot;&gt;&lt;/a&gt;tensorflow_vs_pytorch&lt;/h3&gt;&lt;p&gt;tf1.* 静态图&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; tensorflow &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; tf&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(tf.__version__)	&lt;span class=&quot;comment&quot;&gt;# 1.9.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;x = tf.Variable(&lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;y = tf.Variable(&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(x)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 构建计算图&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# x = x + y&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;add_op = x.assign(x +y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# y = y / 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;div_op = y.assign(y / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; tf.Session() &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; sess:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sess.run(tf.global_variables_initializer())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sess.run(add_op)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sess.run(div_op)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(x.eval())&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;tf2.* 动态图 -&amp;gt; tf1.x中调用tf.enable_eager_execution()方法打开eager mode&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; tensorflow &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; tf&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(tf.__version__)   &lt;span class=&quot;comment&quot;&gt;# 2.0.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;x = tf.constant(&lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;y = tf.constant(&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    x = x + y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    y = y / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(x.numpy())&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;PyTorch 动态图&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; torch&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(torch.__version__)    &lt;span class=&quot;comment&quot;&gt;# 1.4.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;x = torch.Tensor([&lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;y = torch.Tensor([&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    x = x + y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    y = y / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(x)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="tensorflow" scheme="http://yoursite.com/tags/tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>YOLOv3</title>
    <link href="http://yoursite.com/2020/04/02/YOLOv3/"/>
    <id>http://yoursite.com/2020/04/02/YOLOv3/</id>
    <published>2020-04-01T17:29:04.000Z</published>
    <updated>2020-04-04T14:36:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://pjreddie.com/media/files/papers/YOLOv3.pdf" target="_blank" rel="noopener">论文地址</a></p><h2 id="YOLOv3结构图"><a href="#YOLOv3结构图" class="headerlink" title="YOLOv3结构图"></a>YOLOv3结构图</h2><p><img src="https://raw.githubusercontent.com/su-loch/pics/master/img/yolo_v3_structure.png" alt></p><ul><li>DBL：卷积 + BN(Batch Normalization) + Leaky relu</li><li>resn：n表示包含的res_unit个数</li><li>concat：张量拼接，拼接会扩充张量的维度</li></ul><h3 id="backbone"><a href="#backbone" class="headerlink" title="backbone"></a>backbone</h3><p>Darknet-53没有设置池化层和全连接层，而通过改变卷积核的步长进行张量的尺寸变换，在yolov3中没有最后的全局平均池化层，所以张量变化只考虑5层。</p><h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><p>y1、y2、y3深度都是255 = 3*（5+80），其中5是bbox的5个参数，80是COCO数据集的类别数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://pjreddie.com/media/files/papers/YOLOv3.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;论文地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;YOLOv3结构图&quot;&gt;&lt;a href=&quot;#YOL</summary>
      
    
    
    
    
    <category term="毕业设计" scheme="http://yoursite.com/tags/毕业设计/"/>
    
  </entry>
  
  <entry>
    <title>ResNet</title>
    <link href="http://yoursite.com/2020/03/18/ResNet/"/>
    <id>http://yoursite.com/2020/03/18/ResNet/</id>
    <published>2020-03-18T03:05:41.000Z</published>
    <updated>2020-04-04T14:36:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>残差网路</strong></p><p><img src="https://raw.githubusercontent.com/su-loch/pics/master/img/resnet-block.png" alt></p><p>这是一个两层神经网络。</p><p>计算过程从a[l]开始，先进行线性运算。<br>$$<br>z^{[l+1] }= W^{[l+1]}a^{[l]} + b^{[l+1]}<br>$$<br>在由激活函数g得到a[l+1]，这里g是线性整流函数relu<br>$$<br>a^{[l+1]} = g(z^{[l+1]})<br>$$<br>随后进行第二层线性运算<br>$$<br>z^{[l+2]} = W^{[l+2]}a^{[l+1]} + b^{[l+2]}<br>$$<br>再经过Relu<br>$$<br>a^{[l+2]} = g(z^{[l+2]})<br>$$<br>在残差网络中加入一点变化</p><p><img src="https://raw.githubusercontent.com/su-loch/pics/master/img/resnet.png" alt></p><p>即”跳远连接”<br>$$<br>a^{[l+2]} = g(z^{[l+2]} + a^{[l]})<br>$$<br>这样，随着网络的加深，训练误差也跟着下降。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;残差网路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/su-loch/pics/master/img/resnet-block.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;这是一个两层神经网络</summary>
      
    
    
    
    
    <category term="deeplearning" scheme="http://yoursite.com/tags/deeplearning/"/>
    
  </entry>
  
  <entry>
    <title>Linux指令</title>
    <link href="http://yoursite.com/2020/03/17/Linux%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/03/17/Linux%E6%8C%87%E4%BB%A4/</id>
    <published>2020-03-17T07:09:23.000Z</published>
    <updated>2020-04-01T17:33:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/nb/37698552" target="_blank" rel="noopener">https://www.jianshu.com/nb/37698552</a></p><p><a href="https://www.jianshu.com/p/8c2af151ddc2" target="_blank" rel="noopener">https://www.jianshu.com/p/8c2af151ddc2</a></p><p><a href="https://www.runoob.com/linux/linux-shell.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-shell.html</a></p><p><a href="https://www.linuxcool.com/" target="_blank" rel="noopener">linux命令大全</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/nb/37698552&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/nb/37698552&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http</summary>
      
    
    
    
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>VID</title>
    <link href="http://yoursite.com/2020/03/15/VID/"/>
    <id>http://yoursite.com/2020/03/15/VID/</id>
    <published>2020-03-15T12:53:26.000Z</published>
    <updated>2020-03-16T14:44:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>reference paper：</p><blockquote><p>陈志欣. 基于深度学习的视频目标检测算法研究与应用[D].北方工业大学,2019.</p></blockquote><p><strong>视频目标检测（object detection from video）</strong></p><p>从2015年开始，ILSVRC新增了VID挑战任务，视频中的目标检测难题：更多的帧图像文件、由于速度快导致运动模糊和光照等问题、物体间的遮挡问题。</p><p><strong>数据集预处理</strong></p><ol><li>归一化：将原始像素压缩到[0,1]区间</li></ol><p>$$<br>\text { norm }=\frac{x_{i}-\min (x)}{\max (x)-\min (x)}<br>$$</p><ol start="2"><li>去均值化：对每个通道，移除图像的平均亮度，凸显个体差异</li></ol><p>$$<br>x_{r}, x_{g}, x_{b}=\left(x_{r}-R_{m e a n}, x_{g}-G_{m e a n}, x_{b}-B_{m e a n}\right)<br>$$</p><ol start="3"><li>标准化：使像素符合标准正态分布，在样本尺度不一致的情况下（如不同相机采集的图片，或者是来源不同的图片）</li></ol><p>$$<br>x^{\prime}=\frac{x-\mu}{\sigma}<br>$$</p><a id="more"></a><p><strong>数据增强</strong>：解决样本数量和质量不满足需求的问题</p><p>镜像翻转、随机旋转、随机错切、高斯噪声、椒盐噪声、明亮度变化（不加入影响图像本质特性的噪声）</p><p><strong>性能指标</strong></p><p>mAP、IoU、FPS、NMS</p><p><strong>可变形卷积</strong>（Deformable Convolution）-&gt; 了解卷积的多种方式</p><p><img src="https://raw.githubusercontent.com/su-loch/pics/master/img/deformable%20convolution.png" alt></p><p>refer to <a href="https://arxiv.org/pdf/1703.06211.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1703.06211.pdf</a></p><p><strong>对小目标物体的检测</strong></p><ul><li><p>数据增强：用不同尺度的图片进行训练 × </p></li><li><p>SPP 空间池化金字塔 ×</p></li><li><p>SSD 在不同尺度的特征图上引入区域检测机制 （提高有限） ×</p></li><li><p><strong>FPN网络</strong></p></li></ul><p><img src="https://raw.githubusercontent.com/su-loch/pics/master/img/FPN.png" alt></p><p>自下而上的前馈计算（池化采样），自下而上的特征融合与横向连接（最近邻上采样或双线性插值），横向对应的层特征图各像素点之间直接相加，融合后的特征还要进行3*3卷积以消除upsampling产生的混叠作用。</p><p><strong>网络的训练损失函数</strong></p><p>这一块真的看的我眼花…</p><ol><li>回归损失</li></ol><p>均方误差/平方损失/L2 损失：<br>$$<br>M S E=\frac{\sum_{i=1}^{n}\left(y_{i}-\hat{y}_{i}\right)^{2}}{n}<br>$$<br>平均绝对误差/L1 损失：</p><p>$$<br>M A E=\frac{\sum_{i=1}^{n}\left|y_{i}-\hat{y}_{i}\right|}{n}<br>$$</p><p>平均偏差误差（mean bias error）：</p><p>$$<br>M B E=\frac{\sum_{i=1}^{n}\left(y_{i}-\hat{y}_{i}\right)}{n}<br>$$</p><ol start="2"><li>分类损失</li></ol><p>Hinge Loss/多分类 SVM 损失：</p><p>$$<br>S V M L o s s=\sum_{j \neq y_{i}} \max \left(0, s_{j}-s_{y_{i}}+1\right)<br>$$</p><p>交叉熵损失/负对数似然：</p><p>$$<br>CrossEntropyLoss = -\left( y_{i} \log \left( \hat{y} _ {i} \right) + \left( 1-y _ {i} \right) \log \left(1- \hat{y}_{i} \right) \right)<br>$$<br>剩余词条待补充：multi-task loss、facol loss、GIoU、DIoU</p><p>refer to：<a href="https://zhuanlan.zhihu.com/p/112057799" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/112057799</a></p><p><strong>YOLOv3中用k-means聚类得到anchor大小和数量设置</strong></p><p><strong>VID流程</strong></p><p>Image_Feature = N_feat(Image_input) -&gt; Output = N_det(Image_Feature)提取候选框进行分类回归</p><p>Deap Feature Flow利用一种基于卷积操作的FlowNet生成前后帧的光流图，再叠加上前一时刻关键帧信息，生成本时刻关键帧最终的特征图。</p><p>FGFA将相邻帧在时序上的特征聚合到当前帧的特征中，处理运动模糊、视频散焦、奇特姿势等问题。</p><p><strong>稀疏特征传播方式提高检测速度</strong>   DFF</p><p>每隔n张（n常取10）抽取一个关键帧得到特征图，非关键帧的特征图计算为最近邻关键帧以及其与当前非关键帧之间运动变化矢量的加和。通常用光流矢量定量计算临近两帧之间的信息差值。 -&gt; FlowNet如何实现</p><p><strong>密集特征聚合方式提高检测精度</strong>   FGFA</p><p>需要计算视频每一帧的特征图，对视频的第i个时刻的关键帧，给每个时间帧分配一定权重系数，来对前后i+2r个特征图对应位置的值加权求和。 -&gt; 权重如何分配</p><p><strong>关键帧的选择优化</strong></p><ul><li>基于特征一致性的关键帧调度策略：</li></ul><p>$$<br>key = is_{-}key \left( B_{k \rightarrow i} \right)<br>$$</p><p>$$<br>i s_{k e y}\left(Q_{k \rightarrow i}\right) = \left [ \frac{1}{N_{p}} \sum_{p} 1 \left ( B_{k \rightarrow i}(p) \leq \tau \right ) \right ] &gt; \gamma<br>$$<br>前后两个参数分别设置为0.1 和 0.2</p><ul><li><p>FlowNetSimple作为光流计算网络</p></li><li><p>设计Tubelet结构存放<strong>低检测关键帧</strong>前后r帧信息，做密特征聚合使用，优化此关键帧的检测精度。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;reference paper：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;陈志欣. 基于深度学习的视频目标检测算法研究与应用[D].北方工业大学,2019.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;视频目标检测（object detection from video）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从2015年开始，ILSVRC新增了VID挑战任务，视频中的目标检测难题：更多的帧图像文件、由于速度快导致运动模糊和光照等问题、物体间的遮挡问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据集预处理&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;归一化：将原始像素压缩到[0,1]区间&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$$&lt;br&gt;\text { norm }=\frac{x_{i}-\min (x)}{\max (x)-\min (x)}&lt;br&gt;$$&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;去均值化：对每个通道，移除图像的平均亮度，凸显个体差异&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$$&lt;br&gt;x_{r}, x_{g}, x_{b}=\left(x_{r}-R_{m e a n}, x_{g}-G_{m e a n}, x_{b}-B_{m e a n}\right)&lt;br&gt;$$&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;标准化：使像素符合标准正态分布，在样本尺度不一致的情况下（如不同相机采集的图片，或者是来源不同的图片）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$$&lt;br&gt;x^{\prime}=\frac{x-\mu}{\sigma}&lt;br&gt;$$&lt;/p&gt;</summary>
    
    
    
    
    <category term="cv" scheme="http://yoursite.com/tags/cv/"/>
    
  </entry>
  
  <entry>
    <title>Anaconda使用tips</title>
    <link href="http://yoursite.com/2020/03/13/Anaconda%E4%BD%BF%E7%94%A8tips/"/>
    <id>http://yoursite.com/2020/03/13/Anaconda%E4%BD%BF%E7%94%A8tips/</id>
    <published>2020-03-13T11:57:12.000Z</published>
    <updated>2020-03-13T12:59:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天为了安装tensorflow踩了不少坑🤢，主要是anaconda环境安装的问题，写点笔记记下来</p><p>新建一个虚拟环境 conda create -n 环境名 python=3.7 （版本自己选择），创建的环境在./envs文件夹下。</p><p>conda activate 环境名 激活</p><p>conda deactivate 关闭回到base环境</p><p>conda remove -n 环境名 –all 删除已有环境</p><p>conda list 查看已安装package</p><p>换源就不说了，注意在修改.condarc文件时如果运行报错，把里面的https改为http即可。</p><p>因为直接使用conda下载速度太慢，所以选择离线安装。首先在清华镜像源下载<a href="https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/tensorflow/" target="_blank" rel="noopener">tensorflow</a>和<a href="https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/opencv-python/" target="_blank" rel="noopener">opencv</a>，选择对应平台和python版本的.whl文件，放在./Lib/site-packages/文件夹下。cd到当前目录，pip install xxxx.whl安装即可。如果出现报错无法定位程序输入点的问题把Anaconda3/DLLS下libssl-1_1-x64.dll文件到覆盖Anaconda3/Library/bin中，一路yes就可以完成安装。安错版本pip uninstall tensorflow卸载</p><p>在选择tensorflow版本的时候，注意自己的电脑是否支持当前版本。</p><p><strong>reference：</strong></p><p><a href="https://blog.csdn.net/qq_37465638/article/details/100071259" target="_blank" rel="noopener">无法定位程序输入点</a></p><p><a href="https://zhuanlan.zhihu.com/p/102324325" target="_blank" rel="noopener">tf2.0安装</a></p><p><a href="https://www.cnblogs.com/zhaochunhui/p/10839462.html" target="_blank" rel="noopener">版本选择</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天为了安装tensorflow踩了不少坑🤢，主要是anaconda环境安装的问题，写点笔记记下来&lt;/p&gt;
&lt;p&gt;新建一个虚拟环境 conda create -n 环境名 python=3.7 （版本自己选择），创建的环境在./envs文件夹下。&lt;/p&gt;
&lt;p&gt;conda</summary>
      
    
    
    
    
    <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>DL_tools</title>
    <link href="http://yoursite.com/2020/03/12/DL-tools/"/>
    <id>http://yoursite.com/2020/03/12/DL-tools/</id>
    <published>2020-03-12T08:50:55.000Z</published>
    <updated>2020-03-12T09:13:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一些深度学习框架"><a href="#一些深度学习框架" class="headerlink" title="一些深度学习框架"></a>一些深度学习框架</h1><ol><li>Caffe：代码基于C++（训练速度快），入门级、上手快（修改一些配置文件即可），适合新手了解深度学习任务中的各种参数；</li><li>Keras：基于Theano或TensorFlow的高级框架，可快速构建网络，不用了解网络的底层设计；</li><li>TensorFlow：有高级的API（tf.Keras等），也可以自己从零开始构建一个新的网络，但是1.x版本静态图问题不好调试，2.0貌似解决了这个问题（尝试使用这个做毕设，不知道学长用的是哪个）；</li><li>Pytorch：科研人员都说好用的框架，上手快、好搭建，但是工业上采用tensorflow更多。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一些深度学习框架&quot;&gt;&lt;a href=&quot;#一些深度学习框架&quot; class=&quot;headerlink&quot; title=&quot;一些深度学习框架&quot;&gt;&lt;/a&gt;一些深度学习框架&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;Caffe：代码基于C++（训练速度快），入门级、上手快（修改一些配置文件即可）</summary>
      
    
    
    
    
    <category term="深度学习" scheme="http://yoursite.com/tags/深度学习/"/>
    
  </entry>
  
  <entry>
    <title>CNN</title>
    <link href="http://yoursite.com/2020/03/06/CNN/"/>
    <id>http://yoursite.com/2020/03/06/CNN/</id>
    <published>2020-03-06T13:23:00.000Z</published>
    <updated>2020-03-06T13:42:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Convolutional-Neural-Network"><a href="#Convolutional-Neural-Network" class="headerlink" title="Convolutional Neural Network"></a>Convolutional Neural Network</h1><h2 id="1-输入层"><a href="#1-输入层" class="headerlink" title="1. 输入层"></a>1. 输入层</h2><p>原始图片，在计算机内用构成像素点的多维矩阵来表示。</p><h2 id="2-隐层"><a href="#2-隐层" class="headerlink" title="2. 隐层"></a>2. 隐层</h2><p>convolution卷积：过滤特征</p><p>ReLU线性修正单元：激活函数</p><p>polling池化：降低维度并提高模型的容错性</p><p><strong>降低模型的参数数目</strong></p><ol><li><p>局部感知野：每个神经元只需要对局部图像进行感知，然后在更高层将局部的信息综合起来得到全局的信息；</p></li><li><p>权值共享：对于每一层来讲，所有神经元对应的权值参数是一样的，同一层下的神经元连接参数只与特征提取的方式有关，而与具体的位置无关。</p></li></ol><p>第一层隐层一般是用来做边缘和曲线检测</p><p>第二层隐层对第一层学到的边缘曲线组合得到的一些特征</p><p>第三层则会学到一些更复杂的特征</p><p><strong>ReLU激活函数</strong></p><p>引入非线性激励函数，深层网络具有意义（不再是输入的线性组合，可以逼近任意函数）</p><p>为什么采用ReLU函数：1. 采用sigmoid等函数，计算量大，反向传播求误差梯度时涉及除法；2. 对于深层网络，sigmoid函数反向传播时，容易出现梯度消失的情况（sigmoid接近饱和区时，变换太缓慢，导数趋于0，容易造成信息丢失），从而无法完成深层网络的训练；3. ReLU会使一部分神经元的输出为0，造成了网络的稀疏性，并减少了参数的相互依存关系，缓解了过拟合问题的发生。</p><p><strong>pooling池化（欠采样）</strong></p><p>主要有max、average、sum等不同类型的操作</p><h2 id="3-输出层"><a href="#3-输出层" class="headerlink" title="3. 输出层"></a>3. 输出层</h2><p>经过若干次的卷积+线性修真+pooling，模型会将学到的高水平特征接到一个<strong>全连接层</strong>，通过softmax函数得到输出。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Convolutional-Neural-Network&quot;&gt;&lt;a href=&quot;#Convolutional-Neural-Network&quot; class=&quot;headerlink&quot; title=&quot;Convolutional Neural Network&quot;&gt;&lt;/a&gt;Co</summary>
      
    
    
    
    
    <category term="NN" scheme="http://yoursite.com/tags/NN/"/>
    
  </entry>
  
  <entry>
    <title>TexLive_installation</title>
    <link href="http://yoursite.com/2019/07/11/TexLive-installation/"/>
    <id>http://yoursite.com/2019/07/11/TexLive-installation/</id>
    <published>2019-07-11T08:02:40.000Z</published>
    <updated>2019-08-18T07:19:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TexLive-VScode-搭建LaTex编译环境"><a href="#TexLive-VScode-搭建LaTex编译环境" class="headerlink" title="TexLive + VScode 搭建LaTex编译环境"></a>TexLive + VScode 搭建LaTex编译环境</h1><p>最近对LaTex十分感兴趣（因为好看），百度了很多教程，最后决定在VScode上配置环境。</p><fancybox><br><br><img src="/img/texlive_test.png" alt><br><br></fancybox><a id="more"></a><ol><li><p>下载<a href="https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/" target="_blank" rel="noopener">TexLive镜像文件</a>(清华大学镜像)，选择texlive2019.iso下载即可；</p></li><li><p>iso文件解压后，在文件夹中点击install-tl-advanced.bat或install-tl-windows.bat文件均可，其中可进行一些安装地址和组件的配置，安装时间较长；</p></li><li><p>在VScode中安装插件：LaTex language support, LaTex Workshop</p></li><li><p>对latex编译环境进行配置：在设置中搜索latex，对setting.json进行编辑，加入以下代码段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&quot;latex-workshop.latex.tools&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;latexmk&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;latexmk&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;-synctex=1&quot;,</span><br><span class="line">                &quot;-interaction=nonstopmode&quot;,</span><br><span class="line">                &quot;-file-line-error&quot;,</span><br><span class="line">                &quot;-pdf&quot;,</span><br><span class="line">                &quot;%DOC%&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;xelatex&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;xelatex&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;-synctex=1&quot;,</span><br><span class="line">                &quot;-interaction=nonstopmode&quot;,</span><br><span class="line">                &quot;-file-line-error&quot;,</span><br><span class="line">                &quot;%DOC%&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;pdflatex&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;pdflatex&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;-synctex=1&quot;,</span><br><span class="line">                &quot;-interaction=nonstopmode&quot;,</span><br><span class="line">                &quot;-file-line-error&quot;,</span><br><span class="line">                &quot;%DOC%&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;bibtex&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;bibtex&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;%DOCFILE%&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;latex-workshop.latex.recipes&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;xelatex&quot;,</span><br><span class="line">            &quot;tools&quot;: [</span><br><span class="line">                &quot;xelatex&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;pdflatex&quot;,</span><br><span class="line">            &quot;tools&quot;: [</span><br><span class="line">                &quot;pdflatex&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;latexmk&quot;,</span><br><span class="line">            &quot;tools&quot;: [</span><br><span class="line">                &quot;latexmk&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;pdflatex -&gt; bibtex -&gt; pdflatex*2&quot;,</span><br><span class="line">            &quot;tools&quot;: [</span><br><span class="line">                &quot;pdflatex&quot;,</span><br><span class="line">                &quot;bibtex&quot;,</span><br><span class="line">                &quot;pdflatex&quot;,</span><br><span class="line">                &quot;pdflatex&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;latex-workshop.view.pdf.viewer&quot;: &quot;tab&quot;,</span><br><span class="line">    &quot;latex-workshop.latex.clean.subfolder.enabled&quot;: true //这里要选择true清除编译过程中产生的文件</span><br></pre></td></tr></table></figure></li><li><p>创建文件test.tex，Ctrl+S保存编译，得到PDF文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\documentclass[UTF8]&#123;ctexart&#125;</span><br><span class="line">    \title&#123;TexLive + VScode 环境配置&#125;</span><br><span class="line">    \author&#123;Silhouettes&#125;</span><br><span class="line">    \date&#123;\today&#125;</span><br><span class="line">    \begin&#123;document&#125;</span><br><span class="line">    \maketitle</span><br><span class="line">    This is the beginning of the article.\\</span><br><span class="line">    </span><br><span class="line">    编译成功！\\</span><br><span class="line"></span><br><span class="line">    $ &#123;f&#125;&apos;(0) =  \left. \frac&#123;df&#125;&#123;dx&#125; \right|_&#123;x=0&#125; $</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure><p>这里要注意tex文件要按utf-8编码，如果编译后出现乱码，可以更换编码方式重新保存后再编译一次。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;TexLive-VScode-搭建LaTex编译环境&quot;&gt;&lt;a href=&quot;#TexLive-VScode-搭建LaTex编译环境&quot; class=&quot;headerlink&quot; title=&quot;TexLive + VScode 搭建LaTex编译环境&quot;&gt;&lt;/a&gt;TexLive + VScode 搭建LaTex编译环境&lt;/h1&gt;&lt;p&gt;最近对LaTex十分感兴趣（因为好看），百度了很多教程，最后决定在VScode上配置环境。&lt;/p&gt;
&lt;fancybox&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;/img/texlive_test.png&quot; alt&gt;&lt;br&gt;&lt;br&gt;&lt;/fancybox&gt;</summary>
    
    
    
    
    <category term="LaTex" scheme="http://yoursite.com/tags/LaTex/"/>
    
  </entry>
  
  <entry>
    <title>latex2word</title>
    <link href="http://yoursite.com/2019/07/06/latex2word/"/>
    <id>http://yoursite.com/2019/07/06/latex2word/</id>
    <published>2019-07-06T10:21:19.000Z</published>
    <updated>2019-08-18T07:20:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="latex2word"><a href="#latex2word" class="headerlink" title="latex2word"></a>latex2word</h1><p>突然想，能不能把在latex上生成的数学公式导入word里面，因为word自带的公式编辑器确实不是很好用，相较之下latex生成的公式十分精致。</p><p>搜到了很多教程，挑了我觉得最方便的一种：</p><p>先用<a href="https://mathpix.com/" target="_blank" rel="noopener">Mathpix</a>把需要的公式截图翻译成latex语言，再copy到<a href="https://www.latex4technics.com/" target="_blank" rel="noopener">Online LaTeX Equation Editor</a>网站，在MathJax框右键Show Math As项MathML Code选项，在word中 Alt 加 = 快捷键生成一个公式文本框将前面弹出界面的代码全部复制粘贴即可。</p><fancybox><br><br><img src="/img/step_1.gif" alt="step_1"><br><br></fancybox><fancybox><br><br><img src="/img/step_2.gif" alt="step_2"><br><br></fancybox><p>当然这是一种偷懒的方法，在Word2016中的公式编辑器中已经支持了一部分的LaTeX语法（比如\partial、\sum等等），可以很方便地输入一些简单的公式。</p><p>这个方法主要是用来抄理论的时候快速打出公式用的（不是。</p><p>/暑假愉快</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;latex2word&quot;&gt;&lt;a href=&quot;#latex2word&quot; class=&quot;headerlink&quot; title=&quot;latex2word&quot;&gt;&lt;/a&gt;latex2word&lt;/h1&gt;&lt;p&gt;突然想，能不能把在latex上生成的数学公式导入word里面，因为word自</summary>
      
    
    
    
    
    <category term="daily" scheme="http://yoursite.com/tags/daily/"/>
    
  </entry>
  
  <entry>
    <title>tensorflow_learning_2</title>
    <link href="http://yoursite.com/2019/05/20/tensorflow-learning-2/"/>
    <id>http://yoursite.com/2019/05/20/tensorflow-learning-2/</id>
    <published>2019-05-20T11:53:43.000Z</published>
    <updated>2019-05-20T13:57:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tensorflow学习笔记-2"><a href="#tensorflow学习笔记-2" class="headerlink" title="tensorflow学习笔记_2"></a>tensorflow学习笔记_2</h1><h2 id="计算图与张量"><a href="#计算图与张量" class="headerlink" title="计算图与张量"></a>计算图与张量</h2><p>TensorFlow中的计算可以表示为一个有向图（<strong>计算图</strong>），其中每一个运算操作作为一个节点，节点与节点的连接称为边，一张计算图描述了数据的计算流程，我们可以对计算图上的各个分支进行改变来达到我们的运算目的。在计算图的边中流动的数据被称为<strong>张量</strong>（tensor），张量的数据类型可以事先定义，也可以通过计算图的结构推导得出。</p><p>一个运算操作代表了一类抽象运算（如矩阵乘法或向量加法），运算操作必须有自己的属性，但是所有属性都必须被预先设置，或者在计算图沿着边运行时可以被推断出来。</p><h2 id="会话-Session"><a href="#会话-Session" class="headerlink" title="会话 Session"></a>会话 Session</h2><p>session是用户使用tensorflow的互交式接口，用户可以通过session的Extend方法添加新的节点和边来创建计算图，然后通过session的Run方法执行计算图。</p><p>大多数运算中，tensor不会一直保留下去。而Variable是一类特殊的运算操作，可以将一些需要保留的tensor储存在内存或者显存当中。每执行一次计算图后，Variable中的tensor都会被保存，同时在计算过程中，tensor的值也可以被更新。</p><hr><p>csdn上还是有很多的教程   <a href="https://www.cnblogs.com/hypnus-ly/p/8040951.html" target="_blank" rel="noopener">概念理解</a></p><h2 id="MNIST手写数字识别"><a href="#MNIST手写数字识别" class="headerlink" title="MNIST手写数字识别"></a>MNIST手写数字识别</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">mnist = input_data.read_data_sets(<span class="string">"MNIST_data/"</span>, one_hot=<span class="literal">True</span>)</span><br><span class="line">print(mnist.train.images.shape,mnist.train.labels.shape)</span><br><span class="line">print(mnist.test.images.shape,mnist.test.labels.shape)</span><br><span class="line">print(mnist.validation.images.shape,mnist.validation.labels.shape)</span><br></pre></td></tr></table></figure><p>结果输出为</p><p>(55000, 784) (55000, 10)<br>(10000, 784) (10000, 10)<br>(5000, 784) (5000, 10)</p><p><a href="https://github.com/yhlleo/mnist" target="_blank" rel="noopener">一个例程</a> 存</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;tensorflow学习笔记-2&quot;&gt;&lt;a href=&quot;#tensorflow学习笔记-2&quot; class=&quot;headerlink&quot; title=&quot;tensorflow学习笔记_2&quot;&gt;&lt;/a&gt;tensorflow学习笔记_2&lt;/h1&gt;&lt;h2 id=&quot;计算图与张量&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="机器学习" scheme="http://yoursite.com/categories/机器学习/"/>
    
    
    <category term="tensorflow" scheme="http://yoursite.com/tags/tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>tensorflow_learning_1</title>
    <link href="http://yoursite.com/2019/05/19/tensorflow-learning-1/"/>
    <id>http://yoursite.com/2019/05/19/tensorflow-learning-1/</id>
    <published>2019-05-19T09:40:58.000Z</published>
    <updated>2019-05-20T13:23:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tensorflow学习笔记-1"><a href="#tensorflow学习笔记-1" class="headerlink" title="tensorflow学习笔记_1"></a>tensorflow学习笔记_1</h1><h2 id="环境安装-CPU版本的tensorflow"><a href="#环境安装-CPU版本的tensorflow" class="headerlink" title="环境安装 CPU版本的tensorflow"></a>环境安装 CPU版本的tensorflow</h2><ol><li><p>安装anaconda或者miniconda 这里附上 <a href="https://blog.csdn.net/qq_36306781/article/details/81254832?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">一个很完整的参考教程</a>，因为我的anaconda安装了python3.7，而3.5对tensorflow的兼容性最好（听说，所以在anaconda中新建一个环境安装python3.5和tensorflow1.13.1。</p></li><li><p>首先 conda creat -n tensorflow python=3.5 新建一个环境名字为tensorflow，然后发现Anaconda3/envs/目录下出现了tensorflow的文件夹。</p></li><li><p>激活环境 activate tensorflow，关闭这个环境用命令 deactivate</p></li><li><p>安装tensorflow  conda install tensorflow</p><blockquote><p>conda安装比pip要方便不少，而且conda安装的tf效率要比pip安装的高。</p></blockquote></li><li><p>验证是否安装成功</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">hello = tf.constant(<span class="string">'Hello,tensorflow'</span>)</span><br><span class="line">sess = tf.Session()</span><br><span class="line">print(sess.run(hello))</span><br></pre></td></tr></table></figure><p>报错的话加上这段话</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line">os.environ[<span class="string">'TF_CPP_MIN_LOG_LEVEL'</span>] = <span class="string">'2'</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>tips：</strong>上面的方法将tensorflow安装在一个单独的环境当中，其他模块如numpy、opencv等都要重新配置，尝试将/Anaconda3/envs/tensorflow文件夹全部复制到/Anaconda3/Lib/site-packages下运行（参考了一篇安装在linux上的文章，结果不是很理想，放弃。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;tensorflow学习笔记-1&quot;&gt;&lt;a href=&quot;#tensorflow学习笔记-1&quot; class=&quot;headerlink&quot; title=&quot;tensorflow学习笔记_1&quot;&gt;&lt;/a&gt;tensorflow学习笔记_1&lt;/h1&gt;&lt;h2 id=&quot;环境安装-CPU版</summary>
      
    
    
    
    <category term="机器学习" scheme="http://yoursite.com/categories/机器学习/"/>
    
    
    <category term="tensorflow" scheme="http://yoursite.com/tags/tensorflow/"/>
    
  </entry>
  
</feed>
