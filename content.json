{"meta":{"title":"sl's learning notes","subtitle":null,"description":"just record","author":"_Silhouttes","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2020-11-22T14:54:32.051Z","updated":"2019-04-06T18:44:06.000Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404 Not Found很抱歉，您访问的页面不存在可能是输入地址有误或该地址已被删除"},{"title":"About","date":"2020-03-11T14:25:44.000Z","updated":"2020-12-05T10:25:54.625Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"About_me major : EE NUAA undergraduate/BUAA postgraduate idol : kkura qq : 1519088021（_Silhouettes) mail : loch_wjj@163.com"},{"title":"Category","date":"2020-12-05T10:17:34.925Z","updated":"2020-12-05T10:17:34.925Z","comments":true,"path":"category/index.html","permalink":"http://yoursite.com/category/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-11-22T14:54:32.278Z","updated":"2020-01-14T10:46:56.000Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":"jiji的blog"},{"title":"Tag","date":"2020-12-05T10:21:36.571Z","updated":"2020-12-05T10:21:36.571Z","comments":true,"path":"tag/index.html","permalink":"http://yoursite.com/tag/index.html","excerpt":"","text":""},{"title":"","date":"2020-12-05T10:26:50.723Z","updated":"2020-12-05T10:26:50.723Z","comments":true,"path":"some_webs/COUNT_DOWN.html","permalink":"http://yoursite.com/some_webs/COUNT_DOWN.html","excerpt":"","text":"COUNT DOWN function Timer(year,month,day,hour,minute,second){ var leftTime = (new Date(year,month-1,day,hour,minute,second)) - (new Date()); var days = parseInt(leftTime / 1000 / 60 / 60 / 24 , 10); var hours = parseInt(leftTime / 1000 / 60 / 60 % 24 , 10); var minutes = parseInt(leftTime / 1000 / 60 % 60, 10); var seconds = parseInt(leftTime / 1000 % 60, 10); days = checkTime(days); hours = checkTime(hours); minutes = checkTime(minutes); seconds = checkTime(seconds); setInterval(\"Timer(2021,1,18,00,00,00)\",1000); // console.log(days); if (isNaN(days)) { } else{ document.getElementById(\"timer\").innerHTML = days+\"天\" + hours+\"小时\" + minutes+\"分\"+seconds+\"秒\"; } } function checkTime(i){ //0-9的前面加上“0” if(i"}],"posts":[{"title":"Cpp_learningnote2","slug":"Cpp-learning-note-2","date":"2021-03-16T16:00:00.000Z","updated":"2021-03-17T02:44:59.112Z","comments":true,"path":"2021/03/17/Cpp-learning-note-2/","link":"","permalink":"http://yoursite.com/2021/03/17/Cpp-learning-note-2/","excerpt":"","text":"[toc] reference：《黑马》C++系列教程 基础 核心 提高 本篇主要参考核心篇进行记录 内存分区 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收 在C++中主要利用new在堆区开辟内存，释放利用操作符 delete，note释放数组 delete 后加 [] 引用 不要返回局部变量引用，可以返回静态变量引用 static 引用的本质，在C++内部实现是一个指针常量 123int a = 10;int&amp; ref = a;//自动转化为int* const ref = &amp;a; 指针常量是指针指向不可改 在函数形参列表中，可以加const修饰形参，防止形参改变实参 123int&amp; ref = 10; //是错误的，引用本身需要一个合法的内存空间，不能直接赋值const int&amp; ref = 10;//加入const，编译器会优化代码，int temp = 10; const int&amp; ref = temp; 函数重载123456789101112//1.引用作为重载条件void func(int&amp; a)void func(const int&amp; a)int a = 10;func(a);func(10);//调用不同的函数//2.函数重载遇到函数默认参数func2(int a, int b = 10)func2(int a)//这样的定义在调用的时候会报错func2(10);//产生歧义，不能做出调用函数的判断 类和对象 OOP - 封装、继承、多态 一、about 类 语法：class 类名{ 访问权限: 属性 / 行为}; 类在设计时，可以把属性和行为放在不同权限下，加以控制 访问权限有三种： – public 公共权限： 类内可以访问，类外可以访问（只允许本类的成员函数访问） – protected 保护权限 ：类内可以访问，类外不可以访问 （只允许子类及本类的成员函数访问） – private 私有权限： 类内可以访问，类外不可以访问（可以被任意实体访问） 在C++中 struct 和 class 唯一的区别就在于默认的访问权限不同，struct默认权限为公共，class默认权限为私有 二、concerning 对象 对象的初始化和清理 – 构造函数和析构函数 如果编程者不提供，编译器会自动提供空实现的构造和析构函数（这时候编译器自动添加的拷贝构造对属性的拷贝是浅拷贝 –构造函数语法： 类名(){} 构造函数没有返回值也不写void 函数名称与类名相同 构造函数可以参数，可能发生函数重载 程序在调用对象的时候会自动调用构造，且只调用一次 分类 按参数：有参构造、无参构造 按类型：普通构造、拷贝构造 调用方式 括号法、显式法（类似java）、隐式转换法 *tips: 调用无参构造函数不能加括号，加了编译器认为这是一个函数声名； 不能利用拷贝构造函数初始化匿名对象，编译器认为是对象声明； 拷贝构造函数的调用时机： 使用一个已创建好的对象初始化新的对象 值传递的方式给函数参数传值 以值的方式返回局部对象 – 析构函数语法：~类名(){} 析构函数没有返回值也不写void 函数名称与类名相同，前面加上符号~ 析构函数不可以有参数，不能发生重载 程序在对象销毁前会自动调用析构，且只调用一次 （一）深拷贝与浅拷贝 浅拷贝：简单的赋值拷贝操作 深拷贝：在堆区重新申请空间进行拷贝操作 如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的在delete时出现的问题 new -&gt; 在堆空间创建一块内存并返回内存地址给指针 1int* p = new int(10);//这里定义变量类型为指针 （二）初始化列表 语法：构造函数(): 属性1(值1)， 属性2(值2), …{} 只有构造函数可以使用初始化列表语法，引用数据成员与const数据成员必须使用这种语法，因为它们在创建时就需要初始化 12345678class Person&#123;public: Person(int a,int b,int c) :m_A(a), m_B(b), m_C(c) &#123;&#125;private: int m_A: int m_B; int m_C;&#125; （三）类对象作为类成员 当类中成员时其他类对象时，我们称该成员为 对象成员 构造的顺序是：先调用对象成员的构造，再调用本类构造。析构的顺序与构造相反 （四）静态成员 在成员变量和成员函数前加上关键字static，称为静态成员 静态成员变量（2种访问方式：通过对象、通过类名） 所有对象共享同一份数据 在编译阶段分配内存 类内声明，类外初始化 1234567891011class Person&#123;public: static int m_A;private: static int m_B;&#125;int Person::m_A = 10;int Person::m_B = 10;//类外初始化cout &lt;&lt; Person::m_A &lt;&lt; endl;//通过类名访问cout &lt;&lt; Person::m_B &lt;&lt; endl;//会报错，没有访问权限 静态成员函数 所有对象共享同一个函数 静态成员函数只能访问静态成员变量 三、C++对象模型和this指针 在C++中，类内的成员变量和成员函数 分开储存，只有非静态成员变量才属于类的对象上。非静态成员变量占用对象空间，而静态成员变量和成员函数（静态/非静态）都不占用对象空间，所有非静态成员函数共享一个函数实例。 this指针 指向被调用成员函数所属的对象 this指针是隐含在每一个非静态成员函数内的一种指针 不需要定义可以直接使用 用途：当形参和成员变量同名时，用this指针区分；在类的非静态成员函数中返回对象本身，可使用return *this 空指针也可以调用成员函数，但是当成员函数用到了this指针则不可以，这个时候需要对指针进行非空判断，保证代码的健壮性 123Person* p = NULL;if(this == NULL) return;//非空判断 常函数：成员函数后加const​，在常函数内不可以修改成员属性，但是当成员属性声明时添加mutable关键字，在常函数内仍可以进行修改 1234void func() const &#123;...&#125;public: int m_A; mutable int m_B; 常对象：声明对象前加const，常对象只能调用常函数，不能修改成员变量的值，但是可以访问 1const Person person; 四、友元 -&gt; 让一个函数或者类访问另一个类中的私有成员 关键字 friend 三种实现 全局函数左右元 类做友元 成员函数做友元 五、运算符重载 -&gt; 对已有的运算符重新进行定义，赋予另一种功能，以适应不同的数据类型 函数名由关键字 operator 和其后要进行重载的运算符符号构成的 通俗理解就是将数的相加、输出、比较判断等运算重载为直接对对象进行操作 六、继承 class A: public B { }; 其中A类称为子类 或 派生类，B类成为父类 或 基类 派生类中的成员包含从基类继承的和自己增加的成员 继承方式 语法： class 子类: 继承方式 父类 公共继承 public 保护继承 protected 私有继承 private public protected private 公有继承 public protected 不可见 保护继承 protected protected 不可见 私有继承 private private 不可见 tips： 父类中私有成员也被子类继承下去了，只是由编译器隐藏后不能访问 继承中，先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反 继承同名成员的处理方式 访问子类同名成员 直接访问即可 访问父类同名成员 需要添加作用域 1234567891011121314151617class Base &#123;public: Base()&#123;m_A = 100;&#125; void func()&#123;&#125; int m_A;&#125;class Son: public Base&#123;public: Son()&#123;m_A = 200;&#125; void func()&#123;&#125; int m_A;&#125;void main()&#123; Son s; s.func();//直接访问子类同名成员 s.Base::func();//添加作用域访问父类同名成员&#125;//这里是子类以对象的方式进行访问 *tips：对于同名静态成员处理方式与上面相同，不过有通过对象和通过类名两种访问方式 多继承语法：class 子类: 继承方式 父类1, 继承方式 父类2 … 菱形继承（草泥马的例子好形象2333) 羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。 12345678910111213141516171819202122class Animal&#123;public: int m_Age;&#125;;//继承前加virtual关键字后，变为虚继承//此时公共的父类Animal称为虚基类class Sheep : virtual public Animal &#123;&#125;;class Tuo : virtual public Animal &#123;&#125;;class SheepTuo : public Sheep, public Tuo &#123;&#125;;void test01()&#123; SheepTuo st; st.Sheep::m_Age = 100; st.Tuo::m_Age = 200; cout &lt;&lt; \"st.Sheep::m_Age = \" &lt;&lt; st.Sheep::m_Age &lt;&lt; endl; cout &lt;&lt; \"st.Tuo::m_Age = \" &lt;&lt; st.Tuo::m_Age &lt;&lt; endl; cout &lt;&lt; \"st.m_Age = \" &lt;&lt; st.m_Age &lt;&lt; endl;&#125; *tips：采用虚继承解决菱形继承的问题，虚继承的目的是让某个类做出声明，承诺愿意共享它的基类 七、多态 分类： 静态多态：函数重载和运算符重载属于静态多态，复用函数名 动态多态：派生类和虚函数实现运行时多态 区别：静态–函数地址早绑定 - 编译阶段确定函数地址 动态–函数地址晚绑定 - 运行阶段确定函数地址 12345678910111213141516171819202122class Animal&#123;public: virtual void speak()&#123;&#125;//函数前加上virtual关键字，变成虚函数，编译器在编译的时候就不能确定函数调用&#125;;class Cat:public Animal&#123;//继承Animal类public: virtual void speak()&#123;&#125;//Q:这里为virtual为什么可以省略不写&#125;;class Dog:public Animal&#123;public: virtual void speak()&#123;&#125;&#125;;void DoSpeak(Animal &amp; animal)&#123; animal.speak();&#125;int main()&#123; Cat cat; DoSpeak(cat);//传入什么对象，就调用什么对象的寒素 Dog dog; DoSpeak(dog); return 0;&#125; 多态满足条件：1. 有继承关系 2. 子类重写父类中的虚函数 多态使用：父类指针或引用指向子类对象 重写：函数返回值类型 函数名 参数列表 完全一致称为重写 在多态中，通常父类中虚函数饿实现是毫无意义的，主要都是调用子类重写的内容 因此可以将虚函数改为纯虚函数 纯虚函数语法：virtual 返回值类型 函数名 (参数列表) = 0; 当类中有了虚函数（虚构造函数或虚析构函数），这个类也成为抽象类（类中只要有一个纯虚函数就成为抽象类） 抽象类特点： 无法实例化对象 子类必须重写抽象类中的纯虚函数，否则也属于抽象类 Q：多态使用时，子类中开辟属性到堆区（new），父类指针在释放时无法调用子类的析构代码 A：将父类中的析构函数改为虚析构或纯虚析构 虚析构和纯虚析构共性： 可以解决父类指针释放子类对象的问题 都需要有具体的函数实现 虚析构和纯虚析构区别： 纯虚析构，该类属于抽象类，无法实例化对象 虚析构语法：virtual ~类名 () {} 纯虚析构语法：类内 -&gt; virtual ~类名() = 0; 类外 -&gt; 类名::~类名() {} 文件操作C++中对文件操作许哟啊包含头文件&lt;fstream&gt; 文件类型： 文本文件：以ASCII码形式储存在计算机中 二进制文件：以二进制形式存储在计算机中 操作文件的三大类： ofstream：写操作 ifstream：读操作 fstream：读写操作 文本文件 写文件 包含头文件#include&lt;fstream&gt; 创建流对象ofstream ofs; 打开文件ofs.open(&quot;file_path&quot;, way); 写数据ofs&lt;&lt;&quot;writing data&quot;; 关闭文件ofs.close(); 文件打开方式 打开方式 解释 ios::in 为读文件而打开文件 ios::out 为写文件而打开文件 ios::ate 初始位置：文件尾 ios::app 追加方式写文件 ios::trunc 如果文件存在先删除，再创建 ios::binary 二进制方式 文件打开方式可以配合使用，利用|操作符 e.g. 用二进制方式写文件ios::binary|ios::out 读文件 包含头文件#include&lt;fstream&gt; 创建流对象ifstream ifs; 打开文件ifs.open(&quot;file_path&quot;, way);，利用is_open函数可以判断文件是否打开成功 读数据 四种方式 1234char buf[1024] = &#123;0&#125;;while(ifs &gt;&gt; buf)&#123; cout &lt;&lt; buf &lt;&lt; endl;&#125; 1234char buf[1024] = &#123;0&#125;;while(ifs.getline(buf, sizeof(buf)))&#123; cout &lt;&lt; buf &lt;&lt; endl;&#125; 1234string buf;while(getline(ifs, buf))&#123; cout &lt;&lt; buf &lt;&lt; endl;&#125; 1234char c;while((c = ifs.get()) != EOF)&#123; cout &lt;&lt; c;&#125; 关闭文件ifs.close(); 二进制文件打开方式指定为ios::binary 写文件 利用流对象调用成员函数wirte 函数原型 ofstream&amp; write(const char * buffer,int len); 写文件 利用流对象调用成员函数read 函数原型 ifstream&amp; read(char *buffer,int len);","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"Cpp_learningnote3","slug":"Cpp-learning-note-3","date":"2021-03-16T16:00:00.000Z","updated":"2021-03-17T02:45:17.535Z","comments":true,"path":"2021/03/17/Cpp-learning-note-3/","link":"","permalink":"http://yoursite.com/2021/03/17/Cpp-learning-note-3/","excerpt":"","text":"[toc] reference：《黑马》C++系列教程 基础 核心 提高 本篇主要参考提高篇进行记录 模板 模板就是建立通用的模具，提高复用性。模板只是一个框架，不能直接使用 函数模板 C++另一种编程思想称为 泛型编程，主要利用的技术就是模板 C++提供两种模板机制：函数模板 和 类模板 函数模板语法：template&lt;typename T&gt;，其中typename可以用class代替 123456789101112template&lt;typename T&gt;void Swap(T&amp; a,T&amp; b)&#123; T temp = a; a = b; b = temp;&#125;void main()&#123; int a = 10,b = 20; Swap(a, b);//1.自动类型推导 Swap&lt;int&gt;(a, b);//2.显示指定类型 return;&#125; *tips： 自动类型推导，必须推导出一致的数据类型T才可以使用 显示指定类型，必须确定出T的数据类型才可以使用 也就是说，凡是给出了模板定义，之后跟着的函数，必须给出数据类型才能调用。 1234template&lt;typename T&gt;void function()&#123; cout &lt;&lt; \"test\" &lt;&lt; endl;&#125;//函数中没用用到模板类型T，但是调用时必须给出才能使用 普通函数与函数模板的区别 普通函数调用时可以发生自动类型转换（隐式类型转换） 函数模板调用的时候，如果利用自动类型推导，不会发生隐式类型转换 如果利用显式指定类型的方式，可以发生隐式类型转换 普通函数与函数模板的调用规则 如果函数模板和普通函数都可以实现，优先调用普通函数 可以通过空模板参数列表来强制调用函数模板 funtion&lt;&gt;(a, b); 函数模板也可以发生重载 如果函数模板可以产生更好的匹配（例如不用进行隐式转换），优先调用函数模板 模板的局限性：传入数组、类对象、自定义数据类型等数据不能处理，可以为这些特定的类型提供具体化的模板 具体化的模板以template&lt;&gt;开头，通过名称来指出类型，具体化优先于常规模板 1template&lt;&gt; bool compare(Person&amp; p1, Person&amp; p2)&#123; &#125; 类模板 建立一个通用类，类中的成员数据类型可以不具体指定，用一个虚拟的类型来代表 语法： 12template&lt;typename T1， typename T2, ...&gt;class 类模板与函数模板的区别 类模板没有自动类型推导的使用方式 类模板在模板参数列表中可以有默认参数（在显示指定的时候可以更换参数类型，如int-&gt;double） 123456template&lt;class nametype, class agetype = int&gt;//2.defualt parameterclass Person&#123; &#125;void main()&#123; Person &lt;string, double&gt;p('string',10);//1.显示指定&#125; 类模板中的成员函数并不是一开始就创建的，在调用的时候才会创建 类模板对象做函数参数 指定传入的类型 – 直接显示对象的数据类型 1void printPerson1(Person&lt;string, int&gt; &amp;p) 参数模板化 – 将对象中的参数变为模板进行传递 123456template &lt;class T1, class T2&gt;void printPerson2(Person&lt;T1, T2&gt;&amp;p)&#123; p.showPerson(); cout &lt;&lt; \"T1的类型为： \" &lt;&lt; typeid(T1).name() &lt;&lt; endl; cout &lt;&lt; \"T2的类型为： \" &lt;&lt; typeid(T2).name() &lt;&lt; endl;&#125; 整个类模板化 – 将这个对象类型模板化进行传递 123456template&lt;class T&gt;void printPerson3(T &amp; p)&#123; cout &lt;&lt; \"T的类型为： \" &lt;&lt; typeid(T).name() &lt;&lt; endl; p.showPerson();&#125;","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"makefile","slug":"Makefile","date":"2021-03-16T16:00:00.000Z","updated":"2021-03-17T02:46:00.376Z","comments":true,"path":"2021/03/17/Makefile/","link":"","permalink":"http://yoursite.com/2021/03/17/Makefile/","excerpt":"","text":"Makefile_learning 教程：http://c.biancheng.net/makefile/ makefile描述的是文件编译的相关规则，由依赖的关系和执行的命令两部分组成 结构： 12targets: prerequisites command targets：规则的目标，可以是中间文件（*.o），也可以是执行文件（*.elf），还可以是一个标签（clean等） prerequisites：依赖文件，要生成targets需要的文件或目标 command：make需要执行的命令（任意的shell命令） attention：目标和依赖之间要用冒号分隔开，命令的开始一定要使用tab键 makefile的工作流程默认情况下，make执行的是Makefile中的第一规则（Makefile中出现的第一个依赖关系），此规则的第一目标称为“最终目标”，根据依赖关系查找下一条要执行的规则。 这里我们知道，编译时生成的 “.o” 文件。作用是检查某个源文件是不是进行过修改，最终目标文件是不是需要重建。 清除过程文件： 123.PHONY: cleanclean: rm -rf *.0 test Makefile文件所在目录有文件名为clean的文件，命令行“.PHONY: clean”又没添加的话，执行make clean是无效的，“.PHONY: clean”就是保证即使目录下有文件名为clean的文件，也能正常执行make clean 通配符的使用通配符可以出现在模式的规则中，也可以出现在命令中 通配符 使用说明 * 匹配0个或者是任意个字符 ？ 匹配任意一个字符 [] 我们可以指定匹配的字符放在 “[]” 中 % 匹配任意个字符，储存名字在一个列表中，挨个查找 如果我们的通配符使用在依赖的规则中的话一定要注意这个问题：不能通过引用变量的方式来使用，但就是想要通过引用变量的话，我们要使用一个函数 “wildcard”，这个函数在我们引用变量的时候，会帮我们展开 123OBJ = $(wildcard *.c)test: $(OBJ) gcc -o $@ $^ 变量的定义和使用 基本语法VALUE_LIST = one two three 调用变量的时候用$(VALUE_LIST)或${VALUE_LIST}来替换 四种基本赋值方式 简单赋值（:=）只对当前语句的变量有效 递归赋值（=）所有目标变量相关的其他变量都受影响 条件赋值（?=）如果变量未定义，则使用符号中的值（等号后的值）定义变量，如果变量已经赋值，则该赋值语句无效（保持原定义的值） 追加赋值（+=）原变量用空格隔开的方式追加一个新值 makefile自动化变量自动化变量可以理解为由 Makefile 自动产生的变量，自动化变量的取值根据执行的规则来决定，取决于执行规则的目标问价和依赖文件。 自动化变量 说明 $@ 表示规则的目标文件名。如果目标是一个文档文件（Linux 中，一般成 .a 文件为文档文件，也成为静态的库文件）， 那么它代表这个文档的文件名。在多目标模式规则中，它代表的是触发规则被执行的文件名。 $% 当目标文件是一个静态库文件时，代表静态库的一个成员名。 $&lt; 规则的第一个依赖的文件名。如果是一个目标文件使用隐含的规则来重建，则它代表由隐含规则加入的第一个依赖文件。 $? 所有比目标文件更新的依赖文件列表，空格分隔。如果目标文件时静态库文件，代表的是库文件（.o 文件）。 $^ 代表的是所有依赖文件列表，使用空格分隔。如果目标是静态库文件，它所代表的只能是所有的库成员（.o 文件）名。 一个文件可重复的出现在目标的依赖中，变量“$^”只记录它的第一次引用的情况。就是说变量“$^”会去掉重复的依赖文件。 $+ 类似“$^”，但是它保留了依赖文件中重复出现的文件。主要用在程序链接时库的交叉引用场合。 $* 在模式规则和静态模式规则中，代表“茎”。“茎”是目标模式中“%”所代表的部分（当文件名中存在目录时， “茎”也包含目录部分）。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Cpp learning note","slug":"Cpp-learning-note","date":"2020-12-19T09:37:52.000Z","updated":"2020-12-20T03:24:45.453Z","comments":true,"path":"2020/12/19/Cpp-learning-note/","link":"","permalink":"http://yoursite.com/2020/12/19/Cpp-learning-note/","excerpt":"最近因为项目而学习C++ 学习资源：西北工业大学 C++程序设计、青岛大学 面向对象程序设计（C++和Java） 默认参数C++允许在函数定义或声明时，为形参指定默认值，这样的参数称为默认参数。 （1）如果在函数定义时设置了默认参数，那么就不能在函数声明中再次设置，反之亦然。 （2）可以设置多个默认参数，设置的顺序自右向左，即要设置默认值的参数右边的所有参数都必须是默认参数。 12345int volume(int L, int W, int H = 1);int volume(int L = 1, int W = 1, int H = 1);//上面都是正确的int volume(int L = 1, int W, int H);//错误int volume(int L, int W = 1; int H);//错误 （3）默认值可以是常量、全局变量和函数调用（调用实参必须是常量或全局变量的表达式，不可以是局部变量）","text":"最近因为项目而学习C++ 学习资源：西北工业大学 C++程序设计、青岛大学 面向对象程序设计（C++和Java） 默认参数C++允许在函数定义或声明时，为形参指定默认值，这样的参数称为默认参数。 （1）如果在函数定义时设置了默认参数，那么就不能在函数声明中再次设置，反之亦然。 （2）可以设置多个默认参数，设置的顺序自右向左，即要设置默认值的参数右边的所有参数都必须是默认参数。 12345int volume(int L, int W, int H = 1);int volume(int L = 1, int W = 1, int H = 1);//上面都是正确的int volume(int L = 1, int W, int H);//错误int volume(int L, int W = 1; int H);//错误 （3）默认值可以是常量、全局变量和函数调用（调用实参必须是常量或全局变量的表达式，不可以是局部变量） 函数重载function overloading是在同一个域中用同一个函数名来定义多个函数，但是函数参数列表彼此不同（个数不同或参数类型不同） 编译程序将根据实参和形参的类型和个数的最佳匹配来选择调用哪一个函数 数组作为函数的参数如果实参使用数组名，本质上是将这个数组的首地址传递到形参中。数组实参a传递的是数组首地址，形参A定义为数组形式，此时A 的地址与a一样，本质上形参数组A就是实参数组a（内存中两个对象所处位置相同，则实际上它们是同一个对象） 和指针类似，指针传递的也是地址，这样做可以直接改变多个数组元素，而不用返回 数组参数的传递机制 数组作为函数的参数，传递的是数组的地址（数组在内存中是一段区域内连续的） （1）在被调函数中使用形参就是间接使用实参（与变量不同） （2）函数调用时不会为形参数组分配存储空间，即形参数组的长度无实际作用，所以形参数组甚至可不给出长度 （3）函数如何知道数组的长度-&gt;函数调用时再给出一个参数来表示实参数组的长度 （4）多维数组作为函数的参数，形参数组除第一维任意，其他维的长度需要与实参数组相同 字符串C++语言规定字符串是以’\\0’字符作为结束符的字符数组，空字符表示字符串的结束位置 定义字符数组的长度至少为字符串长度加1（空字符占1位） C++在编译时自动在字符串常量后增加一个空字符 123456789//C++中兼容C语言的字符串处理函数的头文件string.hstrcpy(str1, str2);//copystrncpy(str1, str2, n);//copy前n个strcat(str1, str2);//连接strncat(str1, str2, n);//连接前n个strcmp(str1, str2);//比较字符串strlen(str);//lengthatof(\"123.456\");atoi(\"-456\");//string转换成数值函数 字符串对象采用类来实现字符串 123456#include &lt;string&gt;char S1[20];string str1;char S2[20] = \"Java\";//C风格字符串初始化string str2 = \"Java\";//string对象copy初始化string str3(\"Java\");//string对象直接初始化 string对象允许使用+和复合运算符+=实现连接，可以调用其他成员函数来实现字符串处理（与java中的method相同）","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"summary_about_the_half_year","slug":"summary-about-the-half-year","date":"2020-12-05T13:40:35.000Z","updated":"2020-12-05T13:55:33.974Z","comments":true,"path":"2020/12/05/summary-about-the-half-year/","link":"","permalink":"http://yoursite.com/2020/12/05/summary-about-the-half-year/","excerpt":"","text":"20201205-小记不知不觉研一开学有三个月了，自暑假之后再也没碰过blog，总觉得买域名的钱花的有点不值，换电脑后折腾了两个小时把原来的博客都搬到新电脑上面，换了个主题心情大好~。 三个月其实也没有做什么东西，一直在上课和划水。 RTS：李老师的课听得一脸懵…整个人都不太好，还好有万能的同学们一起讨论。也还好它结课了，整个人都轻松了hhh札记可太难了=_= 近期的小目标是学会C++的基本使用和做项目，当然还有考试和作业。 写的好水啊…没有任何干货（这篇后面会删掉吧hhh","categories":[],"tags":[{"name":"about_life","slug":"about-life","permalink":"http://yoursite.com/tags/about-life/"}]},{"title":"bash","slug":"bash notes","date":"2020-08-15T16:00:00.000Z","updated":"2020-08-16T13:47:38.000Z","comments":true,"path":"2020/08/16/bash notes/","link":"","permalink":"http://yoursite.com/2020/08/16/bash notes/","excerpt":"","text":"bash notes reference: https://wangdoc.com/bash/ 基本语法pwd – 显示当前目录 echo 多行加“ ” 输出文本末尾有回车符 -n参数 取消末尾的回车符 -e参数 解释单双引号中的特殊字符(e.g. \\n) type 判断命令的来源 -a参数 查看命令的所有定义 -t参数 返回一个命令的类型：别名（alias），关键词（keyword），函数（function），内置命令（builtin）和文件（file） 快捷键： Ctrl + L：清除屏幕并将当前行移到页面顶部 Ctrl + C：中止当前正在执行的命令 Shift + PageUp：向上滚动 Shift + PageDown：向下滚动 Ctrl + U：从光标位置删除到行首 Ctrl + K：从光标位置删除到行尾 Ctrl + D：关闭 Shell 会话 ↑，↓：浏览已执行命令的历史记录 模式扩展-&gt;简单的正则 shell接收命令，根据空格拆分为一个个词元，然后扩展词元里的特殊字符。 set -f 开启 set +f 关闭 波浪号 自动扩展成当前用户的主目录 ~+ equal to pwsd 问号 代表文件路径中的任意单个字符，不包含空字符 星号 代表文件路径中任意数量的任意字符，包括零个字符，但是不会匹配隐藏文件，如果需要匹配隐藏文件需要写成.* [...] 匹配方括号中的任意一个字符 [!...] or [^...]是非的表达 匹配连字符- 只能放在方括号内部首尾位置 [start-end] {...} 扩展成大括号里的所有值，各个值之间用逗号分隔，逗号前后不能有空格 {start..end} 大括号扩展的简写形式，支持逆序 {start..end..step}中step为步长 变量扩展 e.g. ${SHELL} 子命令扩展 $(…) 可以扩展为另一个命令的运行结果 算数扩展$((…)) 字符类 [[:alnum:]]：匹配任意英文字母与数字 [[:alpha:]]：匹配任意英文字母 [[:blank:]]：空格和 Tab 键 [[:cntrl:]]：ASCII 码 0-31 的不可打印字符 [[:digit:]]：匹配任意数字 0-9 [[:graph:]]：A-Z、a-z、0-9 和标点符号 [[:lower:]]：匹配任意小写字母 a-z [[:print:]]：ASCII 码 32-127 的可打印字符 [[:punct:]]：标点符号（除了 A-Z、a-z、0-9 的可打印字符） [[:space:]]：空格、Tab、LF（10）、VT（11）、FF（12）、CR（13） [[:upper:]]：匹配任意大写字母 A-Z [[:xdigit:]]：16进制字符（A-F、a-f、0-9）","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"YOLOv4","slug":"YOLOv4 - note","date":"2020-04-27T08:03:05.000Z","updated":"2020-04-28T10:51:48.000Z","comments":true,"path":"2020/04/27/YOLOv4 - note/","link":"","permalink":"http://yoursite.com/2020/04/27/YOLOv4 - note/","excerpt":"","text":"YOLOv4 - note arxiv.org/abs/2004.10934 -&gt; translation: https://tongtianta.site/paper/89863 提高accuracy的通用功能：加权残差链接（WRC）、跨阶段部分连接（CSP）、跨小批量标准化（CmBN）、自对抗训练（SAT）、Mish-activation。 本文结合WRC、CSP、CmBN、SAT、Mish-activation、镶嵌数据增强（augmentation mosaic）、DropBlock regularization、CIoU loss bags of freebies数据增强： photomatric distortion-&gt; 调整图像亮度，对比度，色相，饱和度和噪点 geometric distortion -&gt; 随机缩放，裁剪，翻转和旋转 模拟对象遮挡： random erase、CutOut -&gt; 随机选择图像中的矩形区域填充为0的随机或互补值 hide-and-seek、grid mask -&gt; 随机或均匀地选择图像中的多个矩形区域替换为全0 类似概念应用于feature map有：DropOut、DropConnect、DropBlock DIoU考虑了对象中心的距离、CIoU同时考虑了重叠区域 -&gt; 更好的收敛速度和准确性 bags of specialsplugin modules： 增强接收域：SPP、ASPP、RFB 引入注意力机制（channel-wise、point-wise）：Squeeze-and-Excitation(SE)、Spatial Attention Module(SAM) 集成特征：SFAM、ASFF、BiFPN 激活函数：LReLU、PReLU、ReLU6、SELU、Swish、hard-Swish、Mish post-processing：DIoU NMS 架构选择CSPDarknet53、CSPResNext50","categories":[],"tags":[{"name":"毕业设计","slug":"毕业设计","permalink":"http://yoursite.com/tags/毕业设计/"}]},{"title":"tf2.0","slug":"tf2-0","date":"2020-04-05T02:48:29.000Z","updated":"2020-04-09T10:00:52.000Z","comments":true,"path":"2020/04/05/tf2-0/","link":"","permalink":"http://yoursite.com/2020/04/05/tf2-0/","excerpt":"练习代码 pex 基于tensorflow2.0 tensorflow_vs_pytorchtf1.* 静态图 12345678910111213141516171819import tensorflow as tfprint(tf.__version__) # 1.9.0x = tf.Variable(0.)y = tf.Variable(1.)print(x)print(y)# 构建计算图# x = x + yadd_op = x.assign(x +y)# y = y / 2div_op = y.assign(y / 2)with tf.Session() as sess: sess.run(tf.global_variables_initializer()) for i in range(50): sess.run(add_op) sess.run(div_op) print(x.eval()) tf2.* 动态图 -&gt; tf1.x中调用tf.enable_eager_execution()方法打开eager mode 12345678910import tensorflow as tfprint(tf.__version__) # 2.0.0x = tf.constant(0.)y = tf.constant(1.)for i in range(50): x = x + y y = y / 2print(x.numpy()) PyTorch 动态图 123456789import torchprint(torch.__version__) # 1.4.0x = torch.Tensor([0.])y = torch.Tensor([1.])for i in range(50): x = x + y y = y / 2print(x)","text":"练习代码 pex 基于tensorflow2.0 tensorflow_vs_pytorchtf1.* 静态图 12345678910111213141516171819import tensorflow as tfprint(tf.__version__) # 1.9.0x = tf.Variable(0.)y = tf.Variable(1.)print(x)print(y)# 构建计算图# x = x + yadd_op = x.assign(x +y)# y = y / 2div_op = y.assign(y / 2)with tf.Session() as sess: sess.run(tf.global_variables_initializer()) for i in range(50): sess.run(add_op) sess.run(div_op) print(x.eval()) tf2.* 动态图 -&gt; tf1.x中调用tf.enable_eager_execution()方法打开eager mode 12345678910import tensorflow as tfprint(tf.__version__) # 2.0.0x = tf.constant(0.)y = tf.constant(1.)for i in range(50): x = x + y y = y / 2print(x.numpy()) PyTorch 动态图 123456789import torchprint(torch.__version__) # 1.4.0x = torch.Tensor([0.])y = torch.Tensor([1.])for i in range(50): x = x + y y = y / 2print(x) 分类问题与回归问题 分类问题预测的是类别，模型的输出是概率分布 回归问题预测是值，模型的输出是一个实数值 目标函数 ↓ 分类问题–衡量目标类别与当前预测的差距 e.g. 三分类问题，输出：[0.2, 0.7, 0.1] -&gt; 第1类 真实类别第2类 -&gt; one_hot -&gt; [0, 0, 1] one_hot编码，把正整数变为向量表达，生成一个不小于正整数的向量，只有正整数的位置为1，其余位置为0 分类常用损失函数：平方差损失、交叉熵损失 回归问题–预测值与真实值差距 回归常用损失函数：平方差损失、绝对值损失 回调函数tf.keras.callbacks EarlyStopping ModelCheckpoint TensorBoard 在命令行中调用tensorboard：tensorboard –logdir=[你的文件夹名称]","categories":[],"tags":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://yoursite.com/tags/tensorflow/"}]},{"title":"YOLOv3","slug":"YOLOv3","date":"2020-04-01T17:29:04.000Z","updated":"2020-04-04T14:36:14.000Z","comments":true,"path":"2020/04/02/YOLOv3/","link":"","permalink":"http://yoursite.com/2020/04/02/YOLOv3/","excerpt":"","text":"论文地址 YOLOv3结构图 DBL：卷积 + BN(Batch Normalization) + Leaky relu resn：n表示包含的res_unit个数 concat：张量拼接，拼接会扩充张量的维度 backboneDarknet-53没有设置池化层和全连接层，而通过改变卷积核的步长进行张量的尺寸变换，在yolov3中没有最后的全局平均池化层，所以张量变化只考虑5层。 outputy1、y2、y3深度都是255 = 3*（5+80），其中5是bbox的5个参数，80是COCO数据集的类别数。","categories":[],"tags":[{"name":"毕业设计","slug":"毕业设计","permalink":"http://yoursite.com/tags/毕业设计/"}]},{"title":"ResNet","slug":"ResNet","date":"2020-03-18T03:05:41.000Z","updated":"2020-04-04T14:36:10.000Z","comments":true,"path":"2020/03/18/ResNet/","link":"","permalink":"http://yoursite.com/2020/03/18/ResNet/","excerpt":"","text":"残差网路 这是一个两层神经网络。 计算过程从a[l]开始，先进行线性运算。$$z^{[l+1] }= W^{[l+1]}a^{[l]} + b^{[l+1]}$$在由激活函数g得到a[l+1]，这里g是线性整流函数relu$$a^{[l+1]} = g(z^{[l+1]})$$随后进行第二层线性运算$$z^{[l+2]} = W^{[l+2]}a^{[l+1]} + b^{[l+2]}$$再经过Relu$$a^{[l+2]} = g(z^{[l+2]})$$在残差网络中加入一点变化 即”跳远连接”$$a^{[l+2]} = g(z^{[l+2]} + a^{[l]})$$这样，随着网络的加深，训练误差也跟着下降。","categories":[],"tags":[{"name":"deeplearning","slug":"deeplearning","permalink":"http://yoursite.com/tags/deeplearning/"}]},{"title":"Linux指令","slug":"Linux指令","date":"2020-03-17T07:09:23.000Z","updated":"2020-04-01T17:33:20.000Z","comments":true,"path":"2020/03/17/Linux指令/","link":"","permalink":"http://yoursite.com/2020/03/17/Linux指令/","excerpt":"","text":"https://www.jianshu.com/nb/37698552 https://www.jianshu.com/p/8c2af151ddc2 https://www.runoob.com/linux/linux-shell.html linux命令大全","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"VID","slug":"VID","date":"2020-03-15T12:53:26.000Z","updated":"2020-03-16T14:44:00.000Z","comments":true,"path":"2020/03/15/VID/","link":"","permalink":"http://yoursite.com/2020/03/15/VID/","excerpt":"reference paper： 陈志欣. 基于深度学习的视频目标检测算法研究与应用[D].北方工业大学,2019. 视频目标检测（object detection from video） 从2015年开始，ILSVRC新增了VID挑战任务，视频中的目标检测难题：更多的帧图像文件、由于速度快导致运动模糊和光照等问题、物体间的遮挡问题。 数据集预处理 归一化：将原始像素压缩到[0,1]区间 $$\\text { norm }=\\frac{x_{i}-\\min (x)}{\\max (x)-\\min (x)}$$ 去均值化：对每个通道，移除图像的平均亮度，凸显个体差异 $$x_{r}, x_{g}, x_{b}=\\left(x_{r}-R_{m e a n}, x_{g}-G_{m e a n}, x_{b}-B_{m e a n}\\right)$$ 标准化：使像素符合标准正态分布，在样本尺度不一致的情况下（如不同相机采集的图片，或者是来源不同的图片） $$x^{\\prime}=\\frac{x-\\mu}{\\sigma}$$","text":"reference paper： 陈志欣. 基于深度学习的视频目标检测算法研究与应用[D].北方工业大学,2019. 视频目标检测（object detection from video） 从2015年开始，ILSVRC新增了VID挑战任务，视频中的目标检测难题：更多的帧图像文件、由于速度快导致运动模糊和光照等问题、物体间的遮挡问题。 数据集预处理 归一化：将原始像素压缩到[0,1]区间 $$\\text { norm }=\\frac{x_{i}-\\min (x)}{\\max (x)-\\min (x)}$$ 去均值化：对每个通道，移除图像的平均亮度，凸显个体差异 $$x_{r}, x_{g}, x_{b}=\\left(x_{r}-R_{m e a n}, x_{g}-G_{m e a n}, x_{b}-B_{m e a n}\\right)$$ 标准化：使像素符合标准正态分布，在样本尺度不一致的情况下（如不同相机采集的图片，或者是来源不同的图片） $$x^{\\prime}=\\frac{x-\\mu}{\\sigma}$$ 数据增强：解决样本数量和质量不满足需求的问题 镜像翻转、随机旋转、随机错切、高斯噪声、椒盐噪声、明亮度变化（不加入影响图像本质特性的噪声） 性能指标 mAP、IoU、FPS、NMS 可变形卷积（Deformable Convolution）-&gt; 了解卷积的多种方式 refer to https://arxiv.org/pdf/1703.06211.pdf 对小目标物体的检测 数据增强：用不同尺度的图片进行训练 × SPP 空间池化金字塔 × SSD 在不同尺度的特征图上引入区域检测机制 （提高有限） × FPN网络 自下而上的前馈计算（池化采样），自下而上的特征融合与横向连接（最近邻上采样或双线性插值），横向对应的层特征图各像素点之间直接相加，融合后的特征还要进行3*3卷积以消除upsampling产生的混叠作用。 网络的训练损失函数 这一块真的看的我眼花… 回归损失 均方误差/平方损失/L2 损失：$$M S E=\\frac{\\sum_{i=1}^{n}\\left(y_{i}-\\hat{y}_{i}\\right)^{2}}{n}$$平均绝对误差/L1 损失： $$M A E=\\frac{\\sum_{i=1}^{n}\\left|y_{i}-\\hat{y}_{i}\\right|}{n}$$ 平均偏差误差（mean bias error）： $$M B E=\\frac{\\sum_{i=1}^{n}\\left(y_{i}-\\hat{y}_{i}\\right)}{n}$$ 分类损失 Hinge Loss/多分类 SVM 损失： $$S V M L o s s=\\sum_{j \\neq y_{i}} \\max \\left(0, s_{j}-s_{y_{i}}+1\\right)$$ 交叉熵损失/负对数似然： $$CrossEntropyLoss = -\\left( y_{i} \\log \\left( \\hat{y} _ {i} \\right) + \\left( 1-y _ {i} \\right) \\log \\left(1- \\hat{y}_{i} \\right) \\right)$$剩余词条待补充：multi-task loss、facol loss、GIoU、DIoU refer to：https://zhuanlan.zhihu.com/p/112057799 YOLOv3中用k-means聚类得到anchor大小和数量设置 VID流程 Image_Feature = N_feat(Image_input) -&gt; Output = N_det(Image_Feature)提取候选框进行分类回归 Deap Feature Flow利用一种基于卷积操作的FlowNet生成前后帧的光流图，再叠加上前一时刻关键帧信息，生成本时刻关键帧最终的特征图。 FGFA将相邻帧在时序上的特征聚合到当前帧的特征中，处理运动模糊、视频散焦、奇特姿势等问题。 稀疏特征传播方式提高检测速度 DFF 每隔n张（n常取10）抽取一个关键帧得到特征图，非关键帧的特征图计算为最近邻关键帧以及其与当前非关键帧之间运动变化矢量的加和。通常用光流矢量定量计算临近两帧之间的信息差值。 -&gt; FlowNet如何实现 密集特征聚合方式提高检测精度 FGFA 需要计算视频每一帧的特征图，对视频的第i个时刻的关键帧，给每个时间帧分配一定权重系数，来对前后i+2r个特征图对应位置的值加权求和。 -&gt; 权重如何分配 关键帧的选择优化 基于特征一致性的关键帧调度策略： $$key = is_{-}key \\left( B_{k \\rightarrow i} \\right)$$ $$i s_{k e y}\\left(Q_{k \\rightarrow i}\\right) = \\left [ \\frac{1}{N_{p}} \\sum_{p} 1 \\left ( B_{k \\rightarrow i}(p) \\leq \\tau \\right ) \\right ] &gt; \\gamma$$前后两个参数分别设置为0.1 和 0.2 FlowNetSimple作为光流计算网络 设计Tubelet结构存放低检测关键帧前后r帧信息，做密特征聚合使用，优化此关键帧的检测精度。","categories":[],"tags":[{"name":"cv","slug":"cv","permalink":"http://yoursite.com/tags/cv/"}]},{"title":"Anaconda使用tips","slug":"Anaconda使用tips","date":"2020-03-13T11:57:12.000Z","updated":"2020-03-13T12:59:02.000Z","comments":true,"path":"2020/03/13/Anaconda使用tips/","link":"","permalink":"http://yoursite.com/2020/03/13/Anaconda使用tips/","excerpt":"","text":"今天为了安装tensorflow踩了不少坑🤢，主要是anaconda环境安装的问题，写点笔记记下来 新建一个虚拟环境 conda create -n 环境名 python=3.7 （版本自己选择），创建的环境在./envs文件夹下。 conda activate 环境名 激活 conda deactivate 关闭回到base环境 conda remove -n 环境名 –all 删除已有环境 conda list 查看已安装package 换源就不说了，注意在修改.condarc文件时如果运行报错，把里面的https改为http即可。 因为直接使用conda下载速度太慢，所以选择离线安装。首先在清华镜像源下载tensorflow和opencv，选择对应平台和python版本的.whl文件，放在./Lib/site-packages/文件夹下。cd到当前目录，pip install xxxx.whl安装即可。如果出现报错无法定位程序输入点的问题把Anaconda3/DLLS下libssl-1_1-x64.dll文件到覆盖Anaconda3/Library/bin中，一路yes就可以完成安装。安错版本pip uninstall tensorflow卸载 在选择tensorflow版本的时候，注意自己的电脑是否支持当前版本。 reference： 无法定位程序输入点 tf2.0安装 版本选择","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"DL_tools","slug":"DL-tools","date":"2020-03-12T08:50:55.000Z","updated":"2020-03-12T09:13:58.000Z","comments":true,"path":"2020/03/12/DL-tools/","link":"","permalink":"http://yoursite.com/2020/03/12/DL-tools/","excerpt":"","text":"一些深度学习框架 Caffe：代码基于C++（训练速度快），入门级、上手快（修改一些配置文件即可），适合新手了解深度学习任务中的各种参数； Keras：基于Theano或TensorFlow的高级框架，可快速构建网络，不用了解网络的底层设计； TensorFlow：有高级的API（tf.Keras等），也可以自己从零开始构建一个新的网络，但是1.x版本静态图问题不好调试，2.0貌似解决了这个问题（尝试使用这个做毕设，不知道学长用的是哪个）； Pytorch：科研人员都说好用的框架，上手快、好搭建，但是工业上采用tensorflow更多。","categories":[],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://yoursite.com/tags/深度学习/"}]},{"title":"CNN","slug":"CNN","date":"2020-03-06T13:23:00.000Z","updated":"2020-03-06T13:42:58.000Z","comments":true,"path":"2020/03/06/CNN/","link":"","permalink":"http://yoursite.com/2020/03/06/CNN/","excerpt":"","text":"Convolutional Neural Network1. 输入层原始图片，在计算机内用构成像素点的多维矩阵来表示。 2. 隐层convolution卷积：过滤特征 ReLU线性修正单元：激活函数 polling池化：降低维度并提高模型的容错性 降低模型的参数数目 局部感知野：每个神经元只需要对局部图像进行感知，然后在更高层将局部的信息综合起来得到全局的信息； 权值共享：对于每一层来讲，所有神经元对应的权值参数是一样的，同一层下的神经元连接参数只与特征提取的方式有关，而与具体的位置无关。 第一层隐层一般是用来做边缘和曲线检测 第二层隐层对第一层学到的边缘曲线组合得到的一些特征 第三层则会学到一些更复杂的特征 ReLU激活函数 引入非线性激励函数，深层网络具有意义（不再是输入的线性组合，可以逼近任意函数） 为什么采用ReLU函数：1. 采用sigmoid等函数，计算量大，反向传播求误差梯度时涉及除法；2. 对于深层网络，sigmoid函数反向传播时，容易出现梯度消失的情况（sigmoid接近饱和区时，变换太缓慢，导数趋于0，容易造成信息丢失），从而无法完成深层网络的训练；3. ReLU会使一部分神经元的输出为0，造成了网络的稀疏性，并减少了参数的相互依存关系，缓解了过拟合问题的发生。 pooling池化（欠采样） 主要有max、average、sum等不同类型的操作 3. 输出层经过若干次的卷积+线性修真+pooling，模型会将学到的高水平特征接到一个全连接层，通过softmax函数得到输出。","categories":[],"tags":[{"name":"NN","slug":"NN","permalink":"http://yoursite.com/tags/NN/"}]},{"title":"TexLive_installation","slug":"TexLive-installation","date":"2019-07-11T08:02:40.000Z","updated":"2019-08-18T07:19:16.000Z","comments":true,"path":"2019/07/11/TexLive-installation/","link":"","permalink":"http://yoursite.com/2019/07/11/TexLive-installation/","excerpt":"TexLive + VScode 搭建LaTex编译环境最近对LaTex十分感兴趣（因为好看），百度了很多教程，最后决定在VScode上配置环境。","text":"TexLive + VScode 搭建LaTex编译环境最近对LaTex十分感兴趣（因为好看），百度了很多教程，最后决定在VScode上配置环境。 下载TexLive镜像文件(清华大学镜像)，选择texlive2019.iso下载即可； iso文件解压后，在文件夹中点击install-tl-advanced.bat或install-tl-windows.bat文件均可，其中可进行一些安装地址和组件的配置，安装时间较长； 在VScode中安装插件：LaTex language support, LaTex Workshop 对latex编译环境进行配置：在设置中搜索latex，对setting.json进行编辑，加入以下代码段： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&quot;latex-workshop.latex.tools&quot;: [ &#123; &quot;name&quot;: &quot;latexmk&quot;, &quot;command&quot;: &quot;latexmk&quot;, &quot;args&quot;: [ &quot;-synctex=1&quot;, &quot;-interaction=nonstopmode&quot;, &quot;-file-line-error&quot;, &quot;-pdf&quot;, &quot;%DOC%&quot; ] &#125;, &#123; &quot;name&quot;: &quot;xelatex&quot;, &quot;command&quot;: &quot;xelatex&quot;, &quot;args&quot;: [ &quot;-synctex=1&quot;, &quot;-interaction=nonstopmode&quot;, &quot;-file-line-error&quot;, &quot;%DOC%&quot; ] &#125;, &#123; &quot;name&quot;: &quot;pdflatex&quot;, &quot;command&quot;: &quot;pdflatex&quot;, &quot;args&quot;: [ &quot;-synctex=1&quot;, &quot;-interaction=nonstopmode&quot;, &quot;-file-line-error&quot;, &quot;%DOC%&quot; ] &#125;, &#123; &quot;name&quot;: &quot;bibtex&quot;, &quot;command&quot;: &quot;bibtex&quot;, &quot;args&quot;: [ &quot;%DOCFILE%&quot; ] &#125; ], &quot;latex-workshop.latex.recipes&quot;: [ &#123; &quot;name&quot;: &quot;xelatex&quot;, &quot;tools&quot;: [ &quot;xelatex&quot; ] &#125;, &#123; &quot;name&quot;: &quot;pdflatex&quot;, &quot;tools&quot;: [ &quot;pdflatex&quot; ] &#125;, &#123; &quot;name&quot;: &quot;latexmk&quot;, &quot;tools&quot;: [ &quot;latexmk&quot; ] &#125;, &#123; &quot;name&quot;: &quot;pdflatex -&gt; bibtex -&gt; pdflatex*2&quot;, &quot;tools&quot;: [ &quot;pdflatex&quot;, &quot;bibtex&quot;, &quot;pdflatex&quot;, &quot;pdflatex&quot; ] &#125; ], &quot;latex-workshop.view.pdf.viewer&quot;: &quot;tab&quot;, &quot;latex-workshop.latex.clean.subfolder.enabled&quot;: true //这里要选择true清除编译过程中产生的文件 创建文件test.tex，Ctrl+S保存编译，得到PDF文件。 123456789101112\\documentclass[UTF8]&#123;ctexart&#125; \\title&#123;TexLive + VScode 环境配置&#125; \\author&#123;Silhouettes&#125; \\date&#123;\\today&#125; \\begin&#123;document&#125; \\maketitle This is the beginning of the article.\\\\ 编译成功！\\\\ $ &#123;f&#125;&apos;(0) = \\left. \\frac&#123;df&#125;&#123;dx&#125; \\right|_&#123;x=0&#125; $\\end&#123;document&#125; 这里要注意tex文件要按utf-8编码，如果编译后出现乱码，可以更换编码方式重新保存后再编译一次。","categories":[],"tags":[{"name":"LaTex","slug":"LaTex","permalink":"http://yoursite.com/tags/LaTex/"}]},{"title":"latex2word","slug":"latex2word","date":"2019-07-06T10:21:19.000Z","updated":"2019-08-18T07:20:10.000Z","comments":true,"path":"2019/07/06/latex2word/","link":"","permalink":"http://yoursite.com/2019/07/06/latex2word/","excerpt":"","text":"latex2word突然想，能不能把在latex上生成的数学公式导入word里面，因为word自带的公式编辑器确实不是很好用，相较之下latex生成的公式十分精致。 搜到了很多教程，挑了我觉得最方便的一种： 先用Mathpix把需要的公式截图翻译成latex语言，再copy到Online LaTeX Equation Editor网站，在MathJax框右键Show Math As项MathML Code选项，在word中 Alt 加 = 快捷键生成一个公式文本框将前面弹出界面的代码全部复制粘贴即可。 当然这是一种偷懒的方法，在Word2016中的公式编辑器中已经支持了一部分的LaTeX语法（比如\\partial、\\sum等等），可以很方便地输入一些简单的公式。 这个方法主要是用来抄理论的时候快速打出公式用的（不是。 /暑假愉快","categories":[],"tags":[{"name":"daily","slug":"daily","permalink":"http://yoursite.com/tags/daily/"}]},{"title":"tensorflow_learning_2","slug":"tensorflow-learning-2","date":"2019-05-20T11:53:43.000Z","updated":"2019-05-20T13:57:36.000Z","comments":true,"path":"2019/05/20/tensorflow-learning-2/","link":"","permalink":"http://yoursite.com/2019/05/20/tensorflow-learning-2/","excerpt":"","text":"tensorflow学习笔记_2计算图与张量TensorFlow中的计算可以表示为一个有向图（计算图），其中每一个运算操作作为一个节点，节点与节点的连接称为边，一张计算图描述了数据的计算流程，我们可以对计算图上的各个分支进行改变来达到我们的运算目的。在计算图的边中流动的数据被称为张量（tensor），张量的数据类型可以事先定义，也可以通过计算图的结构推导得出。 一个运算操作代表了一类抽象运算（如矩阵乘法或向量加法），运算操作必须有自己的属性，但是所有属性都必须被预先设置，或者在计算图沿着边运行时可以被推断出来。 会话 Sessionsession是用户使用tensorflow的互交式接口，用户可以通过session的Extend方法添加新的节点和边来创建计算图，然后通过session的Run方法执行计算图。 大多数运算中，tensor不会一直保留下去。而Variable是一类特殊的运算操作，可以将一些需要保留的tensor储存在内存或者显存当中。每执行一次计算图后，Variable中的tensor都会被保存，同时在计算过程中，tensor的值也可以被更新。 csdn上还是有很多的教程 概念理解 MNIST手写数字识别1234567from tensorflow.examples.tutorials.mnist import input_dataimport tensorflow as tfmnist = input_data.read_data_sets(\"MNIST_data/\", one_hot=True)print(mnist.train.images.shape,mnist.train.labels.shape)print(mnist.test.images.shape,mnist.test.labels.shape)print(mnist.validation.images.shape,mnist.validation.labels.shape) 结果输出为 (55000, 784) (55000, 10)(10000, 784) (10000, 10)(5000, 784) (5000, 10) 一个例程 存","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/机器学习/"}],"tags":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://yoursite.com/tags/tensorflow/"}]},{"title":"tensorflow_learning_1","slug":"tensorflow-learning-1","date":"2019-05-19T09:40:58.000Z","updated":"2019-05-20T13:23:06.000Z","comments":true,"path":"2019/05/19/tensorflow-learning-1/","link":"","permalink":"http://yoursite.com/2019/05/19/tensorflow-learning-1/","excerpt":"","text":"tensorflow学习笔记_1环境安装 CPU版本的tensorflow 安装anaconda或者miniconda 这里附上 一个很完整的参考教程，因为我的anaconda安装了python3.7，而3.5对tensorflow的兼容性最好（听说，所以在anaconda中新建一个环境安装python3.5和tensorflow1.13.1。 首先 conda creat -n tensorflow python=3.5 新建一个环境名字为tensorflow，然后发现Anaconda3/envs/目录下出现了tensorflow的文件夹。 激活环境 activate tensorflow，关闭这个环境用命令 deactivate 安装tensorflow conda install tensorflow conda安装比pip要方便不少，而且conda安装的tf效率要比pip安装的高。 验证是否安装成功 1234import tensorflow as tfhello = tf.constant('Hello,tensorflow')sess = tf.Session()print(sess.run(hello)) 报错的话加上这段话 12import os os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2' tips：上面的方法将tensorflow安装在一个单独的环境当中，其他模块如numpy、opencv等都要重新配置，尝试将/Anaconda3/envs/tensorflow文件夹全部复制到/Anaconda3/Lib/site-packages下运行（参考了一篇安装在linux上的文章，结果不是很理想，放弃。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/机器学习/"}],"tags":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://yoursite.com/tags/tensorflow/"}]},{"title":"CDN_jsdelivr","slug":"CDN-jsdelivr","date":"2019-05-06T05:08:48.000Z","updated":"2019-05-08T10:31:30.000Z","comments":true,"path":"2019/05/06/CDN-jsdelivr/","link":"","permalink":"http://yoursite.com/2019/05/06/CDN-jsdelivr/","excerpt":"blog引用资源路径由本地替换为CDN 内容分发网络（Content Delivery Network），依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。 由于GitHub资源在国内加载过慢，有很多人选择通过CDN来提高资源加载速度，我选择了免费、速度快的jsdelivr，CDN的本质是缓存。","text":"blog引用资源路径由本地替换为CDN 内容分发网络（Content Delivery Network），依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。 由于GitHub资源在国内加载过慢，有很多人选择通过CDN来提高资源加载速度，我选择了免费、速度快的jsdelivr，CDN的本质是缓存。 1. 在GitHub上Create a new repository得到repository name 2. clone 这个仓库到本地在文件夹下git bash here 1git clone 你的仓库地址 3. 上传资源1234git status # 查看仓库状态git add . # 所有文件添加至缓存区git commit -m &quot;your_commit&quot;git push # 推送至远端仓库 4. 发布仓库点击releases，版本号自定义 5. 引用资源通过路径： 12https://cdn.jsdelivr.net/gh/user/repo@version/filehttps://cdn.jsdelivr.net/gh/你的github用户名/你的仓库名@发布的版本号/文件路径 可以CDN引用资源啦~","categories":[{"name":"HEXO搭建","slug":"HEXO搭建","permalink":"http://yoursite.com/categories/HEXO搭建/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"CDN","slug":"CDN","permalink":"http://yoursite.com/tags/CDN/"}]},{"title":"some_thoughts","slug":"some-thoughts","date":"2019-05-03T16:36:43.000Z","updated":"2019-05-08T14:36:42.000Z","comments":true,"path":"2019/05/04/some-thoughts/","link":"","permalink":"http://yoursite.com/2019/05/04/some-thoughts/","excerpt":"some_thoughts晚上花了一个小时修改了blog的主题，最近电脑看吐，又想一个星期不开电脑，日子会是多么快活。又后悔当初为什么不去学文科kkk… 找了很久才发现，自上次更新了主题后，默认使用cdn加载css，注释掉才会使用本地less文件进行渲染（看到Github上有人跟我遇到了一样的问题hhh，不知道他解决了没有）","text":"some_thoughts晚上花了一个小时修改了blog的主题，最近电脑看吐，又想一个星期不开电脑，日子会是多么快活。又后悔当初为什么不去学文科kkk… 找了很久才发现，自上次更新了主题后，默认使用cdn加载css，注释掉才会使用本地less文件进行渲染（看到Github上有人跟我遇到了一样的问题hhh，不知道他解决了没有） 最近有一个关于朋友的胡思乱想 有兴趣就看看吧 另，Trpora实在是太好用了不得不推荐一下 评论区欢迎留言","categories":[{"name":"HEXO搭建","slug":"HEXO搭建","permalink":"http://yoursite.com/categories/HEXO搭建/"}],"tags":[{"name":"daily","slug":"daily","permalink":"http://yoursite.com/tags/daily/"},{"name":"胡思乱想","slug":"胡思乱想","permalink":"http://yoursite.com/tags/胡思乱想/"}]},{"title":"import_pdb","slug":"import-pdb","date":"2019-03-30T14:58:26.000Z","updated":"2019-05-08T10:31:42.000Z","comments":true,"path":"2019/03/30/import-pdb/","link":"","permalink":"http://yoursite.com/2019/03/30/import-pdb/","excerpt":"pdb – the python debugger最近在python学习中用到了pdb调试模块（在没有IDE的情况下debug应该特别好用）,做一点笔记： 首先, import pdb, 在需要调试的地方设置断点 pdb.set_trace(), 执行程序进入断点。","text":"pdb – the python debugger最近在python学习中用到了pdb调试模块（在没有IDE的情况下debug应该特别好用）,做一点笔记： 首先, import pdb, 在需要调试的地方设置断点 pdb.set_trace(), 执行程序进入断点。 常用命令 命令 功能 next(n) 执行下一行 exit(q) 中止调试并退出 continue(c) 停止debug继续执行程序 where(w) 找出当前代码的运行位置 list(l) 显示当前行的代码段 print(p) 打印变量的值 step(s) 进入函数 return(r) 执行代码直到当前函数返回(return) help 帮助 参考python pdb模块 官方文档 版本：3.7 The module pdb defines an interactive source code debugger for Python programs. It supports setting (conditional) breakpoints and single stepping at the source line level, inspection of stack frames, source code listing, and evaluation of arbitrary Python code in the context of any stack frame. It also supports post-mortem debugging and can be called under program control.","categories":[{"name":"Python学习","slug":"Python学习","permalink":"http://yoursite.com/categories/Python学习/"}],"tags":[{"name":"learning","slug":"learning","permalink":"http://yoursite.com/tags/learning/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"About_https","slug":"About-https","date":"2019-03-21T04:20:34.000Z","updated":"2019-05-08T10:31:44.000Z","comments":true,"path":"2019/03/21/About-https/","link":"","permalink":"http://yoursite.com/2019/03/21/About-https/","excerpt":"","text":"Cloudflare给域名加个s Here at Cloudflare, we make the Internet work the way it should. Offering CDN, DNS, DDoS protection and security, find out how we can help your site. 上完课回宿舍看到一篇博主的推送要给自己的个人网站加个s，所以我决定也给自己的blog加个s。 超文本传输协议HTTP以明文的方式发送信息，而安全套接字层超文本传输协议HTTPS在HTTP的基础上加入了SSL协议，对传输的信息进行了加密，提高了安全性。 有两种方法，一是用Cloudflare提供的免费https服务，二是在阿里云免费申请一个一年的免费证书，我选择了前者： 在Cloudflare上注册一个账号; Add websites：输入自己的域名; Add DNS Records：Cloudflare会将扫描到的DNS记录展示在页面上，如果记录符合Cloudflare的要求，会在记录的Status中显示一个橙色的云在箭头上的图标，如果没有则需要自己添加需要的DNS记录; Select Plan：Free website，可以免费使用; Update Nameservers：Cloudflare提供了新的DNS服务器地址，在域名注册商(我用了阿里云）的域名设置中将之前的DNS服务器地址替换掉即可,等待一段时间后域名映射在服务器上; Enable Https：在Crypto中设置 SSL 为 Flexible，Always Use HTTPS 选项为on(将http都重定向为https); Create Pages Rules：Page Rules中设置路由规则，输入 username.top/*(即你的域名)，网站上的解释很清楚，结束。 等待一段时间就可以看到自己的域名前面出现了https啦~","categories":[{"name":"HEXO搭建","slug":"HEXO搭建","permalink":"http://yoursite.com/categories/HEXO搭建/"}],"tags":[{"name":"learning","slug":"learning","permalink":"http://yoursite.com/tags/learning/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"a_tool","slug":"a-tool","date":"2019-03-15T15:47:59.000Z","updated":"2019-05-04T04:22:38.000Z","comments":true,"path":"2019/03/15/a-tool/","link":"","permalink":"http://yoursite.com/2019/03/15/a-tool/","excerpt":"","text":"深夜的发现围观了大佬的公众号，想从github上面把代码下载下来学习一下,但是遇到了要把一整个仓库的文件都clone下来的问题…于是百度了下载指定文件夹下文件的做法，发现最简单的方法是把链接直接复制在Downgit网站上(这里附上MinhasKamal/DownGit的网址: DownGit)，下载即可。但是又遇到了网站加载不出来的问题，最后发现了另一个大佬移植的网站，尽管这个网址的资源加载也有问题，但是总的来说还可以用，就是等待时间可能会比较长，给人的感觉是这个网站也不能用(嗯？？我折腾了这么久还是不能用？？)，看样子已经是很久没有人维护了…网址如下: 周大侠啊DownGit安了pygame模块就可以愉快地玩游戏啦~另，最近觉得很有意思的表情包上面的梗，以及附上新的md语法介绍：MarkDown基本语法12345public static void main(String[] args)&#123; String s=\"\\u4f18\\u79c0\"; System.out.println(s);&#125;","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"update","slug":"update","date":"2019-03-01T12:38:21.000Z","updated":"2019-05-08T10:28:02.000Z","comments":true,"path":"2019/03/01/update/","link":"","permalink":"http://yoursite.com/2019/03/01/update/","excerpt":"","text":"注册了域名解析到博客网址上面 开学一周四节课正是很闲的时候其实是闲得无聊又不想学习，花时间把这个博客搭好了，感觉像学cadence和mul一样…熟能生巧吧。 阿里云据说比腾讯云更安全一点，但是价格上感觉两家差不多。 另，找了一篇Markdown基本语法的介绍，如下：Markdown","categories":[{"name":"HEXO搭建","slug":"HEXO搭建","permalink":"http://yoursite.com/categories/HEXO搭建/"}],"tags":[{"name":"daily","slug":"daily","permalink":"http://yoursite.com/tags/daily/"}]},{"title":"my_first_blog","slug":"my-first-blog","date":"2019-03-01T08:37:32.000Z","updated":"2020-12-05T13:42:12.033Z","comments":true,"path":"2019/03/01/my-first-blog/","link":"","permalink":"http://yoursite.com/2019/03/01/my-first-blog/","excerpt":"写在开头 花了半个下午的时间弥补了上个学期搞不定hexo的遗憾，现在依旧不太清楚node出了什么问题npm的时候总是报错(WARN，不过总算是能发布到github上面了。暂时没有注册域名的打算。","text":"写在开头 花了半个下午的时间弥补了上个学期搞不定hexo的遗憾，现在依旧不太清楚node出了什么问题npm的时候总是报错(WARN，不过总算是能发布到github上面了。暂时没有注册域名的打算。 看了很多blog觉得这篇很有用：hexo + github搭建个人blog","categories":[{"name":"HEXO搭建","slug":"HEXO搭建","permalink":"http://yoursite.com/categories/HEXO搭建/"}],"tags":[{"name":"daily","slug":"daily","permalink":"http://yoursite.com/tags/daily/"}]}],"categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/机器学习/"},{"name":"HEXO搭建","slug":"HEXO搭建","permalink":"http://yoursite.com/categories/HEXO搭建/"},{"name":"Python学习","slug":"Python学习","permalink":"http://yoursite.com/categories/Python学习/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"about_life","slug":"about-life","permalink":"http://yoursite.com/tags/about-life/"},{"name":"毕业设计","slug":"毕业设计","permalink":"http://yoursite.com/tags/毕业设计/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://yoursite.com/tags/tensorflow/"},{"name":"deeplearning","slug":"deeplearning","permalink":"http://yoursite.com/tags/deeplearning/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"cv","slug":"cv","permalink":"http://yoursite.com/tags/cv/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"深度学习","slug":"深度学习","permalink":"http://yoursite.com/tags/深度学习/"},{"name":"NN","slug":"NN","permalink":"http://yoursite.com/tags/NN/"},{"name":"LaTex","slug":"LaTex","permalink":"http://yoursite.com/tags/LaTex/"},{"name":"daily","slug":"daily","permalink":"http://yoursite.com/tags/daily/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"CDN","slug":"CDN","permalink":"http://yoursite.com/tags/CDN/"},{"name":"胡思乱想","slug":"胡思乱想","permalink":"http://yoursite.com/tags/胡思乱想/"},{"name":"learning","slug":"learning","permalink":"http://yoursite.com/tags/learning/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]}