{"meta":{"title":"sl's learning notes","subtitle":null,"description":"just record","author":"_Silhouttes","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2020-11-22T14:54:32.051Z","updated":"2019-04-06T18:44:06.000Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404 Not Found很抱歉，您访问的页面不存在可能是输入地址有误或该地址已被删除"},{"title":"Tag","date":"2020-12-05T10:21:36.571Z","updated":"2020-12-05T10:21:36.571Z","comments":true,"path":"tag/index.html","permalink":"http://yoursite.com/tag/index.html","excerpt":"","text":""},{"title":"About","date":"2020-03-11T14:25:44.000Z","updated":"2020-12-05T10:25:54.625Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"About_me major : EE NUAA undergraduate/BUAA postgraduate idol : kkura qq : 1519088021（_Silhouettes) mail : loch_wjj@163.com"},{"title":"","date":"2020-12-05T10:26:50.723Z","updated":"2020-12-05T10:26:50.723Z","comments":true,"path":"some_webs/COUNT_DOWN.html","permalink":"http://yoursite.com/some_webs/COUNT_DOWN.html","excerpt":"","text":"COUNT DOWN function Timer(year,month,day,hour,minute,second){ var leftTime = (new Date(year,month-1,day,hour,minute,second)) - (new Date()); var days = parseInt(leftTime / 1000 / 60 / 60 / 24 , 10); var hours = parseInt(leftTime / 1000 / 60 / 60 % 24 , 10); var minutes = parseInt(leftTime / 1000 / 60 % 60, 10); var seconds = parseInt(leftTime / 1000 % 60, 10); days = checkTime(days); hours = checkTime(hours); minutes = checkTime(minutes); seconds = checkTime(seconds); setInterval(\"Timer(2021,1,18,00,00,00)\",1000); // console.log(days); if (isNaN(days)) { } else{ document.getElementById(\"timer\").innerHTML = days+\"天\" + hours+\"小时\" + minutes+\"分\"+seconds+\"秒\"; } } function checkTime(i){ //0-9的前面加上“0” if(i"},{"title":"Category","date":"2020-12-05T10:17:34.925Z","updated":"2020-12-05T10:17:34.925Z","comments":true,"path":"category/index.html","permalink":"http://yoursite.com/category/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-11-22T14:54:32.278Z","updated":"2020-01-14T10:46:56.000Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":"jiji的blog"}],"posts":[{"title":"Cpp-learning-note-4","slug":"Cpp-learning-note-4","date":"2021-07-04T05:04:35.000Z","updated":"2021-07-04T13:26:08.907Z","comments":true,"path":"2021/07/04/Cpp-learning-note-4/","link":"","permalink":"http://yoursite.com/2021/07/04/Cpp-learning-note-4/","excerpt":"","text":"[toc] STL-函数对象函数对象 概念：重载函数调用操作符的类，其对象称为函数对象；函数对象使用重载的()时，行为类似函数调用，也叫仿函数。 本质：函数对象（仿函数）是一个类，不是一个函数。 函数对象的使用： 可以像普通函数那样调用，可以有参数，可以有返回值 函数对象超出普通函数的概念，函数对象可以有自己的状态 函数对象可以作为参数传递（也可以传递匿名对象） 谓词 A predicate is a function that returns bool (or something that can be implicitly converted to bool). Predicates are widely used in the STL. The comparison functions for the standard associative containers are predicates, and predicate functions are commonly passed as parameters to algorithms like find_if and the various sorting algorithms. – Effective STL 概念：返回bool类型的仿函数称为谓词；如果operator()接收一个参数，称为一元谓词；operator()接收两个参数，称为二元谓词 内建函数对象 概念：STL内建了一些函数对象 分类：算数仿函数、关系仿函数、逻辑仿函数 用法： 这些仿函数所产生的对象，用法和一般函数完全相同 使用内建函数对象，需要引入头文件#include &lt;functional&gt; 算数仿函数 – 实现四则运算、除negete是一元外，其他都是二元运算 template&lt;class T&gt; T plus&lt;T&gt; //加法仿函数 template&lt;class T&gt; T minus&lt;T&gt; //减法仿函数 template&lt;class T&gt; T multiplies&lt;T&gt; //乘法仿函数 template&lt;class T&gt; T divides&lt;T&gt; //除法仿函数 template&lt;class T&gt; T modulus&lt;T&gt; //取模仿函数 template&lt;class T&gt; T negate&lt;T&gt; //取反仿函数 关系仿函数 template&lt;class T&gt; bool equal_to&lt;T&gt; //等于 template&lt;class T&gt; bool not_equal_to&lt;T&gt; //不等于 template&lt;class T&gt; bool greater&lt;T&gt; //大于 – 最常用 template&lt;class T&gt; bool greater_equal&lt;T&gt; //大于等于 template&lt;class T&gt; bool less&lt;T&gt; //小于 template&lt;class T&gt; bool less_equal&lt;T&gt; //小于等于 逻辑仿函数 template&lt;class T&gt; bool logical_and&lt;T&gt; //逻辑与 template&lt;class T&gt; bool logical_or&lt;T&gt; //逻辑或 template&lt;class T&gt; bool logical_not&lt;T&gt; //逻辑非 STL-常用算法 算法主要是由头文件&lt;algorithm&gt; &lt;functional&gt; &lt;numeric&gt;组成 &lt;algorithm&gt;是所有STL头文件中最大的一个，范围涉及比较、交换、查找、遍历操作、复制、修改等 &lt;numeric&gt;体积很小，只包括几个在序列上进行简单数学运算的模板函数 &lt;functional&gt;定义了一些模板类，用以声明函数对象 常用遍历算法 for_each //遍历容器 函数原型：for_each(iterator beg, iterator end, _func); _func是函数或者函数对象 transform //搬运容器到另一个容器中 transform(iterator beg1, iterator end1, iterator beg2, _func); tips：搬运的目标容器必须要提前开辟空间，否则无法正常搬运 常用查找算法 find //查找元素 find_if //按条件查找元素 adjacent_find //查找相邻重复元素 binary_search //二分查找法 count //统计元素个数 count_if //按条件统计元素个数 常用排序算法 sort //对容器内元素进行排序 random_shuffle //洗牌 指定范围内的元素随机调整次序 merge // 容器元素合并，并存储到另一容器中 reverse // 反转指定范围的元素 常用拷贝算法和替换算法 copy // 容器内指定范围的元素拷贝到另一容器中 replace // 将容器内指定范围的旧元素修改为新元素 replace_if // 容器内指定范围满足条件的元素替换为新元素 swap // 互换两个容器的元素 常用算术生成算法 算术生成算法属于小型算法，使用时包含的头文件为 #include &lt;numeric&gt; accumulate // 计算容器元素累计总和 fill // 向容器中添加元素 常用集合算法 set_intersection // 求两个容器的交集 set_union // 求两个容器的并集 set_difference // 求两个容器的差集","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"omnetpp","slug":"omnetpp","date":"2021-04-07T02:55:26.000Z","updated":"2021-04-07T03:13:25.592Z","comments":true,"path":"2021/04/07/omnetpp/","link":"","permalink":"http://yoursite.com/2021/04/07/omnetpp/","excerpt":"","text":"Tictoc_tutorialNetwork Description File(NED)","categories":[],"tags":[{"name":"omnetpp","slug":"omnetpp","permalink":"http://yoursite.com/tags/omnetpp/"}]},{"title":"Cpp_learningnote2","slug":"Cpp-learning-note-2","date":"2021-03-16T16:00:00.000Z","updated":"2021-03-17T02:44:59.112Z","comments":true,"path":"2021/03/17/Cpp-learning-note-2/","link":"","permalink":"http://yoursite.com/2021/03/17/Cpp-learning-note-2/","excerpt":"","text":"[toc] reference：《黑马》C++系列教程 基础 核心 提高 本篇主要参考核心篇进行记录 内存分区 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收 在C++中主要利用new在堆区开辟内存，释放利用操作符 delete，note释放数组 delete 后加 [] 引用 不要返回局部变量引用，可以返回静态变量引用 static 引用的本质，在C++内部实现是一个指针常量 123int a = 10;int&amp; ref = a;//自动转化为int* const ref = &amp;a; 指针常量是指针指向不可改 在函数形参列表中，可以加const修饰形参，防止形参改变实参 123int&amp; ref = 10; //是错误的，引用本身需要一个合法的内存空间，不能直接赋值const int&amp; ref = 10;//加入const，编译器会优化代码，int temp = 10; const int&amp; ref = temp; 函数重载123456789101112//1.引用作为重载条件void func(int&amp; a)void func(const int&amp; a)int a = 10;func(a);func(10);//调用不同的函数//2.函数重载遇到函数默认参数func2(int a, int b = 10)func2(int a)//这样的定义在调用的时候会报错func2(10);//产生歧义，不能做出调用函数的判断 类和对象 OOP - 封装、继承、多态 一、about 类 语法：class 类名{ 访问权限: 属性 / 行为}; 类在设计时，可以把属性和行为放在不同权限下，加以控制 访问权限有三种： – public 公共权限： 类内可以访问，类外可以访问（只允许本类的成员函数访问） – protected 保护权限 ：类内可以访问，类外不可以访问 （只允许子类及本类的成员函数访问） – private 私有权限： 类内可以访问，类外不可以访问（可以被任意实体访问） 在C++中 struct 和 class 唯一的区别就在于默认的访问权限不同，struct默认权限为公共，class默认权限为私有 二、concerning 对象 对象的初始化和清理 – 构造函数和析构函数 如果编程者不提供，编译器会自动提供空实现的构造和析构函数（这时候编译器自动添加的拷贝构造对属性的拷贝是浅拷贝 –构造函数语法： 类名(){} 构造函数没有返回值也不写void 函数名称与类名相同 构造函数可以参数，可能发生函数重载 程序在调用对象的时候会自动调用构造，且只调用一次 分类 按参数：有参构造、无参构造 按类型：普通构造、拷贝构造 调用方式 括号法、显式法（类似java）、隐式转换法 *tips: 调用无参构造函数不能加括号，加了编译器认为这是一个函数声名； 不能利用拷贝构造函数初始化匿名对象，编译器认为是对象声明； 拷贝构造函数的调用时机： 使用一个已创建好的对象初始化新的对象 值传递的方式给函数参数传值 以值的方式返回局部对象 – 析构函数语法：~类名(){} 析构函数没有返回值也不写void 函数名称与类名相同，前面加上符号~ 析构函数不可以有参数，不能发生重载 程序在对象销毁前会自动调用析构，且只调用一次 （一）深拷贝与浅拷贝 浅拷贝：简单的赋值拷贝操作 深拷贝：在堆区重新申请空间进行拷贝操作 如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的在delete时出现的问题 new -&gt; 在堆空间创建一块内存并返回内存地址给指针 1int* p = new int(10);//这里定义变量类型为指针 （二）初始化列表 语法：构造函数(): 属性1(值1)， 属性2(值2), …{} 只有构造函数可以使用初始化列表语法，引用数据成员与const数据成员必须使用这种语法，因为它们在创建时就需要初始化 12345678class Person&#123;public: Person(int a,int b,int c) :m_A(a), m_B(b), m_C(c) &#123;&#125;private: int m_A: int m_B; int m_C;&#125; （三）类对象作为类成员 当类中成员时其他类对象时，我们称该成员为 对象成员 构造的顺序是：先调用对象成员的构造，再调用本类构造。析构的顺序与构造相反 （四）静态成员 在成员变量和成员函数前加上关键字static，称为静态成员 静态成员变量（2种访问方式：通过对象、通过类名） 所有对象共享同一份数据 在编译阶段分配内存 类内声明，类外初始化 1234567891011class Person&#123;public: static int m_A;private: static int m_B;&#125;int Person::m_A = 10;int Person::m_B = 10;//类外初始化cout &lt;&lt; Person::m_A &lt;&lt; endl;//通过类名访问cout &lt;&lt; Person::m_B &lt;&lt; endl;//会报错，没有访问权限 静态成员函数 所有对象共享同一个函数 静态成员函数只能访问静态成员变量 三、C++对象模型和this指针 在C++中，类内的成员变量和成员函数 分开储存，只有非静态成员变量才属于类的对象上。非静态成员变量占用对象空间，而静态成员变量和成员函数（静态/非静态）都不占用对象空间，所有非静态成员函数共享一个函数实例。 this指针 指向被调用成员函数所属的对象 this指针是隐含在每一个非静态成员函数内的一种指针 不需要定义可以直接使用 用途：当形参和成员变量同名时，用this指针区分；在类的非静态成员函数中返回对象本身，可使用return *this 空指针也可以调用成员函数，但是当成员函数用到了this指针则不可以，这个时候需要对指针进行非空判断，保证代码的健壮性 123Person* p = NULL;if(this == NULL) return;//非空判断 常函数：成员函数后加const​，在常函数内不可以修改成员属性，但是当成员属性声明时添加mutable关键字，在常函数内仍可以进行修改 1234void func() const &#123;...&#125;public: int m_A; mutable int m_B; 常对象：声明对象前加const，常对象只能调用常函数，不能修改成员变量的值，但是可以访问 1const Person person; 四、友元 -&gt; 让一个函数或者类访问另一个类中的私有成员 关键字 friend 三种实现 全局函数左右元 类做友元 成员函数做友元 五、运算符重载 -&gt; 对已有的运算符重新进行定义，赋予另一种功能，以适应不同的数据类型 函数名由关键字 operator 和其后要进行重载的运算符符号构成的 通俗理解就是将数的相加、输出、比较判断等运算重载为直接对对象进行操作 六、继承 class A: public B { }; 其中A类称为子类 或 派生类，B类成为父类 或 基类 派生类中的成员包含从基类继承的和自己增加的成员 继承方式 语法： class 子类: 继承方式 父类 公共继承 public 保护继承 protected 私有继承 private public protected private 公有继承 public protected 不可见 保护继承 protected protected 不可见 私有继承 private private 不可见 tips： 父类中私有成员也被子类继承下去了，只是由编译器隐藏后不能访问 继承中，先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反 继承同名成员的处理方式 访问子类同名成员 直接访问即可 访问父类同名成员 需要添加作用域 1234567891011121314151617class Base &#123;public: Base()&#123;m_A = 100;&#125; void func()&#123;&#125; int m_A;&#125;class Son: public Base&#123;public: Son()&#123;m_A = 200;&#125; void func()&#123;&#125; int m_A;&#125;void main()&#123; Son s; s.func();//直接访问子类同名成员 s.Base::func();//添加作用域访问父类同名成员&#125;//这里是子类以对象的方式进行访问 *tips：对于同名静态成员处理方式与上面相同，不过有通过对象和通过类名两种访问方式 多继承语法：class 子类: 继承方式 父类1, 继承方式 父类2 … 菱形继承（草泥马的例子好形象2333) 羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。 12345678910111213141516171819202122class Animal&#123;public: int m_Age;&#125;;//继承前加virtual关键字后，变为虚继承//此时公共的父类Animal称为虚基类class Sheep : virtual public Animal &#123;&#125;;class Tuo : virtual public Animal &#123;&#125;;class SheepTuo : public Sheep, public Tuo &#123;&#125;;void test01()&#123; SheepTuo st; st.Sheep::m_Age = 100; st.Tuo::m_Age = 200; cout &lt;&lt; \"st.Sheep::m_Age = \" &lt;&lt; st.Sheep::m_Age &lt;&lt; endl; cout &lt;&lt; \"st.Tuo::m_Age = \" &lt;&lt; st.Tuo::m_Age &lt;&lt; endl; cout &lt;&lt; \"st.m_Age = \" &lt;&lt; st.m_Age &lt;&lt; endl;&#125; *tips：采用虚继承解决菱形继承的问题，虚继承的目的是让某个类做出声明，承诺愿意共享它的基类 七、多态 分类： 静态多态：函数重载和运算符重载属于静态多态，复用函数名 动态多态：派生类和虚函数实现运行时多态 区别：静态–函数地址早绑定 - 编译阶段确定函数地址 动态–函数地址晚绑定 - 运行阶段确定函数地址 12345678910111213141516171819202122class Animal&#123;public: virtual void speak()&#123;&#125;//函数前加上virtual关键字，变成虚函数，编译器在编译的时候就不能确定函数调用&#125;;class Cat:public Animal&#123;//继承Animal类public: virtual void speak()&#123;&#125;//Q:这里为virtual为什么可以省略不写&#125;;class Dog:public Animal&#123;public: virtual void speak()&#123;&#125;&#125;;void DoSpeak(Animal &amp; animal)&#123; animal.speak();&#125;int main()&#123; Cat cat; DoSpeak(cat);//传入什么对象，就调用什么对象的寒素 Dog dog; DoSpeak(dog); return 0;&#125; 多态满足条件：1. 有继承关系 2. 子类重写父类中的虚函数 多态使用：父类指针或引用指向子类对象 重写：函数返回值类型 函数名 参数列表 完全一致称为重写 在多态中，通常父类中虚函数饿实现是毫无意义的，主要都是调用子类重写的内容 因此可以将虚函数改为纯虚函数 纯虚函数语法：virtual 返回值类型 函数名 (参数列表) = 0; 当类中有了虚函数（虚构造函数或虚析构函数），这个类也成为抽象类（类中只要有一个纯虚函数就成为抽象类） 抽象类特点： 无法实例化对象 子类必须重写抽象类中的纯虚函数，否则也属于抽象类 Q：多态使用时，子类中开辟属性到堆区（new），父类指针在释放时无法调用子类的析构代码 A：将父类中的析构函数改为虚析构或纯虚析构 虚析构和纯虚析构共性： 可以解决父类指针释放子类对象的问题 都需要有具体的函数实现 虚析构和纯虚析构区别： 纯虚析构，该类属于抽象类，无法实例化对象 虚析构语法：virtual ~类名 () {} 纯虚析构语法：类内 -&gt; virtual ~类名() = 0; 类外 -&gt; 类名::~类名() {} 文件操作C++中对文件操作许哟啊包含头文件&lt;fstream&gt; 文件类型： 文本文件：以ASCII码形式储存在计算机中 二进制文件：以二进制形式存储在计算机中 操作文件的三大类： ofstream：写操作 ifstream：读操作 fstream：读写操作 文本文件 写文件 包含头文件#include&lt;fstream&gt; 创建流对象ofstream ofs; 打开文件ofs.open(&quot;file_path&quot;, way); 写数据ofs&lt;&lt;&quot;writing data&quot;; 关闭文件ofs.close(); 文件打开方式 打开方式 解释 ios::in 为读文件而打开文件 ios::out 为写文件而打开文件 ios::ate 初始位置：文件尾 ios::app 追加方式写文件 ios::trunc 如果文件存在先删除，再创建 ios::binary 二进制方式 文件打开方式可以配合使用，利用|操作符 e.g. 用二进制方式写文件ios::binary|ios::out 读文件 包含头文件#include&lt;fstream&gt; 创建流对象ifstream ifs; 打开文件ifs.open(&quot;file_path&quot;, way);，利用is_open函数可以判断文件是否打开成功 读数据 四种方式 1234char buf[1024] = &#123;0&#125;;while(ifs &gt;&gt; buf)&#123; cout &lt;&lt; buf &lt;&lt; endl;&#125; 1234char buf[1024] = &#123;0&#125;;while(ifs.getline(buf, sizeof(buf)))&#123; cout &lt;&lt; buf &lt;&lt; endl;&#125; 1234string buf;while(getline(ifs, buf))&#123; cout &lt;&lt; buf &lt;&lt; endl;&#125; 1234char c;while((c = ifs.get()) != EOF)&#123; cout &lt;&lt; c;&#125; 关闭文件ifs.close(); 二进制文件打开方式指定为ios::binary 写文件 利用流对象调用成员函数wirte 函数原型 ofstream&amp; write(const char * buffer,int len); 写文件 利用流对象调用成员函数read 函数原型 ifstream&amp; read(char *buffer,int len);","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"Cpp_learningnote3","slug":"Cpp-learning-note-3","date":"2021-03-16T16:00:00.000Z","updated":"2021-07-03T06:58:25.331Z","comments":true,"path":"2021/03/17/Cpp-learning-note-3/","link":"","permalink":"http://yoursite.com/2021/03/17/Cpp-learning-note-3/","excerpt":"","text":"[toc] reference：《黑马》C++系列教程 基础 核心 提高 本篇主要参考提高篇进行记录 模板 模板就是建立通用的模具，提高复用性。模板只是一个框架，不能直接使用 函数模板 C++另一种编程思想称为 泛型编程，主要利用的技术就是模板 C++提供两种模板机制：函数模板 和 类模板 函数模板语法：template&lt;typename T&gt;，其中typename可以用class代替 123456789101112template&lt;typename T&gt;void Swap(T&amp; a,T&amp; b)&#123; T temp = a; a = b; b = temp;&#125;void main()&#123; int a = 10,b = 20; Swap(a, b);//1.自动类型推导 Swap&lt;int&gt;(a, b);//2.显示指定类型 return;&#125; *tips： 自动类型推导，必须推导出一致的数据类型T才可以使用 显示指定类型，必须确定出T的数据类型才可以使用 也就是说，凡是给出了模板定义，之后跟着的函数，必须给出数据类型才能调用。 1234template&lt;typename T&gt;void function()&#123; cout &lt;&lt; \"test\" &lt;&lt; endl;&#125;//函数中没用用到模板类型T，但是调用时必须给出才能使用 普通函数与函数模板的区别 普通函数调用时可以发生自动类型转换（隐式类型转换） 函数模板调用的时候，如果利用自动类型推导，不会发生隐式类型转换 如果利用显式指定类型的方式，可以发生隐式类型转换 普通函数与函数模板的调用规则 如果函数模板和普通函数都可以实现，优先调用普通函数 可以通过空模板参数列表来强制调用函数模板 funtion&lt;&gt;(a, b); 函数模板也可以发生重载 如果函数模板可以产生更好的匹配（例如不用进行隐式转换），优先调用函数模板 模板的局限性：传入数组、类对象、自定义数据类型等数据不能处理，可以为这些特定的类型提供具体化的模板 具体化的模板以template&lt;&gt;开头，通过名称来指出类型，具体化优先于常规模板 1template&lt;&gt; bool compare(Person&amp; p1, Person&amp; p2)&#123; &#125; 类模板 建立一个通用类，类中的成员数据类型可以不具体指定，用一个虚拟的类型来代表 语法： 12template&lt;typename T1， typename T2, ...&gt;class 类模板与函数模板的区别 类模板没有自动类型推导的使用方式 类模板在模板参数列表中可以有默认参数（在显示指定的时候可以更换参数类型，如int-&gt;double） 123456template&lt;class nametype, class agetype = int&gt;//2.defualt parameterclass Person&#123; &#125;void main()&#123; Person &lt;string, double&gt;p('string',10);//1.显示指定&#125; 类模板中的成员函数并不是一开始就创建的，在调用的时候才会创建 类模板对象做函数参数 指定传入的类型 – 直接显示对象的数据类型 1void printPerson1(Person&lt;string, int&gt; &amp;p) 参数模板化 – 将对象中的参数变为模板进行传递 123456template &lt;class T1, class T2&gt;void printPerson2(Person&lt;T1, T2&gt;&amp;p)&#123; p.showPerson(); cout &lt;&lt; \"T1的类型为： \" &lt;&lt; typeid(T1).name() &lt;&lt; endl; cout &lt;&lt; \"T2的类型为： \" &lt;&lt; typeid(T2).name() &lt;&lt; endl;&#125; 整个类模板化 – 将这个对象类型模板化进行传递 123456template&lt;class T&gt;void printPerson3(T &amp; p)&#123; cout &lt;&lt; \"T的类型为： \" &lt;&lt; typeid(T).name() &lt;&lt; endl; p.showPerson();&#125; 类模板与继承 当子类继承的父类是一个类模板时，子类在声明的时候要制定出父类中T的类型 如果不指定，编译器无法给子类分配内存 如果想灵活制定出父类中T的类型，子类也需要变为类模板 类模板成员函数类外实现 类模板份文件编写 类模板与友元 STL初识 STL(Standard Template Library, 标准模板库) STL广义上分为：容器(container)、算法(algorithm)和迭代器(iterator)。其中容器和算法之间通过迭代器进行无缝连接。STL中几乎所有的代码都采用了模板类或者模板函数。 STL六大组件STL大体分为六大组件，分别是：容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器 容器：各种数据结构，如vector、list、deque、set和map等，用来存放数据； 算法：各种常用的算法，如sort、find、copy、for_each等； 迭代器：扮演了容器与算法之间的胶合剂； 仿函数：行为类似函数，可以作为算法的某种策略； 适配器：一种用来修饰容器或者仿函数或迭代器接口的东西； 空间配置器：负责空间的配置与管理。 STL中容器、算法、迭代器 容器将运用最广泛的一些数据结构实现出来，分为序列式容器和关联式容器两种： 序列式容器：强调值的排序，序列式容器中的每个元素均有固定的位置。 关联式容器：二叉树结构，各元素之间没有严格的物理上的顺序关系 算法分为质变算法和非质变算法： 质变算法：是指运算过程中会更改区间内的元素内容，如拷贝、替换、删除等 非质变算法：是指运算过程中不会更改区间内的元素内容，如查找、计数、遍历、寻找极值等 迭代器：提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。每个容器都有自己专属的迭代器（类似于指针） 容器算法迭代器初识 vector存放内置数据类型 容器：12算法：```for_each 迭代器：123456789101112131415161718192021222324252627282930313233343536373839--- ```c++ #include &lt;vector&gt; #include &lt;algorithm&gt; void MyPrint(int val) &#123; cout &lt;&lt; val &lt;&lt; endl; &#125; void test()&#123; vector&lt;int&gt; v; v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); vector&lt;int&gt;::iterator pBegin = v.begin(); vector&lt;int&gt;::iterator pEnd = v.end(); // 遍历方式1 while(pBegin != pEnd) &#123; cout &lt;&lt; *pBegin &lt;&lt; endl; pBegin++; &#125; // 遍历方式2 for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)&#123; cout &lt;&lt; *it &lt;&lt; endl; &#125; // 遍历方式3 for_each(v.begin(), v.end(), Myprint); &#125; int main()&#123; test(); system(&quot;pause&quot;); return 0; &#125; vector存放自定义数据类型 12345678910111213141516171819202122232425262728293031323334353637383940414243class Person &#123;public: Person(string name, int age)&#123; mName = name; mAge = age;&#125;public: string mName; int mAge;&#125;;// 存放对象void test01() &#123; vector&lt;Person&gt; v; Person p1(\"aaa\", 10); Person p2(\"bbb\", 20); Person p3(\"ccc\", 30); v.push_back(p1); v.push_back(p2); v.push_back(p3); for (vector&lt;Person&gt;::iterator it = v.begin(); it!=v.end(); it++) &#123; cout &lt;&lt; \"Name: \" &lt;&lt; (*it).mName &lt;&lt;\", Age: \" &lt;&lt; (*it).mAge &lt;&lt;endl; &#125;&#125;// 存放对象指针void test02() &#123; vector&lt;Person*&gt; v; Person p1(\"aaa\", 10); Person p2(\"bbb\", 20); Person p3(\"ccc\", 30); v.push_back(&amp;p1); v.push_back(&amp;p2); v.push_back(&amp;p3); for (vector&lt;Person*&gt;::iterator it = v.begin(); it!=v.end(); it++) &#123; Person* p = (*it); cout &lt;&lt; \"Name: \" &lt;&lt; p-&gt;mName &lt;&lt;\", Age: \" &lt;&lt; (*it)-&gt;mAge &lt;&lt;endl; &#125;&#125; vector容器嵌套容器 容器中嵌套容器，将所有数据遍历输出 12345678910111213141516171819202122232425void test01() &#123; vector&lt; vector&lt;int&gt;&gt; v; vector&lt;int&gt; v1; vector&lt;int&gt; v2; for(int i=0;i&lt;4;i++)&#123; v1.push_back(i+1); v2.push_back(i+2); &#125; v.push_back(v1); v.push_back(v2); vector&lt; vector&lt;int&gt;&gt;::iterator pBegin = v.begin(); vector&lt; vector&lt;int&gt;&gt;::iterator pEnd = v.end(); while(pBegin != pEnd) &#123; for (vector&lt;int&gt;::iterator vit = pBegin-&gt;begin(); vit != pBegin-&gt;end(); vit++) &#123; cout &lt;&lt; *vit &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; pBegin++; &#125;&#125; STL - 常用容器string容器 string是c++风格的字符串，本质上是一个类 string与char 的区别：char\\是一个指针，string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。 string构造函数 string()// 创建一个空的字符串 string(const char* s)// 使用字符串s初始化 string(const string&amp; str)// 使用一个string对象初始化另一个string对象 string(int n, char c)// 使用n个字符c初始化 string赋值操作 string&amp; operator=(const char* s); //char*类型字符串赋值给当前的字符串 string&amp; operator=(const string &amp;s); //把字符串s赋给当前的字符串 string&amp; operator=(char c); //字符赋值给当前的字符串 string&amp; assign(const char *s); //把字符串s赋给当前的字符串 string&amp; assign(const char *s, int n); //把字符串s的前n个字符赋给当前的字符串 string&amp; assign(const string &amp;s); //把字符串s赋给当前字符串 string&amp; assign(int n, char c); //用n个字符c赋给当前字符串 string字符串拼接 实现在字符串末尾拼接字符串 string&amp; operator+=(const char* str); //重载+=操作符 string&amp; operator+=(const char c); //重载+=操作符 string&amp; operator+=(const string&amp; str); //重载+=操作符 string&amp; append(const char *s); //把字符串s连接到当前字符串结尾 string&amp; append(const char *s, int n); //把字符串s的前n个字符连接到当前字符串结尾 string&amp; append(const string &amp;s); //同operator+=(const string&amp; str) string&amp; append(const string &amp;s, int pos, int n);//字符串s中从pos开始的n个字符连接到字符串结尾 string查找和替换 查找：查找指定字符串是否存在 替换：在指定的位置替换字符 int find(const string&amp; str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找 int find(const char* s, int pos = 0) const; //查找s第一次出现位置,从pos开始查找 int find(const char* s, int pos, int n) const; //从pos位置查找s的前n个字符第一次位置 int find(const char c, int pos = 0) const; //查找字符c第一次出现位置 int rfind(const string&amp; str, int pos = npos) const; //查找str最后一次位置,从pos开始查找 int rfind(const char* s, int pos = npos) const; //查找s最后一次出现位置,从pos开始查找 int rfind(const char* s, int pos, int n) const; //从pos查找s的前n个字符最后一次位置 int rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置 string&amp; replace(int pos, int n, const string&amp; str); //替换从pos开始n个字符为字符串str string&amp; replace(int pos, int n,const char* s); //替换从pos开始的n个字符为字符串s conclusion：find查找是从左向右，rfind自右向左；find找不到时返回-1；replace要指定从哪个位置起，多少个字符，替换的字符串。 string字符串比较 字符串按字符的ASCII码进行对比，=返回0、&gt;返回1、&lt;返回-1 int compare(const string &amp;s) const; //与字符串s比较 int compare(const char *s) const; //与字符串s比较 string字符串存取 string中单个字符存取方式有两种 char&amp; operator[](int n); //通过[]方式取字符 char&amp; at(int n); //通过at方法获取字符 string插入和删除 string&amp; insert(int pos, const char* s); //插入字符串 string&amp; insert(int pos, const string&amp; str); //插入字符串 string&amp; insert(int pos, int n, char c); //在指定位置插入n个字符c string&amp; erase(int pos, int n = npos); //删除从Pos开始的n个字符 string子串 从字符串中获取想要的子串 string substr(int pos = 0, int n = npos) const; //返回由pos开始的n个字符组成的字符串 vector容器 vector数据结构和数组非常相似，也称为单端数组；不同之处在于数组是静态空间，而vector可以动态扩展。这里的动态扩展并不是在原空间之后续接新空间，而是找更大的内存空间，将原数据copy新空间，释放原空间。 vector构造函数 vector&lt;T&gt; v; //采用模板实现类实现，默认构造函数 vector(v.begin(), v.end()); //将v[begin(), end())区间中的元素拷贝给本身。 vector(n, elem); //构造函数将n个elem拷贝给本身。 vector(const vector &amp;vec); //拷贝构造函数。 vector赋值操作 vector&amp; operator=(const vector &amp;vec);//重载等号操作符 assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。 assign(n, elem); //将n个elem拷贝赋值给本身。 vector容量和大小 empty(); //判断容器是否为空 capacity(); //容器的容量 size(); //返回容器中元素的个数 resize(int num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。 resize(int num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除 vector插入和删除 push_back(ele); //尾部插入元素ele pop_back(); //删除最后一个元素 insert(const_iterator pos, ele); //迭代器指向位置pos插入元素ele insert(const_iterator pos, int count,ele);//迭代器指向位置pos插入count个元素ele erase(const_iterator pos); //删除迭代器指向的元素 erase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素 clear(); //删除容器中所有元素 vector数据存取（除了用迭代去获取vector容器中元素，[]和at也可以） at(int idx); //返回索引idx所指的数据 operator[]; //返回索引idx所指的数据 front(); //返回容器中第一个数据元素 back(); //返回容器中最后一个数据元素 vector互换容器 swap(vec); // 将vec与本身的元素互换 vector预留空间 减少vector在动态扩展容量时的扩展次数 reserve(int len); // 容器预留len个元素长度，预留位置不初始化，元素不可访问 deque容器 双端数组，可以对头端进行插入和删除操作。 deque与vector区别： vector对于头部的插入删除效率低，数据量越大，效率越低 deque相对而言，对头部的插入删除速度比vector块 vector访问元素时的速度比deque快 deque内部工作原理： ​ deque内部有一个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据。中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间。deque容器的迭代器也是支持随机访问的。 stack容器 stack是一种先进后出（FILO）的数据结构，它只有一个出口。 栈中只有顶端的元素才可以被外界使用，不允许有遍历行为。有push和pop操作。 stack常用接口 入栈 — push 出栈 — pop 返回栈顶 — top 判断栈是否为空 — empty 返回栈大小 — size queue容器 queue是一种FIFO的数据结构，有两个出口。 队列容器允许从一端新增元素，从另一端移除元素，只有队头和队尾才可以被使用，不允许有遍历行为。 queue常用接口 入队 — push 出队 — pop 返回队头元素 — front 返回队尾元素 — back 判断队是否为空 — empty 返回队列大小 — size list容器 list（链表）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的，list将数据进行链式储存。 STL中的链表是一个双向循环链表，list的迭代器只支持前移和后移，属于双向迭代器。 list有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。 tips: const_iterator和iterator都可以遍历容器的元素，并访问这些元素的值。iterator可以改变元素值，但是const_iterator不可改。 list 插入与删除 尾插 — push_back 尾删 — pop_back 头插 — push_front 头删 — pop_front 插入 — insert 删除 — erase 移除 — remove 清空 — clear list反转和排序 反转 — reverse 排序 — sort （成员函数） set/multiset容器 所有元素都会在插入时自动被排序 本质：set/multiset属于关联式容器。底层结构是用二叉树实现的。 set与multiset区别：set不允许容器中有重复元素，multiset允许容器中有重复元素。 set不可以插入重复数据，而multiset可以 set插入数据的同时会返回插入结果，表示插入是否成功 multiset不会检测数据，因此可以插入重复数据 set构造与赋值 set容器插入数据时用insert set容器插入数据的数据会自动排序 set大小和交换 统计大小 — size 判断是否为空 — empty 交换容器 — swap set查找和统计 查找 — find （返回的是迭代器） 统计 — count （对于set，结果为0或者1） pair对组创建 成对出现的数据，利用对组可以返回两个数据 pair&lt;type, type&gt; p ( value1, value2 ); pair&lt;type, type&gt; p = make_pair( value1, value2 ); pair&lt;set&lt;int&gt;::iterator, bool&gt; ret = s.insert(10);# 注意insert()的返回是一个pair对组，此外对pair对组的访问通过pair.first or pair.second进行。 set容器排序 set容器默认排序规则为从小到大，利用仿函数，可以改变排序规则。 仿函数 (functor)，就是使一个类的使用看上去像一个函数。 其实现就是类中实现一个 operator ()，这个类就有了类似函数的行为，就是一个仿函数类了。 通过定义结构体(或类)，并在其中重载()运算符，来自定义排序函数。然后，在定义set的时候，将结构体加入其中例如如下代码中的set&lt;int, intComp&gt;和set&lt;string, strComp &gt;。 map/multimap容器 map中所有元素都是pair，pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值），所有元素都会根据元素的key自动排序。 本质：map/multimap属于关联式容器，底层结构用二叉树实现。 map和multimap的区别：map不允许容器中有重复的key，而multimap可以","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"makefile","slug":"Makefile","date":"2021-03-16T16:00:00.000Z","updated":"2021-03-23T07:20:09.104Z","comments":true,"path":"2021/03/17/Makefile/","link":"","permalink":"http://yoursite.com/2021/03/17/Makefile/","excerpt":"","text":"[toc] Makefile_learning 教程：http://c.biancheng.net/makefile/ makefile描述的是文件编译的相关规则，由依赖的关系和执行的命令两部分组成 结构： 12targets: prerequisites command targets：规则的目标，可以是中间文件（*.o），也可以是执行文件（*.elf），还可以是一个标签（clean等） prerequisites：依赖文件，要生成targets需要的文件或目标 command：make需要执行的命令（任意的shell命令） attention：目标和依赖之间要用冒号分隔开，命令的开始一定要使用tab键 makefile的工作流程默认情况下，make执行的是Makefile中的第一规则（Makefile中出现的第一个依赖关系），此规则的第一目标称为“最终目标”，根据依赖关系查找下一条要执行的规则。 这里我们知道，编译时生成的 “.o” 文件。作用是检查某个源文件是不是进行过修改，最终目标文件是不是需要重建。 清除过程文件： 123.PHONY: cleanclean: rm -rf *.0 test Makefile文件所在目录有文件名为clean的文件，命令行“.PHONY: clean”又没添加的话，执行make clean是无效的，“.PHONY: clean”就是保证即使目录下有文件名为clean的文件，也能正常执行make clean 通配符的使用通配符可以出现在模式的规则中，也可以出现在命令中 通配符 使用说明 * 匹配0个或者是任意个字符 ？ 匹配任意一个字符 [] 我们可以指定匹配的字符放在 “[]” 中 % 匹配任意个字符，储存名字在一个列表中，挨个查找 如果我们的通配符使用在依赖的规则中的话一定要注意这个问题：不能通过引用变量的方式来使用，但就是想要通过引用变量的话，我们要使用一个函数 “wildcard”，这个函数在我们引用变量的时候，会帮我们展开 123OBJ = $(wildcard *.c)test: $(OBJ) gcc -o $@ $^ 变量的定义和使用 基本语法VALUE_LIST = one two three 调用变量的时候用$(VALUE_LIST)或${VALUE_LIST}来替换 四种基本赋值方式 简单赋值（:=）只对当前语句的变量有效 递归赋值（=）所有目标变量相关的其他变量都受影响 条件赋值（?=）如果变量未定义，则使用符号中的值（等号后的值）定义变量，如果变量已经赋值，则该赋值语句无效（保持原定义的值） 追加赋值（+=）原变量用空格隔开的方式追加一个新值 makefile自动化变量自动化变量可以理解为由 Makefile 自动产生的变量，自动化变量的取值根据执行的规则来决定，取决于执行规则的目标问价和依赖文件。 自动化变量 说明 $@ 表示规则的目标文件名。如果目标是一个文档文件（Linux 中，一般成 .a 文件为文档文件，也称为静态的库文件）， 那么它代表这个文档的文件名。在多目标模式规则中，它代表的是触发规则被执行的文件名。 $% 当目标文件是一个静态库文件时，代表静态库的一个成员名。 $&lt; 规则的第一个依赖的文件名。如果是一个目标文件使用隐含的规则来重建，则它代表由隐含规则加入的第一个依赖文件。 $? 所有比目标文件更新的依赖文件列表，空格分隔。如果目标文件是静态库文件，代表的是库文件（.o 文件）。 $^ 代表的是所有依赖文件列表，使用空格分隔。如果目标是静态库文件，它所代表的只能是所有的库成员（.o 文件）名。 一个文件可重复的出现在目标的依赖中，变量“\\$^”只记录它的第一次引用的情况。就是说变量“\\$^”会去掉重复的依赖文件。 $+ 类似“$^”，但是它保留了依赖文件中重复出现的文件。主要用在程序链接时库的交叉引用场合。 $* 在模式规则和静态模式规则中，代表“茎”。“茎”是目标模式中“%”所代表的部分（当文件名中存在目录时， “茎”也包含目录部分）。 12345678test:test.o test1.o test2.o gcc -o $@ $^test.o:test.c test.h gcc -o $@ $&lt;test1.o:test1.c test1.h gcc -o $@ $&lt;test2.o:test2.c test2.h gcc -o $@ $&lt; GNU make 中在这些变量中加入字符 “D” 或者 “F” 就形成了一系列变种的自动化变量，这些自动化变量可以对文件的名称进行操作。 变量名 功能 $(@D) 表示文件的目录部分（不包括斜杠）。如果 “$\\@” 表示的是 “dir/foo.o” 那么 “\\$(@D)” 表示的值就是 “dir”。如果 “\\$@” 不存在斜杠（文件在当前目录下），其值就是 “.”。 $(@F) 表示的是文件除目录外的部分（实际的文件名）。如果 “\\$@” 表示的是 “dir/foo.o”，那么 “\\$@F” 表示的值为 “dir”。 \\$(*D) ​\\$(*F) 分别代表 “茎” 中的目录部分和文件名部分 \\$(%D) \\$(%F) 当以 “archive(member)” 形式静态库为目标时，分别表示库文件成员 “member” 名中的目录部分和文件名部分。(?) \\$(&lt;D) ​\\$(&lt;F) 表示第一个依赖文件的目录部分和文件名部分。 \\$(^D) ​\\$(^F) 分别表示所有依赖文件的目录部分和文件部分。 \\$(+D) ​\\$(+F) 分别表示所有的依赖文件的目录部分和文件部分。 \\$(?D) ​\\$(?F) 分别表示更新的依赖文件的目录部分和文件名部分。 makefile目标文件搜索（VPATH和vpath） VAPTH和vpath区别：VPATH是环境变量，使用时需要指定文件的路径；vpath是关键字，按照模式搜索，也可以说是选择搜索。搜索时不仅需要加上文件的路径，还需要加上相应的限制条件。 VAPTH的使用 -&gt; 检索路径下的所有文件 1VPATH := src #把src的值赋值给变量VPATH 存在多个路径，使用空格或冒号分隔开，搜索顺序为书写顺序 vpath的使用（选择性搜索）-&gt; 文件数量大时可以提高搜索效率 VPATH 是搜索路径下所有的文件，而 vpath 更像是添加了限制条件，会过滤出一部分再去寻找。 123vpath PATTERN DIRECTORIES # PATTERN：要寻找的条件 DIRECTORIES：寻找的路径vpath PATTERN # 可以使用通配符% e.g. \"%.c\"搜索所有的.c文件vpath vpath PATTERN DIRECTORIES为所有符合模式“PATTERN”的文件指定搜索目录“DIRECTORIES” 。多个目录使用空格或者冒号（：）分开。 vpath PATTERN清除之前为符合模式“PATTERN”的文件设置的搜索路径。 vpath清除所有已被设置的文件搜索路径。 makefile隐含规则123test:test.o gcc -o test test.otest.o:test.c 隐含条件只能省略中间目标文件重建的命令和规则，最终目标的命令和规则不能省略 工作流程：make执行过程中找到隐含规则，提供了此目标的基本依赖关系。确定目标的依赖文件和重建目标需要使用的命令行。隐含规则所提供的依赖文件只是一个基本的。当需要增加这个文件的依赖文件的时候要在 Makefile 中使用没有命令行的规则给出。 makefile条件判断条件语句可以根据一个变量的值来控制make执行或者忽略makefile的特定部分，条件语句可以是两个不同的变量或者是常量和变量之间的比较。 条件语句只能用于控制make实际执行的makefile部分，不能控制规则的shell命令执行的过程 关键字 功能 ifeq 判断参数是否相等，相等为 true，不相等为 false。 ifneq 判断参数是否不相等，不相等为 true，相等为 false。 ifdef 判断是否有值，有值为 true，没有值为 false。 ifndef 判断是否有值，没有值为 true，有值为 false。 12ifeq (VAL1,VAL2)# 或者 ifeq 'VAL1' 'VAL2'ifdef VARIABLE-NAME makefile伪目标伪目标不会创建目标文件，只是想执行这个目标下面的命令。 使用伪目标的原因 避免makefile中定义的只执行的命令和工作目录下实际文件出现名字冲突 提高执行make的效率 将一个目标声明为伪目标的方法是将它作为特殊的目标.PHONY的依赖 123.PHONY:cleanclean: rm -rf *.o test make在并行和递归执行的过程中，存在一个变量定义为所有需要make的子目录。 123456SUBDIRS = foo bar baz.PHONY:subdirs $(SUBDIRS)subdirs:$(SUBDIRS)$(SUBDIRS): $(MAKE) -C $@foo:baz #规定三个子目录的编译顺序，baz比foo先执行，最后执行bar 伪目标实现多文件编译 12345678.PHONY:allall:test1 test2 test3test1:test1.o gcc -o $@ $^test2:test2.o gcc -o $@ $^test3:test3.o gcc -o $@ $^ makefile常用字符串处理函数函数的语法结构 1$(&lt;function&gt; &lt;arguments&gt;) # or $&#123;&lt;function&gt; &lt;arguments&gt;&#125; 其中，function是函数名，arguments是函数的参数，参数之间要用逗号分隔开，而函数名和参数之间用空格分开。调用函数的时候要使用字符$，后面跟小括号或者花括号。 模式字符串替换函数 1$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;) 查找text中的单词是否符合模式pattern，如果匹配的话，则用replacement替换。返回值为替换后的新字符串。 字符串替换函数 1$(subst &lt;form&gt;,&lt;to&gt;,&lt;text&gt;) 将字符串中的form替换成to，返回值为替换后的新字符串。 去空格函数 1$(strip &lt;string&gt;) 去掉字符串开后和结尾的空格，并将字符中间的多个连续的空格合并成为一个空格，返回值为去掉空格的字符串。 查找字符串函数 1$(findstring &lt;find&gt;,&lt;in&gt;) 查找in中的find，如果我们的目标字符串存在。返回值为目标字符串，如果不存在就返回空值。 过滤函数 1$(filter &lt;pattern&gt;,&lt;text&gt;) 过滤出text中符合模式pattern的字符串，可以有多个pattern。返回值为过滤后的字符串。 反过滤函数 1$(filter-out &lt;pattern&gt;,&lt;text&gt;) 排序函数 1$(sort &lt;list&gt;) 将list中的单词排序（升序）。返回值为排序后的字符串。 sort会去除重复的字符串 取单词函数 1$(word &lt;n&gt;,&lt;text&gt;) 取出text中的第n个单词。 makefile常用文件名操作函数 下面每个函数的参数字符串都会被当作是一个系列的文件名来看待 取目录函数 1$(dir &lt;names&gt;) 从文件名序列names中取出目录部分，如果names中没有/，取出的值为./。返回值为目录部分，指的是最后一个反斜杠之前的部分。 取文件函数名 1$(notdir &lt;names) 从文件名序列names中取出非目录部分。 取后缀名函数 1$(suffix &lt;names&gt;) 从文件名序列names中取出各个问价的后缀名。返回值为后缀序列，如果没有后缀名，返回空字符串。 取前缀函数 1$(basename &lt;names&gt;) 获取的是文件的前缀名，包含文件路径的部分。 添加后缀名函数 1$(addsuffix &lt;suffix&gt;,&lt;names&gt;) 添加前缀名函数 1$(addprefix &lt;prefix&gt;,&lt;names&gt;) 可以使用这个函数给文件添加路径 链接函数 1$(join &lt;list1&gt;,&lt;list2&gt;) 把list2中的单词对应地拼接到list1的后面。如果list1的单词比list2多，那么list1中多出来的单词将保持原样；如果list1中的单词比list2的少，那么list2中多出来的单词将保持原样。 123OBJ = $(join src car,abc zxc qwe)all: @echo $(OBJ) 结果输出为srcabc carzxc qwe 获取匹配模式文件函数名 1$(wildcard PATTERN) 列出当前目录下的所有符合模式的PATTERN格式的文件名。返回值为空格分隔并且存在当前目录下的所有符合模式PATTERN的文件名。 123OBJ = $(*.c *.h)# 这里可以不适用wildcard函数 因为echo属于shell函数，通配符会自动展开，注意这里不是规则，是执行语句all: @echo $(OBJ) makefile中其他常用函数 foreach 1$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;) 把参数&lt;list&gt;中的单词逐一取出放到参数&lt;var&gt;所指定的变量中，然后再执行&lt;text&gt;所包含的表达式。每一次&lt;text&gt;会返回一个字符串，循环过程中，&lt;text&gt;所返回的每个字符串会以空格分割，最后当整个循环结束的时候，&lt;text&gt;所返回的每个字符串所组成的整个字符串（以空格分隔）将会是 foreach 函数的返回值。所以&lt;var&gt;最好是一个变量名，&lt;list&gt;可以是一个表达式，而&lt;text&gt;中一般会只用&lt;var&gt;这个参数来一次枚举&lt;list&gt;中的单词。 1234name := a b c dfiles := $(foreach val, $(names), $(val).o)all: @echo $(files) 输出为a.o b.o c.o d.o foreah中的var是局部变量，作用域只在函数内 if 1$(if &lt;condition&gt;,&lt;then-part&gt;) # or $(if &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;) call 1$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;,...) call函数是唯一一个可以用来创建新的参数化的函数，可以用来写一个非常复杂的表达式，用call来向这个表达式传递参数。当 make 执行这个函数的时候，expression参数中的变量\\$(1)、\\$(2)、\\$(3)等，会被参数parm1，parm2，parm3依次取代。而expression的返回值就是 call 函数的返回值。 origin 1$(origin &lt;variable&gt;) origin函数告诉你变量从哪里来 下面是origin函数返回值： “undefined”：如果&lt;variable&gt;从来没有定义过，函数将返回这个值。 “default”：如果&lt;variable&gt;是一个默认的定义，比如说“CC”这个变量。 “environment”：如果&lt;variable&gt;是一个环境变量并且当Makefile被执行的时候，“-e”参数没有被打开。 “file”：如果&lt;variable&gt;这个变量被定义在Makefile中，将会返回这个值。 “command line”：如果&lt;variable&gt;这个变量是被命令执行的，将会被返回。 “override”：如果&lt;variable&gt;是被override指示符重新定义的。 “automatic”：如果&lt;variable&gt;是一个命令运行中的自动化变量。 makefile命令的编写 命令回显 通常make在执行命令行之前会把要执行的命令行输出到标准输出设备，我们称之为“回显”。如果规则的命令行以字符@开始，则make在执行的时候不会显示这个将要被执行的命令。 我们在执行 make 时添加上一些参数，可以控制命令行是否输出。 当使用 make 的时候加上参数-n或者是--just-print ，执行时只显示所要执行的命令，但不会真正的执行这个命令。只有在这种情况下 make 才会打印出所有的 make 需要执行的命令，其中包括了使用的“@”字符开始的命令。 而 make 参数-s或者是--slient则是禁止所有的执行命令的显示。就好像所有的命令行都使用“@”开始一样。 命令执行 当规则中的目标需要被重建的时候，此规则所定义的命令将会被执行，如果是多行的命令，那么每一行命令将是在一个独立的子 shell 进程中被执行。因此，多命令行之间的执行命令时是相互独立的，相互之间不存在往来。 在 Makefile 中书写在同一行中的多个命令（用;分隔开）属于一个完整的 shell 命令行，书写在独立行的一条命令是一个独立的 shell 命令行。使用反斜杠\\来对处于多行的命令进行连接，表示他们是一个完整的shell命令行。 并发执行命令 通过 make 命令行选项 “-j” 或者 “–jobs” 来告诉 make 在同一时刻可以允许多条命令同时执行。如果选项 “-j” 之后存在一个整数，其含义是告诉 make 在同一时刻可以允许同时执行的命令行的数目。这个数字被称为job slots。当 “-j” 选项中没有出现数字的时候，那么同一时间执行的命令数目没有要求。使用默认的job solts，值为1，表示make将串行的执行规则的命令（同一时刻只能由一条命令被执行）。 makefile include文件包含当make读取到“lnclude”关键字的时候，会暂停读物当前的makefile，而是去读“include”包含的文件，读取结束后再继续读取当前的makefile文件。 1include &lt;filenames&gt; include使用场景 将共同使用的变量或者模式规则定义在一个文件中，需要的时候用 “include” 包含这个文件。 当根据源文件自动产生依赖文件时，我们可以将自动产生的依赖关系保存在另一个文件中。然后在 Makefile 中包含这个文件。 如果使用 “include” 包含文件的时候，指定的文件不是文件的绝对路径或者是为当前文件下没有这个文件，make 会根据文件名会在以下几个路径中去找，首先我们在执行 make 命令的时候可以加入选项 “-I” 或 “–include-dir” 后面添加上指定的路径，如果文件存在就会被使用，如果文件不存在将会在其他的几个路径中搜索： “usr/gnu/include”、”usr/local/include” 和 “usr/include”。 如果在上面的路径没有找到 “include” 指定的文件，make 将会提示一个文件没有找到的警示提示，但是不会退出，而是继续执行 Makefile 的后续的内容。当完成读取整个 Makefile 后，make 将试图使用规则来创建通过 “include” 指定但不存在的文件。当不能创建的时候，文件将会提示致命错误并退出。 使用时，通常用 “-include” 来代替 “include” 来忽略文件不存在或者是无法创建的错误提示 1-include &lt;filename&gt; 这种情况下，只有在不能正确完成终极目标的重建时，才会提示错误并退出。 为了和其它的make程序进行兼容。也可以使用“sinclude”来代替“-include”（GNU所支持的方式）。 makefile的嵌套执行make不同模块有自己的makefile文件，我们只需要控制其他模块中的makefile就可以实现总体的控制。 我们把最外层的 Makefile 称为是总控 Makefile 12345subsystem: cd subdir &amp;&amp; $(MAKE)# or subsystem: $(MAKE) -C subdir 变量“CURDIR”，代表make的工作目录。当使用make的选项 -C 的时候，命令会进入指定的目录中，这时该变量会被重新赋值为指定目录。 export的使用 如果需要变量的传递（到下一层make），可以使用下列语句 1export &lt;variable&gt; 不需要使用“$“字符。如果所有变量都需要传递，那么只需要使用”export“即可 Makefile中有两个变量不需使用关键字”export“声明，他们总会传递到下层的Makefile中，分别是 SHELL 和 MAKEFLAGS。其中MAKEFLAGS包含了make的参数信息，这是一个系统级别的环境变量。 make命令中有几个参数选项并不传递，它们是：”-C”、”-f”、”-o”、”-h” 和 “-W”。如果我们不想传递 MAKEFLAGS 变量的值，在 Makefile 中可以这样来写： 12subsystem: cd subdir &amp;&amp; $(MAKE) MAKEFLAGS= 嵌套执行make 要提供正确的依赖关系 当 make 发觉它正在递归调用另一个 make 时，他会启 用–print-directory(-w) 选项，这会使得 make 输出 Entering directory(进入目录) 和 Leaving directory(离开目录) 的信息。当 –directory(-C) 选项被使用时，也会启用这个选项。我们还可以看到每一行中，MAKELEVEL 这个 make 变量的值加上方括号之后被一起输出。 makefile变量的高级用法 替换引用 字符串后缀名的替换（同patsubst函数） 123456foo:=a.c b.c d.cobj:=$(foo:.c=.o) # 变量名的后面要使用冒号和参数选项分开，表达式中间不能使用空格# 更通用的写法obj:=$(foo:%.c:%.o) # e.g. $(foo:a%c:x%y)all: @echo $(obj) 嵌套引用 在一个变量的赋值中引用其他的变量（避免使用-别人可能看不懂） 12345first_pass=hellobar=firstvar:=$(bar)_passall: @echo $(var) # 输出结果是hello makefile控制函数error和warning当make执行过程中检测到某些错误时为用户提供消息，并可以控制make执行过程是否继续 1$(error TEXT...) 函数说明如下： 函数功能：产生致命错误，并提示 “TEXT…” 信息给用户，并退出 make 的执行。需要说明的是：”error” 函数是在函数展开时（函数被调用时）才提示信息并结束 make 进程。因此如果函数出现在命令中或者一个递归的变量定义时，读取 Makefile 时不会出现错误。而只有包含 “error” 函数引用的命令被执行，或者定义中引用此函数的递归变量被展开时，才会提示知名信息 “TEXT…” 同时退出 make。 返回值：空 函数说明：”error” 函数一般不出现在直接展开式的变量定义中，否则在 make 读取 Makefile 时将会提示致命错误。 1$(warning TEXT...) 函数说明如下： 函数功能：函数 “warning” 类似于函数 “error” ，区别在于它不会导致致命错误（make不退出），而只是提示 “TEXT…”，make 的执行过程继续。 返回值：空 函数说明：用法和 “error” 类似，展开过程相同。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Cpp learning note","slug":"Cpp-learning-note","date":"2020-12-19T09:37:52.000Z","updated":"2020-12-20T03:24:45.453Z","comments":true,"path":"2020/12/19/Cpp-learning-note/","link":"","permalink":"http://yoursite.com/2020/12/19/Cpp-learning-note/","excerpt":"最近因为项目而学习C++ 学习资源：西北工业大学 C++程序设计、青岛大学 面向对象程序设计（C++和Java） 默认参数C++允许在函数定义或声明时，为形参指定默认值，这样的参数称为默认参数。 （1）如果在函数定义时设置了默认参数，那么就不能在函数声明中再次设置，反之亦然。 （2）可以设置多个默认参数，设置的顺序自右向左，即要设置默认值的参数右边的所有参数都必须是默认参数。 12345int volume(int L, int W, int H = 1);int volume(int L = 1, int W = 1, int H = 1);//上面都是正确的int volume(int L = 1, int W, int H);//错误int volume(int L, int W = 1; int H);//错误 （3）默认值可以是常量、全局变量和函数调用（调用实参必须是常量或全局变量的表达式，不可以是局部变量）","text":"最近因为项目而学习C++ 学习资源：西北工业大学 C++程序设计、青岛大学 面向对象程序设计（C++和Java） 默认参数C++允许在函数定义或声明时，为形参指定默认值，这样的参数称为默认参数。 （1）如果在函数定义时设置了默认参数，那么就不能在函数声明中再次设置，反之亦然。 （2）可以设置多个默认参数，设置的顺序自右向左，即要设置默认值的参数右边的所有参数都必须是默认参数。 12345int volume(int L, int W, int H = 1);int volume(int L = 1, int W = 1, int H = 1);//上面都是正确的int volume(int L = 1, int W, int H);//错误int volume(int L, int W = 1; int H);//错误 （3）默认值可以是常量、全局变量和函数调用（调用实参必须是常量或全局变量的表达式，不可以是局部变量） 函数重载function overloading是在同一个域中用同一个函数名来定义多个函数，但是函数参数列表彼此不同（个数不同或参数类型不同） 编译程序将根据实参和形参的类型和个数的最佳匹配来选择调用哪一个函数 数组作为函数的参数如果实参使用数组名，本质上是将这个数组的首地址传递到形参中。数组实参a传递的是数组首地址，形参A定义为数组形式，此时A 的地址与a一样，本质上形参数组A就是实参数组a（内存中两个对象所处位置相同，则实际上它们是同一个对象） 和指针类似，指针传递的也是地址，这样做可以直接改变多个数组元素，而不用返回 数组参数的传递机制 数组作为函数的参数，传递的是数组的地址（数组在内存中是一段区域内连续的） （1）在被调函数中使用形参就是间接使用实参（与变量不同） （2）函数调用时不会为形参数组分配存储空间，即形参数组的长度无实际作用，所以形参数组甚至可不给出长度 （3）函数如何知道数组的长度-&gt;函数调用时再给出一个参数来表示实参数组的长度 （4）多维数组作为函数的参数，形参数组除第一维任意，其他维的长度需要与实参数组相同 字符串C++语言规定字符串是以’\\0’字符作为结束符的字符数组，空字符表示字符串的结束位置 定义字符数组的长度至少为字符串长度加1（空字符占1位） C++在编译时自动在字符串常量后增加一个空字符 123456789//C++中兼容C语言的字符串处理函数的头文件string.hstrcpy(str1, str2);//copystrncpy(str1, str2, n);//copy前n个strcat(str1, str2);//连接strncat(str1, str2, n);//连接前n个strcmp(str1, str2);//比较字符串strlen(str);//lengthatof(\"123.456\");atoi(\"-456\");//string转换成数值函数 字符串对象采用类来实现字符串 123456#include &lt;string&gt;char S1[20];string str1;char S2[20] = \"Java\";//C风格字符串初始化string str2 = \"Java\";//string对象copy初始化string str3(\"Java\");//string对象直接初始化 string对象允许使用+和复合运算符+=实现连接，可以调用其他成员函数来实现字符串处理（与java中的method相同）","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"summary_about_the_half_year","slug":"summary-about-the-half-year","date":"2020-12-05T13:40:35.000Z","updated":"2021-03-10T06:27:46.739Z","comments":true,"path":"2020/12/05/summary-about-the-half-year/","link":"","permalink":"http://yoursite.com/2020/12/05/summary-about-the-half-year/","excerpt":"","text":"20201205-小记不知不觉研一开学有三个月了，自暑假之后再也没碰过blog，总觉得买域名的钱花的有点不值，换电脑后折腾了两个小时把原来的博客都搬到新电脑上面，换了个主题心情大好~。 三个月其实也没有做什么东西，一直在上课和划水。 RTS：李老师的课听得一脸懵…整个人都不太好，还好有万能的同学们一起讨论。也还好它结课了，整个人都轻松了hhh札记可太难了=_= 近期的小目标是学会C++的基本使用和做项目，当然还有考试和作业。 写的好水啊…没有任何干货（这篇后面会删掉吧hhh","categories":[],"tags":[{"name":"about_life","slug":"about-life","permalink":"http://yoursite.com/tags/about-life/"}]},{"title":"bash","slug":"bash notes","date":"2020-08-15T16:00:00.000Z","updated":"2020-08-16T13:47:38.000Z","comments":true,"path":"2020/08/16/bash notes/","link":"","permalink":"http://yoursite.com/2020/08/16/bash notes/","excerpt":"","text":"bash notes reference: https://wangdoc.com/bash/ 基本语法pwd – 显示当前目录 echo 多行加“ ” 输出文本末尾有回车符 -n参数 取消末尾的回车符 -e参数 解释单双引号中的特殊字符(e.g. \\n) type 判断命令的来源 -a参数 查看命令的所有定义 -t参数 返回一个命令的类型：别名（alias），关键词（keyword），函数（function），内置命令（builtin）和文件（file） 快捷键： Ctrl + L：清除屏幕并将当前行移到页面顶部 Ctrl + C：中止当前正在执行的命令 Shift + PageUp：向上滚动 Shift + PageDown：向下滚动 Ctrl + U：从光标位置删除到行首 Ctrl + K：从光标位置删除到行尾 Ctrl + D：关闭 Shell 会话 ↑，↓：浏览已执行命令的历史记录 模式扩展-&gt;简单的正则 shell接收命令，根据空格拆分为一个个词元，然后扩展词元里的特殊字符。 set -f 开启 set +f 关闭 波浪号 自动扩展成当前用户的主目录 ~+ equal to pwsd 问号 代表文件路径中的任意单个字符，不包含空字符 星号 代表文件路径中任意数量的任意字符，包括零个字符，但是不会匹配隐藏文件，如果需要匹配隐藏文件需要写成.* [...] 匹配方括号中的任意一个字符 [!...] or [^...]是非的表达 匹配连字符- 只能放在方括号内部首尾位置 [start-end] {...} 扩展成大括号里的所有值，各个值之间用逗号分隔，逗号前后不能有空格 {start..end} 大括号扩展的简写形式，支持逆序 {start..end..step}中step为步长 变量扩展 e.g. ${SHELL} 子命令扩展 $(…) 可以扩展为另一个命令的运行结果 算数扩展$((…)) 字符类 [[:alnum:]]：匹配任意英文字母与数字 [[:alpha:]]：匹配任意英文字母 [[:blank:]]：空格和 Tab 键 [[:cntrl:]]：ASCII 码 0-31 的不可打印字符 [[:digit:]]：匹配任意数字 0-9 [[:graph:]]：A-Z、a-z、0-9 和标点符号 [[:lower:]]：匹配任意小写字母 a-z [[:print:]]：ASCII 码 32-127 的可打印字符 [[:punct:]]：标点符号（除了 A-Z、a-z、0-9 的可打印字符） [[:space:]]：空格、Tab、LF（10）、VT（11）、FF（12）、CR（13） [[:upper:]]：匹配任意大写字母 A-Z [[:xdigit:]]：16进制字符（A-F、a-f、0-9）","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"YOLOv4","slug":"YOLOv4 - note","date":"2020-04-27T08:03:05.000Z","updated":"2020-04-28T10:51:48.000Z","comments":true,"path":"2020/04/27/YOLOv4 - note/","link":"","permalink":"http://yoursite.com/2020/04/27/YOLOv4 - note/","excerpt":"","text":"YOLOv4 - note arxiv.org/abs/2004.10934 -&gt; translation: https://tongtianta.site/paper/89863 提高accuracy的通用功能：加权残差链接（WRC）、跨阶段部分连接（CSP）、跨小批量标准化（CmBN）、自对抗训练（SAT）、Mish-activation。 本文结合WRC、CSP、CmBN、SAT、Mish-activation、镶嵌数据增强（augmentation mosaic）、DropBlock regularization、CIoU loss bags of freebies数据增强： photomatric distortion-&gt; 调整图像亮度，对比度，色相，饱和度和噪点 geometric distortion -&gt; 随机缩放，裁剪，翻转和旋转 模拟对象遮挡： random erase、CutOut -&gt; 随机选择图像中的矩形区域填充为0的随机或互补值 hide-and-seek、grid mask -&gt; 随机或均匀地选择图像中的多个矩形区域替换为全0 类似概念应用于feature map有：DropOut、DropConnect、DropBlock DIoU考虑了对象中心的距离、CIoU同时考虑了重叠区域 -&gt; 更好的收敛速度和准确性 bags of specialsplugin modules： 增强接收域：SPP、ASPP、RFB 引入注意力机制（channel-wise、point-wise）：Squeeze-and-Excitation(SE)、Spatial Attention Module(SAM) 集成特征：SFAM、ASFF、BiFPN 激活函数：LReLU、PReLU、ReLU6、SELU、Swish、hard-Swish、Mish post-processing：DIoU NMS 架构选择CSPDarknet53、CSPResNext50","categories":[],"tags":[{"name":"毕业设计","slug":"毕业设计","permalink":"http://yoursite.com/tags/毕业设计/"}]},{"title":"tf2.0","slug":"tf2-0","date":"2020-04-05T02:48:29.000Z","updated":"2020-04-09T10:00:52.000Z","comments":true,"path":"2020/04/05/tf2-0/","link":"","permalink":"http://yoursite.com/2020/04/05/tf2-0/","excerpt":"练习代码 pex 基于tensorflow2.0 tensorflow_vs_pytorchtf1.* 静态图 12345678910111213141516171819import tensorflow as tfprint(tf.__version__) # 1.9.0x = tf.Variable(0.)y = tf.Variable(1.)print(x)print(y)# 构建计算图# x = x + yadd_op = x.assign(x +y)# y = y / 2div_op = y.assign(y / 2)with tf.Session() as sess: sess.run(tf.global_variables_initializer()) for i in range(50): sess.run(add_op) sess.run(div_op) print(x.eval()) tf2.* 动态图 -&gt; tf1.x中调用tf.enable_eager_execution()方法打开eager mode 12345678910import tensorflow as tfprint(tf.__version__) # 2.0.0x = tf.constant(0.)y = tf.constant(1.)for i in range(50): x = x + y y = y / 2print(x.numpy()) PyTorch 动态图 123456789import torchprint(torch.__version__) # 1.4.0x = torch.Tensor([0.])y = torch.Tensor([1.])for i in range(50): x = x + y y = y / 2print(x)","text":"练习代码 pex 基于tensorflow2.0 tensorflow_vs_pytorchtf1.* 静态图 12345678910111213141516171819import tensorflow as tfprint(tf.__version__) # 1.9.0x = tf.Variable(0.)y = tf.Variable(1.)print(x)print(y)# 构建计算图# x = x + yadd_op = x.assign(x +y)# y = y / 2div_op = y.assign(y / 2)with tf.Session() as sess: sess.run(tf.global_variables_initializer()) for i in range(50): sess.run(add_op) sess.run(div_op) print(x.eval()) tf2.* 动态图 -&gt; tf1.x中调用tf.enable_eager_execution()方法打开eager mode 12345678910import tensorflow as tfprint(tf.__version__) # 2.0.0x = tf.constant(0.)y = tf.constant(1.)for i in range(50): x = x + y y = y / 2print(x.numpy()) PyTorch 动态图 123456789import torchprint(torch.__version__) # 1.4.0x = torch.Tensor([0.])y = torch.Tensor([1.])for i in range(50): x = x + y y = y / 2print(x) 分类问题与回归问题 分类问题预测的是类别，模型的输出是概率分布 回归问题预测是值，模型的输出是一个实数值 目标函数 ↓ 分类问题–衡量目标类别与当前预测的差距 e.g. 三分类问题，输出：[0.2, 0.7, 0.1] -&gt; 第1类 真实类别第2类 -&gt; one_hot -&gt; [0, 0, 1] one_hot编码，把正整数变为向量表达，生成一个不小于正整数的向量，只有正整数的位置为1，其余位置为0 分类常用损失函数：平方差损失、交叉熵损失 回归问题–预测值与真实值差距 回归常用损失函数：平方差损失、绝对值损失 回调函数tf.keras.callbacks EarlyStopping ModelCheckpoint TensorBoard 在命令行中调用tensorboard：tensorboard –logdir=[你的文件夹名称]","categories":[],"tags":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://yoursite.com/tags/tensorflow/"}]},{"title":"YOLOv3","slug":"YOLOv3","date":"2020-04-01T17:29:04.000Z","updated":"2020-04-04T14:36:14.000Z","comments":true,"path":"2020/04/02/YOLOv3/","link":"","permalink":"http://yoursite.com/2020/04/02/YOLOv3/","excerpt":"","text":"论文地址 YOLOv3结构图 DBL：卷积 + BN(Batch Normalization) + Leaky relu resn：n表示包含的res_unit个数 concat：张量拼接，拼接会扩充张量的维度 backboneDarknet-53没有设置池化层和全连接层，而通过改变卷积核的步长进行张量的尺寸变换，在yolov3中没有最后的全局平均池化层，所以张量变化只考虑5层。 outputy1、y2、y3深度都是255 = 3*（5+80），其中5是bbox的5个参数，80是COCO数据集的类别数。","categories":[],"tags":[{"name":"毕业设计","slug":"毕业设计","permalink":"http://yoursite.com/tags/毕业设计/"}]},{"title":"ResNet","slug":"ResNet","date":"2020-03-18T03:05:41.000Z","updated":"2020-04-04T14:36:10.000Z","comments":true,"path":"2020/03/18/ResNet/","link":"","permalink":"http://yoursite.com/2020/03/18/ResNet/","excerpt":"","text":"残差网路 这是一个两层神经网络。 计算过程从a[l]开始，先进行线性运算。$$z^{[l+1] }= W^{[l+1]}a^{[l]} + b^{[l+1]}$$在由激活函数g得到a[l+1]，这里g是线性整流函数relu$$a^{[l+1]} = g(z^{[l+1]})$$随后进行第二层线性运算$$z^{[l+2]} = W^{[l+2]}a^{[l+1]} + b^{[l+2]}$$再经过Relu$$a^{[l+2]} = g(z^{[l+2]})$$在残差网络中加入一点变化 即”跳远连接”$$a^{[l+2]} = g(z^{[l+2]} + a^{[l]})$$这样，随着网络的加深，训练误差也跟着下降。","categories":[],"tags":[{"name":"deeplearning","slug":"deeplearning","permalink":"http://yoursite.com/tags/deeplearning/"}]},{"title":"Linux指令","slug":"Linux指令","date":"2020-03-17T07:09:23.000Z","updated":"2020-04-01T17:33:20.000Z","comments":true,"path":"2020/03/17/Linux指令/","link":"","permalink":"http://yoursite.com/2020/03/17/Linux指令/","excerpt":"","text":"https://www.jianshu.com/nb/37698552 https://www.jianshu.com/p/8c2af151ddc2 https://www.runoob.com/linux/linux-shell.html linux命令大全","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"VID","slug":"VID","date":"2020-03-15T12:53:26.000Z","updated":"2020-03-16T14:44:00.000Z","comments":true,"path":"2020/03/15/VID/","link":"","permalink":"http://yoursite.com/2020/03/15/VID/","excerpt":"reference paper： 陈志欣. 基于深度学习的视频目标检测算法研究与应用[D].北方工业大学,2019. 视频目标检测（object detection from video） 从2015年开始，ILSVRC新增了VID挑战任务，视频中的目标检测难题：更多的帧图像文件、由于速度快导致运动模糊和光照等问题、物体间的遮挡问题。 数据集预处理 归一化：将原始像素压缩到[0,1]区间 $$\\text { norm }=\\frac{x_{i}-\\min (x)}{\\max (x)-\\min (x)}$$ 去均值化：对每个通道，移除图像的平均亮度，凸显个体差异 $$x_{r}, x_{g}, x_{b}=\\left(x_{r}-R_{m e a n}, x_{g}-G_{m e a n}, x_{b}-B_{m e a n}\\right)$$ 标准化：使像素符合标准正态分布，在样本尺度不一致的情况下（如不同相机采集的图片，或者是来源不同的图片） $$x^{\\prime}=\\frac{x-\\mu}{\\sigma}$$","text":"reference paper： 陈志欣. 基于深度学习的视频目标检测算法研究与应用[D].北方工业大学,2019. 视频目标检测（object detection from video） 从2015年开始，ILSVRC新增了VID挑战任务，视频中的目标检测难题：更多的帧图像文件、由于速度快导致运动模糊和光照等问题、物体间的遮挡问题。 数据集预处理 归一化：将原始像素压缩到[0,1]区间 $$\\text { norm }=\\frac{x_{i}-\\min (x)}{\\max (x)-\\min (x)}$$ 去均值化：对每个通道，移除图像的平均亮度，凸显个体差异 $$x_{r}, x_{g}, x_{b}=\\left(x_{r}-R_{m e a n}, x_{g}-G_{m e a n}, x_{b}-B_{m e a n}\\right)$$ 标准化：使像素符合标准正态分布，在样本尺度不一致的情况下（如不同相机采集的图片，或者是来源不同的图片） $$x^{\\prime}=\\frac{x-\\mu}{\\sigma}$$ 数据增强：解决样本数量和质量不满足需求的问题 镜像翻转、随机旋转、随机错切、高斯噪声、椒盐噪声、明亮度变化（不加入影响图像本质特性的噪声） 性能指标 mAP、IoU、FPS、NMS 可变形卷积（Deformable Convolution）-&gt; 了解卷积的多种方式 refer to https://arxiv.org/pdf/1703.06211.pdf 对小目标物体的检测 数据增强：用不同尺度的图片进行训练 × SPP 空间池化金字塔 × SSD 在不同尺度的特征图上引入区域检测机制 （提高有限） × FPN网络 自下而上的前馈计算（池化采样），自下而上的特征融合与横向连接（最近邻上采样或双线性插值），横向对应的层特征图各像素点之间直接相加，融合后的特征还要进行3*3卷积以消除upsampling产生的混叠作用。 网络的训练损失函数 这一块真的看的我眼花… 回归损失 均方误差/平方损失/L2 损失：$$M S E=\\frac{\\sum_{i=1}^{n}\\left(y_{i}-\\hat{y}_{i}\\right)^{2}}{n}$$平均绝对误差/L1 损失： $$M A E=\\frac{\\sum_{i=1}^{n}\\left|y_{i}-\\hat{y}_{i}\\right|}{n}$$ 平均偏差误差（mean bias error）： $$M B E=\\frac{\\sum_{i=1}^{n}\\left(y_{i}-\\hat{y}_{i}\\right)}{n}$$ 分类损失 Hinge Loss/多分类 SVM 损失： $$S V M L o s s=\\sum_{j \\neq y_{i}} \\max \\left(0, s_{j}-s_{y_{i}}+1\\right)$$ 交叉熵损失/负对数似然： $$CrossEntropyLoss = -\\left( y_{i} \\log \\left( \\hat{y} _ {i} \\right) + \\left( 1-y _ {i} \\right) \\log \\left(1- \\hat{y}_{i} \\right) \\right)$$剩余词条待补充：multi-task loss、facol loss、GIoU、DIoU refer to：https://zhuanlan.zhihu.com/p/112057799 YOLOv3中用k-means聚类得到anchor大小和数量设置 VID流程 Image_Feature = N_feat(Image_input) -&gt; Output = N_det(Image_Feature)提取候选框进行分类回归 Deap Feature Flow利用一种基于卷积操作的FlowNet生成前后帧的光流图，再叠加上前一时刻关键帧信息，生成本时刻关键帧最终的特征图。 FGFA将相邻帧在时序上的特征聚合到当前帧的特征中，处理运动模糊、视频散焦、奇特姿势等问题。 稀疏特征传播方式提高检测速度 DFF 每隔n张（n常取10）抽取一个关键帧得到特征图，非关键帧的特征图计算为最近邻关键帧以及其与当前非关键帧之间运动变化矢量的加和。通常用光流矢量定量计算临近两帧之间的信息差值。 -&gt; FlowNet如何实现 密集特征聚合方式提高检测精度 FGFA 需要计算视频每一帧的特征图，对视频的第i个时刻的关键帧，给每个时间帧分配一定权重系数，来对前后i+2r个特征图对应位置的值加权求和。 -&gt; 权重如何分配 关键帧的选择优化 基于特征一致性的关键帧调度策略： $$key = is_{-}key \\left( B_{k \\rightarrow i} \\right)$$ $$i s_{k e y}\\left(Q_{k \\rightarrow i}\\right) = \\left [ \\frac{1}{N_{p}} \\sum_{p} 1 \\left ( B_{k \\rightarrow i}(p) \\leq \\tau \\right ) \\right ] &gt; \\gamma$$前后两个参数分别设置为0.1 和 0.2 FlowNetSimple作为光流计算网络 设计Tubelet结构存放低检测关键帧前后r帧信息，做密特征聚合使用，优化此关键帧的检测精度。","categories":[],"tags":[{"name":"cv","slug":"cv","permalink":"http://yoursite.com/tags/cv/"}]},{"title":"Anaconda使用tips","slug":"Anaconda使用tips","date":"2020-03-13T11:57:12.000Z","updated":"2020-03-13T12:59:02.000Z","comments":true,"path":"2020/03/13/Anaconda使用tips/","link":"","permalink":"http://yoursite.com/2020/03/13/Anaconda使用tips/","excerpt":"","text":"今天为了安装tensorflow踩了不少坑🤢，主要是anaconda环境安装的问题，写点笔记记下来 新建一个虚拟环境 conda create -n 环境名 python=3.7 （版本自己选择），创建的环境在./envs文件夹下。 conda activate 环境名 激活 conda deactivate 关闭回到base环境 conda remove -n 环境名 –all 删除已有环境 conda list 查看已安装package 换源就不说了，注意在修改.condarc文件时如果运行报错，把里面的https改为http即可。 因为直接使用conda下载速度太慢，所以选择离线安装。首先在清华镜像源下载tensorflow和opencv，选择对应平台和python版本的.whl文件，放在./Lib/site-packages/文件夹下。cd到当前目录，pip install xxxx.whl安装即可。如果出现报错无法定位程序输入点的问题把Anaconda3/DLLS下libssl-1_1-x64.dll文件到覆盖Anaconda3/Library/bin中，一路yes就可以完成安装。安错版本pip uninstall tensorflow卸载 在选择tensorflow版本的时候，注意自己的电脑是否支持当前版本。 reference： 无法定位程序输入点 tf2.0安装 版本选择","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"DL_tools","slug":"DL-tools","date":"2020-03-12T08:50:55.000Z","updated":"2020-03-12T09:13:58.000Z","comments":true,"path":"2020/03/12/DL-tools/","link":"","permalink":"http://yoursite.com/2020/03/12/DL-tools/","excerpt":"","text":"一些深度学习框架 Caffe：代码基于C++（训练速度快），入门级、上手快（修改一些配置文件即可），适合新手了解深度学习任务中的各种参数； Keras：基于Theano或TensorFlow的高级框架，可快速构建网络，不用了解网络的底层设计； TensorFlow：有高级的API（tf.Keras等），也可以自己从零开始构建一个新的网络，但是1.x版本静态图问题不好调试，2.0貌似解决了这个问题（尝试使用这个做毕设，不知道学长用的是哪个）； Pytorch：科研人员都说好用的框架，上手快、好搭建，但是工业上采用tensorflow更多。","categories":[],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://yoursite.com/tags/深度学习/"}]},{"title":"CNN","slug":"CNN","date":"2020-03-06T13:23:00.000Z","updated":"2020-03-06T13:42:58.000Z","comments":true,"path":"2020/03/06/CNN/","link":"","permalink":"http://yoursite.com/2020/03/06/CNN/","excerpt":"","text":"Convolutional Neural Network1. 输入层原始图片，在计算机内用构成像素点的多维矩阵来表示。 2. 隐层convolution卷积：过滤特征 ReLU线性修正单元：激活函数 polling池化：降低维度并提高模型的容错性 降低模型的参数数目 局部感知野：每个神经元只需要对局部图像进行感知，然后在更高层将局部的信息综合起来得到全局的信息； 权值共享：对于每一层来讲，所有神经元对应的权值参数是一样的，同一层下的神经元连接参数只与特征提取的方式有关，而与具体的位置无关。 第一层隐层一般是用来做边缘和曲线检测 第二层隐层对第一层学到的边缘曲线组合得到的一些特征 第三层则会学到一些更复杂的特征 ReLU激活函数 引入非线性激励函数，深层网络具有意义（不再是输入的线性组合，可以逼近任意函数） 为什么采用ReLU函数：1. 采用sigmoid等函数，计算量大，反向传播求误差梯度时涉及除法；2. 对于深层网络，sigmoid函数反向传播时，容易出现梯度消失的情况（sigmoid接近饱和区时，变换太缓慢，导数趋于0，容易造成信息丢失），从而无法完成深层网络的训练；3. ReLU会使一部分神经元的输出为0，造成了网络的稀疏性，并减少了参数的相互依存关系，缓解了过拟合问题的发生。 pooling池化（欠采样） 主要有max、average、sum等不同类型的操作 3. 输出层经过若干次的卷积+线性修真+pooling，模型会将学到的高水平特征接到一个全连接层，通过softmax函数得到输出。","categories":[],"tags":[{"name":"NN","slug":"NN","permalink":"http://yoursite.com/tags/NN/"}]},{"title":"TexLive_installation","slug":"TexLive-installation","date":"2019-07-11T08:02:40.000Z","updated":"2019-08-18T07:19:16.000Z","comments":true,"path":"2019/07/11/TexLive-installation/","link":"","permalink":"http://yoursite.com/2019/07/11/TexLive-installation/","excerpt":"TexLive + VScode 搭建LaTex编译环境最近对LaTex十分感兴趣（因为好看），百度了很多教程，最后决定在VScode上配置环境。","text":"TexLive + VScode 搭建LaTex编译环境最近对LaTex十分感兴趣（因为好看），百度了很多教程，最后决定在VScode上配置环境。 下载TexLive镜像文件(清华大学镜像)，选择texlive2019.iso下载即可； iso文件解压后，在文件夹中点击install-tl-advanced.bat或install-tl-windows.bat文件均可，其中可进行一些安装地址和组件的配置，安装时间较长； 在VScode中安装插件：LaTex language support, LaTex Workshop 对latex编译环境进行配置：在设置中搜索latex，对setting.json进行编辑，加入以下代码段： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&quot;latex-workshop.latex.tools&quot;: [ &#123; &quot;name&quot;: &quot;latexmk&quot;, &quot;command&quot;: &quot;latexmk&quot;, &quot;args&quot;: [ &quot;-synctex=1&quot;, &quot;-interaction=nonstopmode&quot;, &quot;-file-line-error&quot;, &quot;-pdf&quot;, &quot;%DOC%&quot; ] &#125;, &#123; &quot;name&quot;: &quot;xelatex&quot;, &quot;command&quot;: &quot;xelatex&quot;, &quot;args&quot;: [ &quot;-synctex=1&quot;, &quot;-interaction=nonstopmode&quot;, &quot;-file-line-error&quot;, &quot;%DOC%&quot; ] &#125;, &#123; &quot;name&quot;: &quot;pdflatex&quot;, &quot;command&quot;: &quot;pdflatex&quot;, &quot;args&quot;: [ &quot;-synctex=1&quot;, &quot;-interaction=nonstopmode&quot;, &quot;-file-line-error&quot;, &quot;%DOC%&quot; ] &#125;, &#123; &quot;name&quot;: &quot;bibtex&quot;, &quot;command&quot;: &quot;bibtex&quot;, &quot;args&quot;: [ &quot;%DOCFILE%&quot; ] &#125; ], &quot;latex-workshop.latex.recipes&quot;: [ &#123; &quot;name&quot;: &quot;xelatex&quot;, &quot;tools&quot;: [ &quot;xelatex&quot; ] &#125;, &#123; &quot;name&quot;: &quot;pdflatex&quot;, &quot;tools&quot;: [ &quot;pdflatex&quot; ] &#125;, &#123; &quot;name&quot;: &quot;latexmk&quot;, &quot;tools&quot;: [ &quot;latexmk&quot; ] &#125;, &#123; &quot;name&quot;: &quot;pdflatex -&gt; bibtex -&gt; pdflatex*2&quot;, &quot;tools&quot;: [ &quot;pdflatex&quot;, &quot;bibtex&quot;, &quot;pdflatex&quot;, &quot;pdflatex&quot; ] &#125; ], &quot;latex-workshop.view.pdf.viewer&quot;: &quot;tab&quot;, &quot;latex-workshop.latex.clean.subfolder.enabled&quot;: true //这里要选择true清除编译过程中产生的文件 创建文件test.tex，Ctrl+S保存编译，得到PDF文件。 123456789101112\\documentclass[UTF8]&#123;ctexart&#125; \\title&#123;TexLive + VScode 环境配置&#125; \\author&#123;Silhouettes&#125; \\date&#123;\\today&#125; \\begin&#123;document&#125; \\maketitle This is the beginning of the article.\\\\ 编译成功！\\\\ $ &#123;f&#125;&apos;(0) = \\left. \\frac&#123;df&#125;&#123;dx&#125; \\right|_&#123;x=0&#125; $\\end&#123;document&#125; 这里要注意tex文件要按utf-8编码，如果编译后出现乱码，可以更换编码方式重新保存后再编译一次。","categories":[],"tags":[{"name":"LaTex","slug":"LaTex","permalink":"http://yoursite.com/tags/LaTex/"}]},{"title":"latex2word","slug":"latex2word","date":"2019-07-06T10:21:19.000Z","updated":"2019-08-18T07:20:10.000Z","comments":true,"path":"2019/07/06/latex2word/","link":"","permalink":"http://yoursite.com/2019/07/06/latex2word/","excerpt":"","text":"latex2word突然想，能不能把在latex上生成的数学公式导入word里面，因为word自带的公式编辑器确实不是很好用，相较之下latex生成的公式十分精致。 搜到了很多教程，挑了我觉得最方便的一种： 先用Mathpix把需要的公式截图翻译成latex语言，再copy到Online LaTeX Equation Editor网站，在MathJax框右键Show Math As项MathML Code选项，在word中 Alt 加 = 快捷键生成一个公式文本框将前面弹出界面的代码全部复制粘贴即可。 当然这是一种偷懒的方法，在Word2016中的公式编辑器中已经支持了一部分的LaTeX语法（比如\\partial、\\sum等等），可以很方便地输入一些简单的公式。 这个方法主要是用来抄理论的时候快速打出公式用的（不是。 /暑假愉快","categories":[],"tags":[{"name":"daily","slug":"daily","permalink":"http://yoursite.com/tags/daily/"}]},{"title":"tensorflow_learning_2","slug":"tensorflow-learning-2","date":"2019-05-20T11:53:43.000Z","updated":"2019-05-20T13:57:36.000Z","comments":true,"path":"2019/05/20/tensorflow-learning-2/","link":"","permalink":"http://yoursite.com/2019/05/20/tensorflow-learning-2/","excerpt":"","text":"tensorflow学习笔记_2计算图与张量TensorFlow中的计算可以表示为一个有向图（计算图），其中每一个运算操作作为一个节点，节点与节点的连接称为边，一张计算图描述了数据的计算流程，我们可以对计算图上的各个分支进行改变来达到我们的运算目的。在计算图的边中流动的数据被称为张量（tensor），张量的数据类型可以事先定义，也可以通过计算图的结构推导得出。 一个运算操作代表了一类抽象运算（如矩阵乘法或向量加法），运算操作必须有自己的属性，但是所有属性都必须被预先设置，或者在计算图沿着边运行时可以被推断出来。 会话 Sessionsession是用户使用tensorflow的互交式接口，用户可以通过session的Extend方法添加新的节点和边来创建计算图，然后通过session的Run方法执行计算图。 大多数运算中，tensor不会一直保留下去。而Variable是一类特殊的运算操作，可以将一些需要保留的tensor储存在内存或者显存当中。每执行一次计算图后，Variable中的tensor都会被保存，同时在计算过程中，tensor的值也可以被更新。 csdn上还是有很多的教程 概念理解 MNIST手写数字识别1234567from tensorflow.examples.tutorials.mnist import input_dataimport tensorflow as tfmnist = input_data.read_data_sets(\"MNIST_data/\", one_hot=True)print(mnist.train.images.shape,mnist.train.labels.shape)print(mnist.test.images.shape,mnist.test.labels.shape)print(mnist.validation.images.shape,mnist.validation.labels.shape) 结果输出为 (55000, 784) (55000, 10)(10000, 784) (10000, 10)(5000, 784) (5000, 10) 一个例程 存","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/机器学习/"}],"tags":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://yoursite.com/tags/tensorflow/"}]},{"title":"tensorflow_learning_1","slug":"tensorflow-learning-1","date":"2019-05-19T09:40:58.000Z","updated":"2019-05-20T13:23:06.000Z","comments":true,"path":"2019/05/19/tensorflow-learning-1/","link":"","permalink":"http://yoursite.com/2019/05/19/tensorflow-learning-1/","excerpt":"","text":"tensorflow学习笔记_1环境安装 CPU版本的tensorflow 安装anaconda或者miniconda 这里附上 一个很完整的参考教程，因为我的anaconda安装了python3.7，而3.5对tensorflow的兼容性最好（听说，所以在anaconda中新建一个环境安装python3.5和tensorflow1.13.1。 首先 conda creat -n tensorflow python=3.5 新建一个环境名字为tensorflow，然后发现Anaconda3/envs/目录下出现了tensorflow的文件夹。 激活环境 activate tensorflow，关闭这个环境用命令 deactivate 安装tensorflow conda install tensorflow conda安装比pip要方便不少，而且conda安装的tf效率要比pip安装的高。 验证是否安装成功 1234import tensorflow as tfhello = tf.constant('Hello,tensorflow')sess = tf.Session()print(sess.run(hello)) 报错的话加上这段话 12import os os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2' tips：上面的方法将tensorflow安装在一个单独的环境当中，其他模块如numpy、opencv等都要重新配置，尝试将/Anaconda3/envs/tensorflow文件夹全部复制到/Anaconda3/Lib/site-packages下运行（参考了一篇安装在linux上的文章，结果不是很理想，放弃。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/机器学习/"}],"tags":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://yoursite.com/tags/tensorflow/"}]},{"title":"CDN_jsdelivr","slug":"CDN-jsdelivr","date":"2019-05-06T05:08:48.000Z","updated":"2019-05-08T10:31:30.000Z","comments":true,"path":"2019/05/06/CDN-jsdelivr/","link":"","permalink":"http://yoursite.com/2019/05/06/CDN-jsdelivr/","excerpt":"blog引用资源路径由本地替换为CDN 内容分发网络（Content Delivery Network），依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。 由于GitHub资源在国内加载过慢，有很多人选择通过CDN来提高资源加载速度，我选择了免费、速度快的jsdelivr，CDN的本质是缓存。","text":"blog引用资源路径由本地替换为CDN 内容分发网络（Content Delivery Network），依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。 由于GitHub资源在国内加载过慢，有很多人选择通过CDN来提高资源加载速度，我选择了免费、速度快的jsdelivr，CDN的本质是缓存。 1. 在GitHub上Create a new repository得到repository name 2. clone 这个仓库到本地在文件夹下git bash here 1git clone 你的仓库地址 3. 上传资源1234git status # 查看仓库状态git add . # 所有文件添加至缓存区git commit -m &quot;your_commit&quot;git push # 推送至远端仓库 4. 发布仓库点击releases，版本号自定义 5. 引用资源通过路径： 12https://cdn.jsdelivr.net/gh/user/repo@version/filehttps://cdn.jsdelivr.net/gh/你的github用户名/你的仓库名@发布的版本号/文件路径 可以CDN引用资源啦~","categories":[{"name":"HEXO搭建","slug":"HEXO搭建","permalink":"http://yoursite.com/categories/HEXO搭建/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"CDN","slug":"CDN","permalink":"http://yoursite.com/tags/CDN/"}]},{"title":"some_thoughts","slug":"some-thoughts","date":"2019-05-03T16:36:43.000Z","updated":"2019-05-08T14:36:42.000Z","comments":true,"path":"2019/05/04/some-thoughts/","link":"","permalink":"http://yoursite.com/2019/05/04/some-thoughts/","excerpt":"some_thoughts晚上花了一个小时修改了blog的主题，最近电脑看吐，又想一个星期不开电脑，日子会是多么快活。又后悔当初为什么不去学文科kkk… 找了很久才发现，自上次更新了主题后，默认使用cdn加载css，注释掉才会使用本地less文件进行渲染（看到Github上有人跟我遇到了一样的问题hhh，不知道他解决了没有）","text":"some_thoughts晚上花了一个小时修改了blog的主题，最近电脑看吐，又想一个星期不开电脑，日子会是多么快活。又后悔当初为什么不去学文科kkk… 找了很久才发现，自上次更新了主题后，默认使用cdn加载css，注释掉才会使用本地less文件进行渲染（看到Github上有人跟我遇到了一样的问题hhh，不知道他解决了没有） 最近有一个关于朋友的胡思乱想 有兴趣就看看吧 另，Trpora实在是太好用了不得不推荐一下 评论区欢迎留言","categories":[{"name":"HEXO搭建","slug":"HEXO搭建","permalink":"http://yoursite.com/categories/HEXO搭建/"}],"tags":[{"name":"daily","slug":"daily","permalink":"http://yoursite.com/tags/daily/"},{"name":"胡思乱想","slug":"胡思乱想","permalink":"http://yoursite.com/tags/胡思乱想/"}]},{"title":"import_pdb","slug":"import-pdb","date":"2019-03-30T14:58:26.000Z","updated":"2019-05-08T10:31:42.000Z","comments":true,"path":"2019/03/30/import-pdb/","link":"","permalink":"http://yoursite.com/2019/03/30/import-pdb/","excerpt":"pdb – the python debugger最近在python学习中用到了pdb调试模块（在没有IDE的情况下debug应该特别好用）,做一点笔记： 首先, import pdb, 在需要调试的地方设置断点 pdb.set_trace(), 执行程序进入断点。","text":"pdb – the python debugger最近在python学习中用到了pdb调试模块（在没有IDE的情况下debug应该特别好用）,做一点笔记： 首先, import pdb, 在需要调试的地方设置断点 pdb.set_trace(), 执行程序进入断点。 常用命令 命令 功能 next(n) 执行下一行 exit(q) 中止调试并退出 continue(c) 停止debug继续执行程序 where(w) 找出当前代码的运行位置 list(l) 显示当前行的代码段 print(p) 打印变量的值 step(s) 进入函数 return(r) 执行代码直到当前函数返回(return) help 帮助 参考python pdb模块 官方文档 版本：3.7 The module pdb defines an interactive source code debugger for Python programs. It supports setting (conditional) breakpoints and single stepping at the source line level, inspection of stack frames, source code listing, and evaluation of arbitrary Python code in the context of any stack frame. It also supports post-mortem debugging and can be called under program control.","categories":[{"name":"Python学习","slug":"Python学习","permalink":"http://yoursite.com/categories/Python学习/"}],"tags":[{"name":"learning","slug":"learning","permalink":"http://yoursite.com/tags/learning/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"About_https","slug":"About-https","date":"2019-03-21T04:20:34.000Z","updated":"2019-05-08T10:31:44.000Z","comments":true,"path":"2019/03/21/About-https/","link":"","permalink":"http://yoursite.com/2019/03/21/About-https/","excerpt":"","text":"Cloudflare给域名加个s Here at Cloudflare, we make the Internet work the way it should. Offering CDN, DNS, DDoS protection and security, find out how we can help your site. 上完课回宿舍看到一篇博主的推送要给自己的个人网站加个s，所以我决定也给自己的blog加个s。 超文本传输协议HTTP以明文的方式发送信息，而安全套接字层超文本传输协议HTTPS在HTTP的基础上加入了SSL协议，对传输的信息进行了加密，提高了安全性。 有两种方法，一是用Cloudflare提供的免费https服务，二是在阿里云免费申请一个一年的免费证书，我选择了前者： 在Cloudflare上注册一个账号; Add websites：输入自己的域名; Add DNS Records：Cloudflare会将扫描到的DNS记录展示在页面上，如果记录符合Cloudflare的要求，会在记录的Status中显示一个橙色的云在箭头上的图标，如果没有则需要自己添加需要的DNS记录; Select Plan：Free website，可以免费使用; Update Nameservers：Cloudflare提供了新的DNS服务器地址，在域名注册商(我用了阿里云）的域名设置中将之前的DNS服务器地址替换掉即可,等待一段时间后域名映射在服务器上; Enable Https：在Crypto中设置 SSL 为 Flexible，Always Use HTTPS 选项为on(将http都重定向为https); Create Pages Rules：Page Rules中设置路由规则，输入 username.top/*(即你的域名)，网站上的解释很清楚，结束。 等待一段时间就可以看到自己的域名前面出现了https啦~","categories":[{"name":"HEXO搭建","slug":"HEXO搭建","permalink":"http://yoursite.com/categories/HEXO搭建/"}],"tags":[{"name":"learning","slug":"learning","permalink":"http://yoursite.com/tags/learning/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"a_tool","slug":"a-tool","date":"2019-03-15T15:47:59.000Z","updated":"2019-05-04T04:22:38.000Z","comments":true,"path":"2019/03/15/a-tool/","link":"","permalink":"http://yoursite.com/2019/03/15/a-tool/","excerpt":"","text":"深夜的发现围观了大佬的公众号，想从github上面把代码下载下来学习一下,但是遇到了要把一整个仓库的文件都clone下来的问题…于是百度了下载指定文件夹下文件的做法，发现最简单的方法是把链接直接复制在Downgit网站上(这里附上MinhasKamal/DownGit的网址: DownGit)，下载即可。但是又遇到了网站加载不出来的问题，最后发现了另一个大佬移植的网站，尽管这个网址的资源加载也有问题，但是总的来说还可以用，就是等待时间可能会比较长，给人的感觉是这个网站也不能用(嗯？？我折腾了这么久还是不能用？？)，看样子已经是很久没有人维护了…网址如下: 周大侠啊DownGit安了pygame模块就可以愉快地玩游戏啦~另，最近觉得很有意思的表情包上面的梗，以及附上新的md语法介绍：MarkDown基本语法12345public static void main(String[] args)&#123; String s=\"\\u4f18\\u79c0\"; System.out.println(s);&#125;","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"update","slug":"update","date":"2019-03-01T12:38:21.000Z","updated":"2019-05-08T10:28:02.000Z","comments":true,"path":"2019/03/01/update/","link":"","permalink":"http://yoursite.com/2019/03/01/update/","excerpt":"","text":"注册了域名解析到博客网址上面 开学一周四节课正是很闲的时候其实是闲得无聊又不想学习，花时间把这个博客搭好了，感觉像学cadence和mul一样…熟能生巧吧。 阿里云据说比腾讯云更安全一点，但是价格上感觉两家差不多。 另，找了一篇Markdown基本语法的介绍，如下：Markdown","categories":[{"name":"HEXO搭建","slug":"HEXO搭建","permalink":"http://yoursite.com/categories/HEXO搭建/"}],"tags":[{"name":"daily","slug":"daily","permalink":"http://yoursite.com/tags/daily/"}]},{"title":"my_first_blog","slug":"my-first-blog","date":"2019-03-01T08:37:32.000Z","updated":"2020-12-05T13:42:12.033Z","comments":true,"path":"2019/03/01/my-first-blog/","link":"","permalink":"http://yoursite.com/2019/03/01/my-first-blog/","excerpt":"写在开头 花了半个下午的时间弥补了上个学期搞不定hexo的遗憾，现在依旧不太清楚node出了什么问题npm的时候总是报错(WARN，不过总算是能发布到github上面了。暂时没有注册域名的打算。","text":"写在开头 花了半个下午的时间弥补了上个学期搞不定hexo的遗憾，现在依旧不太清楚node出了什么问题npm的时候总是报错(WARN，不过总算是能发布到github上面了。暂时没有注册域名的打算。 看了很多blog觉得这篇很有用：hexo + github搭建个人blog","categories":[{"name":"HEXO搭建","slug":"HEXO搭建","permalink":"http://yoursite.com/categories/HEXO搭建/"}],"tags":[{"name":"daily","slug":"daily","permalink":"http://yoursite.com/tags/daily/"}]}],"categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/机器学习/"},{"name":"HEXO搭建","slug":"HEXO搭建","permalink":"http://yoursite.com/categories/HEXO搭建/"},{"name":"Python学习","slug":"Python学习","permalink":"http://yoursite.com/categories/Python学习/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"omnetpp","slug":"omnetpp","permalink":"http://yoursite.com/tags/omnetpp/"},{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"about_life","slug":"about-life","permalink":"http://yoursite.com/tags/about-life/"},{"name":"毕业设计","slug":"毕业设计","permalink":"http://yoursite.com/tags/毕业设计/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://yoursite.com/tags/tensorflow/"},{"name":"deeplearning","slug":"deeplearning","permalink":"http://yoursite.com/tags/deeplearning/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"cv","slug":"cv","permalink":"http://yoursite.com/tags/cv/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"深度学习","slug":"深度学习","permalink":"http://yoursite.com/tags/深度学习/"},{"name":"NN","slug":"NN","permalink":"http://yoursite.com/tags/NN/"},{"name":"LaTex","slug":"LaTex","permalink":"http://yoursite.com/tags/LaTex/"},{"name":"daily","slug":"daily","permalink":"http://yoursite.com/tags/daily/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"CDN","slug":"CDN","permalink":"http://yoursite.com/tags/CDN/"},{"name":"胡思乱想","slug":"胡思乱想","permalink":"http://yoursite.com/tags/胡思乱想/"},{"name":"learning","slug":"learning","permalink":"http://yoursite.com/tags/learning/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]}